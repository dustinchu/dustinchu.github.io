<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用jxl將excel-讀到JAVA上]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87excel-%E8%AE%80%E5%88%B0JAVA%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[使用 jxl 把Excel讀取到java 上一篇 把資料寫入到Excel 這篇就順便將讀取到java補上了說明都打在註解上了!!就不在多做說明了 java123456789101112131415161718192021222324252627282930313233343536373839404142package excel;import java.io.File;import java.io.IOException;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;import jxl.read.biff.BiffException;public class ReadExcel&#123; //JXL讀取EXCEL public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //建立 workbook Workbook workbook = Workbook.getWorkbook(new File("C:/jxl_test.xls")); //得到第一個工作表 Sheet sheet = workbook.getSheet(0); //取得資料 for (int i = 0; i &lt; sheet.getRows(); i++) //行 &#123; for (int j = 0; j &lt; sheet.getColumns(); j++)//列 &#123; Cell cell= sheet.getCell(j,i); System.out.print(cell.getContents()+" "); &#125; System.out.println(); //換行 &#125; workbook.close(); //將workbook關閉 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將java資料導入excel]]></title>
      <url>%2F2017%2F03%2F27%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87java%E8%B3%87%E6%96%99%E5%B0%8E%E5%85%A5excel%2F</url>
      <content type="text"><![CDATA[使用java_將資料導入excel 最近在把公司舊的ERP HR系統 移植出來必須要用最快的方式移植出來不然我本來的專案會趕不上進度順便找時間記錄一下最近開發紀錄 excel 幾種實現方式!POI poi 是 apache poi開放源碼函式庫提供java對 Microsoft office 格式檔案讀寫功能通過HSSF可以使用純JAVA代碼來讀取 寫入 修改EXCELHSSF -讀寫Microsoft Excel格式檔案功能(只支援97-2003)XSSF -讀寫Microsoft Excel OOXML格式檔案功能HWPF -讀寫讀寫Microsoft Word格式檔案功能HSLF -讀寫讀寫Microsoft PowerPoint格式檔案功能HDGF -讀寫讀寫Microsoft Visio格式檔案功能-iText 可以通過iText 來建立PDF 只需在classpath加入iText.jar JXL 有興趣的在去查一下 FASTEXCEL 是一個採用純java 開發的excel文件讀寫組件 支持Excel 97-2003fastExcel 只能讀取單元格的字串資料其他屬性 像是顏色 字體就不支持 但也因為這樣FastExcel 需要用到的記憶體很少 JXL java excel 可以讀取Excel文件內容 建立excel文件 更新已存在的excel POI JXK 比較 效率高 功能強大使用上比較複雜 支持公式 圖表 能夠修改單元屬性格 支持字體 數字 日期操作 JXL 效率低 操作簡單 部分支援 能夠修改單元格屬性 但不比POI強大 支援字體 數字 日期 使用JXL程式碼實例 程式都註解上去了!由於時間的關係需要快速的去開發就嘗試幾個方法開發 需要更快速的來去完成工作才是目標所以選擇使用 JXL 有空再把POI程式碼貼上來 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package excel;import java.awt.Label;import java.io.File;import java.io.IOException;import jxl.Workbook;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class excel&#123; //jxl 建立 excel public static void main(String[] args) &#123; String[] title = &#123;"id","name","sex"&#125;; //建立文件 File file = new File("C:/jxl_test.xls"); try &#123; file.createNewFile(); //建立 工作簿 WritableWorkbook workbook = Workbook.createWorkbook(file); //建立 Sheet WritableSheet sheet = workbook.createSheet("sheet1", 0); jxl.write.Label label=null; for (int i = 0; i &lt; title.length; i++) &#123; //第一行 設定列名 label = new jxl.write.Label(i, 0, title[i]); sheet.addCell(label); &#125; //增加資料 for (int i = 1; i &lt; 10; i++) &#123; label = new jxl.write.Label(0, i, "a"+1); sheet.addCell(label); label = new jxl.write.Label(1, i, "user"+1); sheet.addCell(label); label = new jxl.write.Label(2, i, "男"+1); sheet.addCell(label); &#125; //寫入 workbook.write(); //關閉 workbook.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果圖 ``` JXL.jar 下載點分享 JXL.jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-txt資料讀取存入SQL]]></title>
      <url>%2F2017%2F03%2F24%2Fjava-txt%E8%B3%87%E6%96%99%E8%AE%80%E5%8F%96%E5%AD%98%E5%85%A5SQL%2F</url>
      <content type="text"><![CDATA[java-txt資料讀取存入SQL前言 最近實在太忙了.沒什麼時間更新blog.本來打算寫專案過程可以抓時間學習python主管最近突然跟我說10天要把舊ERP的一個員工教育訓練的程式移植出來.由於舊ERP太爛了沒有用SQL..資料是儲存在txt..!!!就只好寫個程式來匯入 由於時間太趕了..就不太注重細節趕快把這寫出來如果是csv檔案的話稍微修改就可以用了! txt資料 “345”|”456”|”xxxx”|4|12/05/11|12/05/11|0|””|0|””|”name”|12/06/01先寫程式把資料的 “ | 這兩個符號先更改改完如下 #345#@#456#@#xxxx#@4@12/05/11@12/05/11@0@##@0@##@#name#@12/06/01 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import utils.sqlconnection;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Array;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class SQL extends sqlconnection&#123; public static void main(String[] args) &#123; try &#123; java.sql.Connection conn; try &#123; conn = DriverManager.getConnection(CONNURL, SQL_NAME,SQL_PASSWORD); PreparedStatement pstmt = conn.prepareStatement(SQL_INSERT); FileReader fr = new FileReader(FILE_PATH); BufferedReader brdFile = new BufferedReader(fr); String strLine = null; while ((strLine = brdFile.readLine()) != null) &#123; strLine = strLine.replace("#", "");//先將資料夾裡面的#改成"" String[] array = strLine.split("@");// 因為是用"@"分開所以用split切開存入字串陣列 System.out.println(strLine); for (int i = 0; i &lt; array.length; i++) &#123;// System.out.println(array[i]); 可以用來檢視分割的檔案是否正確 pstmt.setString(i+1,array[i]); &#125; pstmt.execute(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL語法紀錄]]></title>
      <url>%2F2017%2F03%2F05%2FSQL%E8%AA%9E%E6%B3%95%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[SQL語法紀錄前言一直以來只記得 select insert drop…每次要用都忘記..還是來記錄一下! 基礎語法 操作功能 SQL 語法 說明 建立資料庫 create database 資料庫名稱; 列出所有資料庫 show databases; 刪除資料庫 drop database 資料庫名稱; 使用資料庫 use 資料庫名稱; 建立資料表 create table 資料表名稱(&lt;br&gt;sn integer auto_increment primary key,&lt;br&gt;name char(20),&lt;br&gt;mail char(50),&lt;br&gt;home char(50),&lt;br&gt;messages char(50)); 常用資料庫資料型態 1. INT (整數) 2. CHAR (1~255字元字串) 3. VARCHAR (不超過255字元不定長度字串) 4. TEXT (不定長度字串最多65535字元) 列出資料表欄位資訊 describe 資料表名稱; 修改資料表欄位 alter table 資料表名稱&lt;br&gt;change column 原來欄位名稱&lt;br&gt;新欄位名稱資料型態; 新增資料表欄位 alter table 資料表名稱 add &lt;br&gt;column 欄位名稱 資料型態; 刪除資料表欄位 alter table 資料表名稱 drop column 欄位名稱; 刪除資料表 drop table 資料表名稱; 清空資料表 truncate table 資料表名稱; 只清除資料並保留結構、欄位、索引 … 插入欄位資料 insert into 資料表名稱(欄位1,欄位2,欄位3,欄位4, ...... 欄位N)&lt;br&gt;values(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;,&#39;值4&#39;, ...... &#39;值N&#39;); 更新修改欄位資料 update 資料表名稱 set 欄位1=&#39;值1&#39;,欄位2=&#39;值2&#39;,欄位3=&#39;值3&#39;,... &lt;br&gt;欄位N=&#39;值N&#39;where 條件式 (例如 sn=&#39;5&#39; 或 name=&#39;塔司尼&#39; ); 查詢單一欄位資料 select 欄位名 from 資料表名稱; 查詢多個欄位資料 select 欄位名, 欄位名, 欄位名 from 資料表名稱; 查詢欄位資料的唯一值 select distinct 欄位名 from 資料表名稱; 重複值只列一次 查詢所有欄位資料 select * from 資料表名稱; 條件式查詢 select * from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39;); （=, &lt;, &gt;, !=） 條件式查詢 and select * from 資料表名稱 where 條件式1 and 條件式2; 條件式查詢 or select * from 資料表名稱 where 條件式1 or 條件式2; 查詢某一範圍 between select * from 資料表名稱 where 欄位名 between 值1 and 值2; 值為數字 查詢空值欄位的資料 select * from 資料表名稱 where 欄位名 is null not null; 查詢特定筆數資料 select * from 資料表名稱 limit 8, 10; 第9筆開始選取10筆 查詢結果遞增排序 select * from 資料表名稱 order by 欄位名; 查詢結果遞減排序 select * from 資料表名稱 order by 欄位名 desc ; 查詢比對字串列出單一欄位 select 欄位名 from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 查詢比對字串列出所有欄位 select * from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 刪除條件值資料 delete from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39; 或 id=&#39;91001&#39; ); 刪除條件值資料 delete from 資料表名稱 where 條件式1 and 條件式2; 刪除條件值資料 delete from 資料表名稱 where 條件式1 or 條件式2; 比對刪除條件值資料 delete from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 一筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;; 兩筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;and xxxx=&#39;xxxx&#39;; 一筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39;; 兩筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39; and xxxx=&#39;xxxx&#39;; 進階語法 操作功能 SQL 語法 說明 查看正在執行的行程 show processlist; 查看 Master 狀態 show master status; 查看 Slave 狀態 show slave status\G; 查看 binlog 狀態 show binary logs; 清除過時的 binlog purge binary logs to &#39;mysql-bin.000006&#39;; 將刪除 mysql-bin.000001 ~ 5 的 binlog 參考資料 SQL常用參考資料1 SQL常用參考資料2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[詳細解讀DialogFragment]]></title>
      <url>%2F2017%2F01%2F20%2F%E8%A9%B3%E7%B4%B0%E8%A7%A3%E8%AE%80DialogFragment%2F</url>
      <content type="text"><![CDATA[DialogFragment 版權聲明：轉載請保留原文連結及作者http://www.cnblogs.com/tianzhijiexian/p/4161811.html 相信看這篇文章的人都應該知道android中的Dialog了吧，如果對於Dialog還不是很了解可以看我之前的一篇詳解文章：Dialog詳解：http://www.cnblogs.com/tianzhijiexian/p/3867731.html隨著Fragment這個類的引入，Google官方推薦大家使用DialogFragment來代替傳統的Dialog，那麼是不是說我們之前學習的Dialog知識都沒有用處了呢？非也，新的fragment是來方便大家更好的管理和重用Dialog，之前的知識其實都是可以拿來就用的，僅僅需要少許的改變。 Dialog和DialogFragment的區別和優劣 新來的DialogFragment讓dialog也變成了碎片，相比之前來說應該做了很多優化和處理，對於程序員來看對話框現在更加具體了，就是一個activity上的一個fragment，我們也可以用fragment的知識來管理對話框了。我們看看之前是怎麼運用對話框對象的 1234AlertDialog dialog = new AlertDialog.Builder( this ) .setTitle( "Dialog" ) .setMessage( "thisis a dialog" ) .show(); 如果這個時候屏幕方向發生變化，就會導致Activity重建，然後之前顯示的對話框就不見了。查看log可以發現這個錯誤： 04-1917:30:06.999: E/WindowManager(14495): Activitycom.example.androidtest.MainActivity has leaked windowcom.android.internal.policy.impl.PhoneWindow$DecorView{42ca3c18 V.E…..R……. 0,0-1026,414} that was originally added here 當然我們也可以無視這個錯誤，因為程序不會因此崩潰（看來android本身就已經預料到這種情況了）。 如果我們想要在旋轉屏幕的時候也能保證這個對話框顯示就需要做一定的處理了，在activity要銷毀前設立一個標誌，看這時對話框是否是顯示狀態，如果是那麼activity在下次建立時直接顯示對話框。 在onSaveInstanceState中1234567@Override protected void onSaveInstanceState(Bundle outState) &#123; super .onSaveInstanceState(outState); if (dialog != null &amp;&amp; dialog.isShowing()) &#123; outState.putBoolean( "DIALOG_SHOWN", true ); &#125; &#125; 在onCreat中123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null ) &#123; boolean isShown = savedInstanceState.getBoolean("DIALOG_SHOWN" ); if (isShown) &#123; AlertDialog dialog = new AlertDialog.Builder( this ).setTitle("Dialog" ) .setMessage( "thisis a dialog" ).show(); &#125; &#125; ……&#125; 使用DialogFragment來管理對話框就不會有這種問題了，代碼也少了很多的邏輯處理。當你旋轉屏幕的時候，fragmentManager會自定管理DialogFragment的生命週期，如果當前已經顯示在屏幕上了，那麼旋轉屏幕後夜會自動顯示，下面就是在屏幕旋轉時的log輸出。12345678910111213141516171819202122234-1917:45:41.289: D/==========(16156): MyDialogFragment : onAttach04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreate04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:41.309: D/==========(16156): MyDialogFragment : onStart04-1917:45:50.619: D/==========(16156): MyDialogFragment : onStop04-1917:45:50.619: D/==========(16156): third activity on destroy04-1917:45:50.619:D/==========(16156): MyDialogFragment : onDestroyView04-1917:45:50.619: D/==========(16156): MyDialogFragment : onDetach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onAttach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onCreate04-1917:45:50.659: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:50.659: D/==========(16156): MyDialogFragment : onStart Ok，當然你可以不以為然，你說我的應用就是豎著用的，旋轉屏幕畢竟是小概率事件，誰會開著對話框旋轉來旋轉去啊。那麼相信下面的好處你一定不能否定吧。 我們之前用Dialog的時候，在activity中必須要建立這個對象，而且一般我們都是需要給它放監聽器的，比如下面的代碼： 12345678910111213141516171819202122@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.guid_main); new AlertDialog.Builder(GuideActivity. this ).setTitle("用戶申明" ) .setMessage(getResources().getString(R.string.statement)) .setPositiveButton( "我同意", new positiveListener()) .setNegativeButton( "不同意", new negativeListener()) .setCancelable( false ) .show(); &#125; private class positiveListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; prefs.setIsFirstTime( false ); &#125; &#125; private class negativeListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Util.virtualHome(GuideActivity. this ); &#125; &#125; 你會發現這麼長的代碼很破壞activity中的邏輯性，有木有！！！在activity中我們處理的各種控件的顯示和邏輯，但對於dialog這種不屬於activity並且建立和處理邏輯都自成一體的東西，我們為什麼要在activity中建立呢？而且為了方便重用，我們在實際過程中基本都會建立一個dialog的工具類來做處理，所以為什麼不用DialogFragment來實現呢？如果通過它來實現，我們就能很方便的進行管理對話框。 此外，當旋轉屏幕和按下後退鍵時可以更好的管理其聲明周期，它和Fragment有著基本一致的聲明周期。且DialogFragment也允許開發者把Dialog作為內嵌的組件進行重用，類似Fragment（可以在大屏幕和小屏幕顯示出不同的效果）。有可能我們在大屏幕上就不需要彈出一個對話框了，直接內嵌在activity界面中顯示即可。這點也很贊！ DialogFragment的最簡單用法使用DialogFragment很簡單，甚至比用Fragment還簡單，因為在api中已經實現了fragment切換對象了。 建立一個fragment對象123456789101112131415161718package com.kale.dialogfragmenttest;import android.app.DialogFragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup;public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); // tag which is from acitivity which started this fragment return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 我們建立了一個fragment，讓他繼承了DialogFragment，在onCreatView中通過佈局文件建立了一個view，這和fragment完全一致。 佈局文件如下： 1234567891011121314151617181920212223242526272829303132&lt;? xml version="1.0" encoding="utf-8" ?&gt;&lt; LinearLayout xmlns:android ="http://schemas.android.com/apk/res/android" android:layout_width ="match_parent" android:layout_height ="match_parent" android:orientation ="vertical" android:padding ="16dp" &gt; &lt; TextView android:id ="@+id/textView1" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Large Text" android:textAppearance ="?android:attr/textAppearanceLarge" /&gt; &lt; EditText android:layout_marginTop ="10dp" android:id ="@+id/editText1" android:layout_width ="match_parent" android:layout_height ="wrap_content" android:ems ="10" &gt; &lt; requestFocus /&gt; &lt;/ EditText &gt; &lt; Button android:id ="@+id/button1" android:layout_marginTop ="10dp" android:layout_gravity ="center_horizo​​ntal" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Button" /&gt;&lt;/ LinearLayout &gt; 在activity中啟用這個dialog12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new DialogFragmentTest() .show(getFragmentManager(), "dialog_fragment" ); &#125; 很像Dialog吧，也是支持鍊式編程的。這裡面的參數： ① 一個fragmentManager，在低版本中用getSupport來獲取；② 一個tag（String）通過這個tag可以告訴fragment是誰啟動了它，當然這僅僅是這個tag的一種使用方式啦。在fragment中可以通過getTag()方法來獲取這個tag 這裡多說一句，在一年前我還一直說要兼容要兼容，不兼容的demo是很不負責任的，但是現在來看，低版本的用戶真的很少很少了，而且這些低版本的用戶已經不能是我們的主流用戶了，所以在2014年末，我可以負責任的說，可以不用兼容2.x的系統了。我之前寫過很多兼容的文章，actionbar啊，對話框的兼容啊，但現在都變得無所謂了，其實任何事物的發展都是如此。很多之前很重要的技術，在新的發展中已經慢慢變得無足輕重了，但我們之前為之付出的東西卻不是無價值的。一個原因是為自己之前的工作找到價值，一種是在那段時光中我們慢慢體會到了很多東西，這些東西就是我們的閱歷也是一種談資。 好，閒話少敘，下面是運行效果： 有人會說，上面的那個空白的title好醜，我想去掉。當然可以，這就是fragment的好處，用這個方法： getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); 12345678910public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 現在它變成了這個樣子： 所以你可以看到，任何改變都是要付出代價的，如果你還是像之前一樣用match_parent來製定控件的寬度，那麼就是這種結果。可以說那個title欄就是一個房梁，支撐著對話框的寬度，沒了它就只能自適應了。解決辦法就是自定義控件的寬度，寫個幾百dp啥的，沒任何技術難度。 注意： 如果你的DialogFragment是Activity的內部類，必須將DialogFragment定義為靜態的。否則會報錯！！！ 123456789public static class DialogFragmentTest extends DialogFragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // TODO自動生成的方法存根 return inflater.inflate(R.layout.dialog, null ); &#125; &#125; DialogFragment啟動、終止過程分析之前說了，我們沒有像fragment那樣建立一個fragment加載對象進行fragment的加載，也沒有commit，但卻能使用dialogFragment對象，這是為什麼呢？ 我們先來回顧下fragment是怎麼使用的。 ① 建立FragmentManager對象，用來管理fragment ② 建立fragmentTransaction對象，用來添加和fragment ③ 提交fragment切換（commit） 123456FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction ft = fragmentManager.beginTransaction(); ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE); ft.add(R.id.container_fragment, new MyFragment()) .commit(); 替換fragment的方法 1234getSupportFragmentManager().beginTransaction(). replace(R.id.container_fragment02, fragment) .addToBackStack( null ) .commit(); 現在，我們通過源碼來分析下DialogFragment的啟動方式 我們在使用它的時候沒有去用fragmentTransaction對象，也沒有執行add，也沒有執行commit，僅僅提供了一個fragmentManager，那麼它是怎麼被添加的呢？我們知道這個對話框是用show方法顯示的，那麼就來看看這個方法吧。 DialogFragment源碼：1.show()1234567public void show(FragmentManager manager, String tag)&#123; mDismissed = false ; mShownByMe = true ; FragmentTransaction ft = manager.beginTransaction(); // creat a fragmentTransaction ft.add( this , tag); // add fragment with tag ft.commit(); &#125; 真相大白，api自動給你實現了一個fragment切換的對象，而且在show的時候就已經add了fragment，所以沒有任何問題~ 在add方法中沒有提供容器的id，所以表示是加載到當前activity中的，在添加後也的確調用了commit方法3 show()的另一種形式12345678public int show(FragmentTransaction transaction, String tag) &#123; mDismissed = false ; mShownByMe = true ; transaction.add( this , tag); mViewDestroyed = false ; mBackStackId = transaction.commit(); return mBackStackId; &#125; 上面的show方法傳入的是一個fragmentTransaction對象，這個也很容易理解。我們之前傳入fragmentManager對象的目的就是生成這個fragmentTransaction對象，這回我們可以在傳入一個已經配置好的fragmentTransaction對象，大大增加了可定制性。所以api的製訂也是大神們心血的結晶啊。 dimiss()1234567891011121314151617181920212223242526272829303132333435** * Dismiss the fragment and its dialog. If the fragment was added to the * back stack, all back stack state up to and including this entry will * be popped. Otherwise, a new transaction will be committed to remove * the fragment. */ public void dismiss() &#123; dismissInternal( false ); &#125; void dismissInternal( boolean allowStateLoss) &#123; if (mDismissed) &#123; return ; &#125; mDismissed = true ; mShownByMe = false ; if (mDialog != null ) &#123; mDialog.dismiss(); mDialog = null ; &#125; mViewDestroyed = true ; if (mBackStackId &gt;= 0 ) &#123; getFragmentManager().popBackStack(mBackStackId, FragmentManager.POP_BACK_STACK_INCLUSIVE); mBackStackId = -1 ; &#125; else &#123; FragmentTransaction ft = getFragmentManager().beginTransaction(); ft.remove( this ); if (allowStateLoss) &#123; ft.commitAllowingStateLoss(); &#125; else &#123; ft.commit(); &#125; &#125; &#125; 我們知道瞭如果一個DialogFragment關閉的時候會檢查堆棧裡面有沒有其他的對象，如果有就pop出來，如果沒有就直接remove和commit。也就是說：如果back stack堆棧有該Dialog，將其pop出來，否則ft.remove(this); ft.commit();。估計pop的操作也包含ft.remove()和ft.commit()。調用dismiss()會觸發onDismiss()回調函數。 跟踪狀態，如下： 通過onCreateView()來建立對話框佈局 上面的例子中我們已經在onCreateView()建立的對話框佈局，這時fragment中建立佈局的傳統寫法， 很適合用於自定義的對話框，我們可以修改任何的東西，包括對話框的style。 上面的例子中我們已經乾掉了對話框上面title的區域，而我們也沒發現可以設置標題的方法， 感覺上面那個標題欄就是個標題黨，毫無意義（之後會說到這塊區域的用處） 。 我們在onCreat中可以設置對話框的風格和各種屬性，但是千萬別設置關於view的東西，因為這時候對話框還沒建立呢，有關於view的東西在onCreatView中去設置吧，這裡我簡單設置了一個button的點擊事件——關閉對話框 123456789101112131415161718192021222324252627282930public class MyDialogFragment extends DialogFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); // 如果setCancelable()中參數為true，若點擊dialog覆蓋不到的activity的空白或者按返回鍵， // 則進行cancel，狀態檢測依次onCancel()和onDismiss()。如參數為false，則按空白處或返回鍵無反應。缺省為true setCancelable( true ); // 可以設置dialog的顯示風格 // setStyle(style,theme); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View rootView = inflater.inflate(R.layout.dialog, null ); Button btn = (Button)rootView.findViewById(R.id.button); btn.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO自動生成的方法存根 dismiss(); &#125; &#125;); return rootView; &#125;&#125; 補充：實現信息保存在activity橫豎屏切換的時候，dialog現在可以自動重建了，如果你在editText中輸入了信息，在重建的時候會不會保留之前的呢？在4.2和4.4中對話框人性化的自定保存了之前輸入的內容，我們無須手動處理。但如果你測試的手機被奇葩的定制了，那就乖乖的保存數據吧。 123456789101112131415161718192021222324public class MyDialogFragment extends DialogFragment &#123; EditText editText; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.dialog, null ); editText = (EditText) rootView.findViewById(R.id.editText); if (savedInstanceState != null ) &#123; CharSequence text = savedInstanceState.getCharSequence( "input data" ); editText.setText(text == null ? "" : text); &#125; return rootView; &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; outState.putCharSequence( "input data" , editText.getText()); super .onSaveInstanceState(outState); &#125;&#125; 通過onCreateDialog()來快捷的建立對話框我們上面建立的對話框都是用自定義佈局的，難道我們之前學過的dialog知識都沒用了麼？我們如果沒自定義對話框的需求，怎麼辦？就沒有一種快一點的方式來建立對話框麼？快用onCreatDialog吧！！！這個回調方法是DialogFragment獨有的，通過它返回的是一個Dialog對象，這個對象就會被顯示到屏幕上。千萬別同時使用onCreatView和onCreatDialog方法，他們僅僅是為了完成同樣一個目的的兩條路而已。 PS：從生命週期的順序而言，先執行onCreateDialog()，後執行onCreateView() 我在onCreatDialog建立一個警告對話框的builder，通過這個builder的create()方法來生成一個AlertDialog對象，因為AlertDialog是Dialog的子類，所以可以直接返回給Dialog。這裡可以用其他不同對話框的builder，代碼類似，只不過就是通過builder的creat()方法返回的是不同的對象而已。builder模式也是蠻巧妙的~ 1234567891011121314151617181920public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener&#123; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ) .setNegativeButton( "不同意", this ) .setCancelable( false ); //.show(); // show cann't be use here return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 &#125;&#125; 顯示效果： 看到了麼，這裡的標題欄終於有用了，原來那個標題欄是為了給我們在這裡用的啊~ 注意： ① 因為這裡創建的是一個dialog，所以用的onclickListener自然是對話框中的listener了。 ② 千萬別在構建對話框對象的時候順手寫了show()方法，我們現在是在fragment中初始化一個對話框，真正讓他顯示的時候是在activity中用這個dialogFragment對象顯示的。如果這裡寫了show方法不會報錯，但是會出現兩個對話框！ 那麼，我們能不能在這裡自定義對話框呢？當然可以啦，本身Dialog.builder就提供了自定義view的方法，和之前用Dialog一樣自定義下viwe就搞定了。 123456789101112131415161718192021@Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.fragment_login_dialog, null ); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout builder.setView(view) // set your own view // Add action buttons .setPositiveButton("Sign in" , new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int id) &#123; &#125; &#125;).setNegativeButton( "Cancel", null ); return builder.create(); &#125; 這裡貼下我在另一篇文章的自定義對話框view的代碼片段： 詳細看這裡：http://www.cnblogs.com/tianzhijiexian/p/3867731.html 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定義視圖對話框 * * @param title */ public void viewDialog(String title) &#123; // LayoutInflater是用來找layout文件夾下的xml佈局文件，並且實例化 LayoutInflater factory = LayoutInflater.from(mContext); // 把activity_login中的控件定義在View中 View view = factory.inflate(R.layout.dialog_layout, null ); // 將LoginActivity中的控件顯示在對話框中 // 獲取用戶輸入的“用戶名”，“密碼” // 注意：view.findViewById很重要，因為上面factory.inflate(R.layout.activity_login, // null)將頁面佈局賦值給了view了 TextView titleTv = (TextView) view .findViewById(R.id.dialog_textView_id); titleTv.setText(title); Button btn = (Button) view.findViewById(R.id.dialog_logout_button_id); btn.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; showToast( "按下自定義視圖的按鈕了~" ); &#125; &#125;); builder // 設定顯示的View .setView(view); // 設置dialog是否為模態，false表示模態，true表示非模態 // ab.setCancelable(false); // 對話框的創建、顯示,這裡顯示的位置是在屏幕的最下面，但是很不推薦這個種做法，因為距底部有一段空隙 AlertDialog dialog = builder.create(); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); // 此處可以設置dialog顯示的位置 window.setWindowAnimations(R.style.myAnimationstyle); // 添加動畫 dialog.show(); &#125; DialogFragment與Activity之前進行通信思路很簡單，就是定義一個傳輸數據的接口，強制activity實現這個接口，在fragment需要傳遞數據的時候去調用這個接口的方法，activity就能在這個方法中得到相應的數據了。這點在之前的fragment傳遞數據中已經介紹過了， 可以參考這篇文章：http://www.cnblogs.com/tianzhijiexian/p/3888330.html 在真正項目中，fragment的編寫並不需要了解activity的各類方法，好的編程風格是將fragment所涉及的方法以接口的方式封裝起來，我在此寫一個例子來說明一下。 寫一個接口——DataCallback123456package com.kale.dialogfragmenttest;public interface DataCallback &#123; public void getData(String data);&#125; activity實現這個接口123456789101112131415161718public class MainActivity extends Activity implements DataCallback&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new MyDialogFragment() .show(getFragmentManager(), "dialog_fragment" ); &#125; @Override public void getData(String data) &#123; // TODO自動生成的方法存根 System.out.println("data = "+ data); &#125;&#125; 在DialogFragment中使用這個接口在DialogFragment中使用這個接口，並且用instanceof來看啟動它的activity是否實現了這個接口，如果沒實現就拋出異常。這樣我們就能保證在大型項目中不會出現忘記實現這個接口的問題了。 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Activity; import android.app.AlertDialog; import android.app.AlertDialog.Builder; import android.app.Dialog; import android.app.DialogFragment; import android.content.DialogInterface; import android.os.Bundle ;public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener &#123; @Override public void onAttach(Activity activity) &#123; // onAttach()是合適的早期階段進行檢查MyActivity是否真的實現了接口。 // 採用接口的方式，dialog無需詳細了解MyActivity，只需了解其所需的接口函數，這是真正項目中應採用的方式。 if (!(activity instanceof DataCallback)) &#123; throw new IllegalStateException("fragment所在的Activity必須實現Callbacks接口" ); &#125; super .onAttach(activity); &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ).setNegativeButton("不同意", this ) .setCancelable( false ); // show(); return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 DataCallback callback = (DataCallback) getActivity(); callback.getData( "test" ); &#125;&#125; 此外fragment也可以通過fragment管理器，通過tag，獲取其他fragment實例，從而進行fragment之間的通信。當然從編程思想的角度看，fragment之間的過多進行交叉調用，不利於程序的管控。 用DialogFragment實現再次彈窗有時候我們可能有這樣的需求，點擊對話框中的一個按鈕後又彈出一個對話框，這個該怎麼做呢？首先在點擊事件中將這個對話框在屏幕上移除，然後把這個fragment壓棧，最後建立一個新的dialogFragment對象，show出來。我們雖然讓這個fragment在屏幕上消失，但還是可以通過fragment管理器到回退棧中找到它。 二次彈窗的代碼：123456789101112131415161718FragmentTransaction ft = getFragmentManager().beginTransaction(); /* * 如果不執行remove()，對話框即不會進入onDismiss()狀態。會被顯示在新的對話框下方，是可見的。 * 主要考慮美觀的問題，如果下面的對話框大於上面的對話框就很難看了。對於Dialog，container為0或者null。 */ ft.remove( this ); /* * 將當前的PromptDialogFragment加入到回退堆棧，當用戶按返回鍵，或者通過按幫助框的Close按鈕dismiss幫助框是， * 重新顯示提示框。對於back stack的處理，系統具有一定的智能。例如：執行兩次addToStackStack()，實際不會重複壓棧。 * 有例如：註釋掉remove()語句，即提示框不消失，而是在幫助框的下面。 * 但是在實驗中發現是否有addToBackStack()都不會結果有影響，系統能夠分析到對象存在，不需要壓棧。沒有去查源代碼， * 猜測通過mBackStackId比對來進行智能處理。 */ ft.addToBackStack( null ); new OhterDialogFragment() .show(getFragmentManager(), "dialog_fragment"); 利用Fragment的特性，為不同屏幕做適配如果我們想在大屏幕上顯示對話框，而小屏幕中直接把對話框的內容放在activity中顯示呢？ 其實也很簡單，本身這個dialogFragment就是一個fragment，所以完全有fragment的特性，你可以用fragmentTranscation將其放到任何佈局中，你也可以用show()方法把它當作dialog顯示出來。接下來就剩下一個問題了，判斷屏幕大小。 在默認的values下新建一個bools.xml 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; false &lt;/ bool &gt; &lt;/ resources &gt; 然後，在res下新建一個values-large，在values-large下再新建一個bools.xml，通過加載不同的value就能知道是大屏還是小屏幕啦 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; true &lt;/ bool &gt; &lt;/ resources &gt; 在代碼中進行判斷 123456789101112131415161718192021public void showDialogInDifferentScreen(View view) &#123; FragmentManager fragmentManager = getFragmentManager(); EditNameDialogFragment newFragment = new EditNameDialogFragment(); boolean mIsLargeLayout = getResources().getBoolean(R.bool.large_layout) ; Log.e( "TAG", mIsLargeLayout+"" ); if (mIsLargeLayout ) &#123; // The device is using a large layout, so show the fragment as a // dialog newFragment.show(fragmentManager, "dialog" ); &#125; else &#123; // The device is smaller, so show the fragment fullscreen FragmentTransaction transaction = fragmentManager.beginTransaction(); // For a little polish, specify a transition animation transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN); // To make it fullscreen , use the 'content' root view as the // container for the fragment, which is always the root view for the activity transaction.replace(R.id.id_ly, newFragment).commit(); &#125; &#125; 參考http://blog.csdn.net/huangyabin001/article/details/30053835 http://blog.csdn.net/lmj623565791/article/details/37815413 http://www.cnblogs.com/tianzhijiexian/p/4161811.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升倉管備料效率-小程式]]></title>
      <url>%2F2017%2F01%2F19%2Favexir%E5%82%99%E6%96%99%2F</url>
      <content type="text"><![CDATA[計算bom表 小程式前言 版權聲明：轉載請保留原文連結及作者由於公司產品種類太多,User RMA回來數量都一樣兩樣很散一個User要去ERP開一張單,但ERP沒辦法把多張單合併包材集中在一張單,導致倉管必須一張單一張單備料由於這樣實在沒效率,所以寫個小程式把User購買的外部料號KEY在程式裡自動會算出需要的包材數量 效果 把外部料號,內部料號打進去會自動算出,倉管需要備東西把客戶名稱日期打上,可以記錄倉管幾月幾號幫RMA備料倉管可以自行反查紀錄,也會紀錄備料人員是誰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Textinputlayout使用及自訂義顏色]]></title>
      <url>%2F2017%2F01%2F16%2FTextinputlayout%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%87%AA%E8%A8%82%E7%BE%A9%E9%A1%8F%E8%89%B2%2F</url>
      <content type="text"><![CDATA[版權聲明：轉載請保留原文連結及作者http://blog.csdn.net/android_freshman/article/details/51136657 Textinputlayout gradle 配置12compile ‘com.Android.support:design:22.2.0’compile ‘com.android.support:appcompat-v7:22.2.0’ xml1234private android.widget.LinearLayout.LayoutParams setEditText(EditText editText, LayoutParams lp) &#123; if(this.mEditText != null) &#123; throw new IllegalArgumentException("We already have an EditText, can only have one"); &#125; else &#123; 注意點：部分源代碼中的內容，TextInputLayout 繼承LinearLayout 且裡面只能有一個editEditText，和scrollView 很像。下面是佈局文件： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.design.widget.TextInputLayout android:id="@+id/titleTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:layout_marginLeft="40dp" android:layout_marginRight="15dp" app:errorTextAppearance="@style/TextInput_Error_style"&gt; &lt;EditText android:id="@+id/title" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/white" android:singleLine="true" android:hint="Title"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/descriptionsTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="40dp" android:layout_marginRight="15dp"&gt; &lt;EditText android:id="@+id/descriptions" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp" android:textColor="@color/white" android:hint="Descriptions"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; java 注意：不能重寫TextInputLayout的OnFocusChangeListener的監聽事件，因為在源代碼中定義了動畫效果和editText注入，重寫了會導致動畫失效。設置浮動標籤動畫效果titleTextInput.setHint(“Title”); 123456if(titleEditText.getText().toString().length()&lt;6)&#123; titleTextInput.setErrorEnabled(true); titleTextInput.setError("title length must &gt;= 6");&#125;else &#123; titleTextInput.setErrorEnabled(false);&#125; 這一部分是動態錯誤提示的相關代碼 完成上面的，基本就可以出現TextInputLayout 的動畫效果了，但是默認的顏色不是很好看，所以我們需要自定義相關的顏色，比如hint 字的顏色，下劃線的顏色，錯誤字體的顏色大小等，下面就是自定義顏色的部分： google把Design Support Library寫的很好。每一個控件的顏色都是直接通過主題顏色繪製的，在style.xml 中指定。打開它添加colorAccent 到主題以改變表單的顏色。在style.xml 中修改相關的屬性 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/primary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt; &lt;!--&lt;item name="colorAccent"&gt;#3498db&lt;/item&gt;--&gt; &lt;item name="android:textColorHint"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlNormal"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlActivated"&gt;@color/white&lt;/item&gt; &lt;item name="colorControlHighlight"&gt;@color/white&lt;/item&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; colorAccent 是什麼意思，哪裡的顏色 這張圖片基本說明了colorAccent代表的顏色，而在google的官網上：https://www.google.com/design/spec/style/color.html#color-color-schemes 也有相關的說明 其他相關顏色的說明 android:textColorHint代表hint的顏色colorControlNormal代表下劃線沒有獲取焦點的顏色colorControlActivated，colorControlHighlight代表了獲取焦點或者點擊的時候下劃線的顏色 錯誤提示的顏色說明：默認的錯誤提示的顏色是紅色：在這種背景色下面，紅色不是很好看，所以需要自定義顏色 在設置佈局的時候errorTextAppearance這個屬性，自定義style 寫顏色和大小就可以了，至於另一個屬性hintTextAppearance 這個屬性修改顏色，好像沒有什麼效果，不起作用。 修改之後的效果，如下圖：有的機器上面可能沒有效果，下面提供一種解決方案： 123456789101112public static void setErrorTextColor(TextInputLayout textInputLayout, int color) &#123; try &#123; Field fErrorView = TextInputLayout.class.getDeclaredField("mErrorView"); fErrorView.setAccessible(true); TextView mErrorView = (TextView) fErrorView.get(textInputLayout); Field fCurTextColor = TextView.class.getDeclaredField("mCurTextColor"); fCurTextColor.setAccessible(true); fCurTextColor.set(mErrorView, color); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 這個是material design 的說明文檔：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText 的拍擋 - TextInputLayout]]></title>
      <url>%2F2017%2F01%2F14%2FTextInputLayout%2F</url>
      <content type="text"><![CDATA[toggleButtong 版權聲明：轉載請保留原文連結及作者http://blog.30sparks.com/material-design-6-textinputlayout/ Android Design Support Library 提供一個TextInputLayout 元件，可用來包著 EditText，令 EditText 得到 focus 時，自動將 hints 變成標題： 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" &gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Your name" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 效果 一個 TextInputLayout 只能容納一個 EditText，所以每個 EditText都需要自訂各自的 TextInputLayout。 關於 HintTextInputLayout 可直接使用 EditText 上的 hint，用來當成 header 。不過，你也可直接設定 hint 到 TextInputLayout 上，它們的效果也是相同的，值得留意的是，你可同時設定 hint 到 TextInputLayout 和 EditText 上。這樣的話，它們一開始會重叠，而當拿到 focus 時，在 TextInputLayout 上的 hint 會被拿來當 header ，而在 EditText 上的會跟以往一樣，有文字輸入後 hint 會消失。不過我想，在正常情況下應該不會這樣做吧？ 字數統計可使用 app:counterEnabled=&quot;true&quot; 和 app:counterMaxLength 可設定顯示輸入文字的長度。 錯誤訊息 TextInputLayout 還有另一好處，是可以顯示錯誤訊息。透過 textInputLayout.setError(&quot;Erorr in name input&quot;)便在底部可顯示錯誤訊息。 例如為我們之前加的 EditText 加進驗証的的話，可以這樣做 123456789101112131415 final TextInputLayout nameLayout = (TextInputLayout)findViewById(R.id.til_et_name);final EditText nameEditText = (EditText)findViewById(R.id.et_name);final Button button = (Button) findViewById(R.id.btn_submit);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(nameEditText.length() == 0)&#123; nameLayout.setError("Error in name input"); &#125; else&#123; nameLayout.setError(null); &#125; &#125;&#125;); 這樣當按 button 時，若 nameEditText 沒有文字的話，便會顯示 “Error in name input”。 不過有留意到顯示錯誤訊息時，整個 messageEditText 會被推下，因為當初 TextInputLayout 沒有預留空間去顯示錯誤訊息！想避免此情況，可以先設定1nameLayout.setErrorEnabled(true); 或者在 layout xml 上加入app:errorEnabled=&quot;true&quot; 123456&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" app:errorEnabled="true" &gt; 這樣，TextInputLayout 便會預留空間去顯示錯誤訊息了。留意的是，你可用 nameLayout. setErrorEnabled(false) 的話，去消除錯誤訊息，但整個layout 會被拉上去 (因錯誤訊息的位置也會被消除)。若不想 layout 移動的話，便應用nameLayout.setError(null) 去消除。 Style顏色想簡單更改底線顏色的話，可到 style.xml 修改 colorAccent 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- ...other style settings --&gt; &lt;item name="colorAccent"&gt;#0000FF&lt;/item&gt;&lt;/style&gt; header若只想改變 header 顏色 ，可使用 app:hintTextAppearance=&quot;style&quot;。先到 style.xml 中加入 TextInputHint 1234&lt;style name="TextInputHint" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#AA2288&lt;/item&gt;&lt;/style&gt; 然後加到 TextInputLayout 加入 app:hintTextAppearance=&quot;@style/TextInputHint &quot; 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:hintTextAppearance ="@style/TextInputHint "&gt; 佷簡單便可修改 header 的風格了。 錯誤訊息要更改錯誤訊息的顏色的話，跟改 header顏色的方法差不多，這次使用的是app:errorTextAppearance。 style.xml: 1234&lt;style name="TextInputError" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#FF00FF&lt;/item&gt;&lt;/style&gt; layout: 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:errorTextAppearance="@style/TextInputError"&gt; 這樣便可以自訂錯誤訊息的風格了。 結語要令文字輸入的 UI 更具動感，TextInputLayout 是一個很方便簡單的工具。快加到你的 UI 中吧。 相關連結 Material Design Patterns 官方文件 - TextInputLayout Working with the EditText]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-line聊天分割]]></title>
      <url>%2F2017%2F01%2F13%2Fjava-line%2F</url>
      <content type="text"><![CDATA[line 聊天記錄 分割 版權聲明：轉載請保留原文連結及作者以前想看line紀錄但太長了寫了一個以日期來分聊天記錄的小程式但效率不是很好也沒有太多時間回去在優化他了如果剛學java的可以自己寫一個看看 效果 主要思路 把txt讀近來後每一行判斷字串 是否有日期例如2016/01/31（日） 先把日期改成你想要的方式 先儲存一份在讀取新的txt 讀到你更改後的日期格式,把日期存成檔案名稱裡面的內容存到txt裡,讀到下一個日期停止先存一份更改日期的用意是.聊天內容或許會有日期或是/ 會抓錯其他應該很簡單就不再詳細敘述了分割好的內容會自動存在C:\LINE 資料夾內 下載點 下載點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toggleButton]]></title>
      <url>%2F2017%2F01%2F05%2FtoggleButton%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下 效果 程式碼 程式碼分成兩類 圖片繪製 點擊事件 布局XML 直接打上自定義原件類別名就可 12345678&lt;com.togg.toggiebutton.CustomToggleButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tb_backround" android:id="@+id/view"&gt;&lt;/com.togg.toggiebutton.CustomToggleButton&gt; onMeasure12345678910protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //底層圖片 backBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tb_backround); //上層圖片 overBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.slide_backround); //寬高和底層圖片一樣 setMeasuredDimension(backBitmap.getWidth(), backBitmap.getHeight()); &#125; onDraw1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; //2.繪制上層圖片 if (isTounching) &#123;//上層圖片跟随滑動 /** * * 防止上層圖片滑動出下層圖片的范围 */ //算出當前觸碰點為上層圖片的中心點時，上層圖片的左侧座標距離 int left = currentX - overBitmap.getWidth() / 2; System.out.println(left + "left 數值" + currentX + "currentx"); if (left &lt; 0) &#123;//防止左侧出界 left = 0; &#125; else if (left &gt; backBitmap.getWidth() - overBitmap.getWidth()) &#123;//防止右侧出界 left = backBitmap.getWidth() - overBitmap.getWidth(); &#125; canvas.drawBitmap(overBitmap, left, 0, null); &#125; else &#123;//上層圖片直接跳到開或關的位置 if (state) &#123; //開 canvas.drawBitmap(overBitmap, backBitmap.getWidth() - overBitmap.getWidth(), 0, null); listener.rightClick(); &#125; else &#123; //關 canvas.drawBitmap(overBitmap, 0, 0, null); listener.leftClick(); &#125; &#125; &#125; onTouchEvent123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //按下為true isTounching = true; //當前觸碰點的x座標 currentX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: isTounching = true; currentX = (int) event.getX(); break; case MotionEvent.ACTION_UP: //抬起時觸碰狀態為false isTounching = false; currentX = (int) event.getX(); break; &#125; //觸碰點超過底層圖片的一半，則state為true,開的狀態 state = currentX &gt; backBitmap.getWidth() / 2; //重新繪制 invalidate(); return true; &#125; 點擊1234567891011private topbarClickListener listener; public interface topbarClickListener &#123; public void leftClick(); public void rightClick(); &#125; public void setOntopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; MainActivity12345678910111213CustomToggleButton cust = (CustomToggleButton) findViewById(R.id.view); cust.setOntopbarClickListener(new CustomToggleButton.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left click", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,"right click",Toast.LENGTH_SHORT).show(); &#125; &#125;); 結尾 這個樣子可直接在你要使用的類 直接new就可以直接使用了 如果要使用各式各樣的開關 只需更改圖片 就可直接使用了 如果一個程式要使用多種開關 把onMeasure 裡面的底層 上層圖寫成外部輸入圖就可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 end]]></title>
      <url>%2F2016%2F12%2F31%2F2016-end%2F</url>
      <content type="text"><![CDATA[離起點又遠了一些,離終點又進了一點無論今天在困難,明天終究會到來無論今年發生多少事,到了明年還是會變成回憶中的故事這一切終究會拼湊成一個一個完整的人生新的一年,不要忘了完成那些該完成的事情謝謝周遭的許多人幫助了我非常非常多的事情有了你們這一切才會變成可行的事情 2016年度總結 今年接了幾個開發的案子,經歷了一大段很挫折壓力大到爆表的日子也接了幾個私人伺服器的協助開發,這段日子應該算是最快樂的,有錢賺還可以玩遊戲XDD也謝謝幾位高材生協助指導讓我完成這一串事情..整年度大部分時間都在學著嵌入式開發,當要開發的時候C已經忘得差不多了,花了很多的時間在學這一部分,在硬體開發部分由於對於電路不是很懂,有時候並不是代碼有寫錯而是電路的問題,常常在浪費時間在原地打轉.每當回去寫APP的時候都會忘記那時候到底在寫什麼,寫到了哪裡,那時候在想什麼年初給自己的目標,完成了六成,希望明年可以在努力一點今年應該算是最枯燥的一年,但今年的知識吸收量應該是以前的好幾倍,已結果來說還蠻滿意的年底架設了這個部落格,慢慢的會把自己所開發的過程放上來,如果有時間會把一些開源也慢慢的會把evernote上記錄的資料也移過來 2016書單 學失敗：創業熱時代看不見的退場故事 創業投資聖經：Startup募資、天使投資人、投資契約、談判策略全方位教戰法則 免費！揭開零定價的獲利祕密 自己的品牌自己做：企業自媒化，營造忠實顧客群的品牌經營方針 競爭論 創業的藝術 工作大解放：這樣做事反而更成功 從0到1：打開世界運作的未知祕密，在意想不到之處發現價值 全方位把玩Android 400個API：精挑細選365個實例說明 ARM Cortex-M4+Wi-Fi MCU應用指南：CC3200 CCS基礎篇 ARM Cortex-M3與Cortex-M4權威指南 拖延心理學：為什麼我老是愛拖延？是與生俱來的壞習慣，還是身不由己？ 創新者的窘境 30年心血，品牌之父艾克終於說出的品牌王道：微軟、可口可樂、麥當勞、三星、P&amp;G，全球行銷長都在讀的20終極法則 今年淺讀了這些書,雖然還有幾本還沒讀完..!!!!!2016也訂了一年份的空中英語教室月刊希望明年的今天語言部分可以進步很多 20172017 年度計畫 今年預計後半年要花點時間學python 今年也會開始學Machine Learning很大部分會完成2016該完成還沒完成的事情,加上一點突發狀況明年應該就這樣結束了慢慢的習慣把學習紀錄,資料記錄寫到部落格上 2017 書單 引爆社群：移動互聯網時代的新4C法則 稀缺：我們是如何陷入貧窮與忙碌的 TED TALKS 說話的力量：你可以用言語來改變自己，也改變世界 TED唯一官方版演講指南 不懂帶團隊，那就大家一起死！：行為科學教你把豬一般的隊友變菁英 沒經驗，是你最大優勢 賽局理論，解決問題最簡單的方法 文案力：如果沒有文案，這世界會有多無聊？ 釣愚：操縱與欺騙的經濟學 Python 自動化的樂趣｜搞定重複瑣碎 &amp;單調無聊的工作 解事者：複雜的事物我簡單說明白 如果這樣，會怎樣？：胡思亂想的搞怪趣問 正經認真的科學妙答 商業冒險：華爾街的12個經典故事 債的歷史：從文明的初始到全球負債時代 我的思考，我的光：諾貝爾獎得主中村修二創新突破的7個思考原點 如果中途有看到喜歡的書在新增上來 END 想起前陣子跟朋友討論一本俄羅斯的小說裡面有段話挺有趣的真正的窮人,是那種群聚在一起的人,而孑然一身的窮人,不過是沒賺到錢的有錢人罷了 任何值得去的地方 都沒有捷徑努力配得上你的夢想那麼你的夢想也不會辜負你的努力送給自己一句話自律能讓你更優秀 加油！！！！2016再見 2017加油!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout]]></title>
      <url>%2F2016%2F12%2F15%2FMy-New-post%2F</url>
      <content type="text"><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下在安卓5.0有新增了TabLauout但他並不能滿足很多時候想顯示的樣子所以使用V4下的FragmentPagerAdapter來實現.請記得都要import v4 否則會報錯呈現的效果如下 效果 程式碼 程式碼分成四類 FragmentPagerAdapter ArrayList&lt;Fragment&gt;() 初始化三個布局 更改點擊的布局屬性 布局XML 從上面的效果可以看的出來 沒選重的狀況下其他兩個字體大小要一置 選重的要變大 下底線要與字體長度一樣 程式碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:orientation="horizontal"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/id_tab_trend" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_trend" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_trend_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_surrounding" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_sourrounding" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_surrounding_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_appliances" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_appliances" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_appliances_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在一個LinearLayout裡面 再放三個`LinearLayout`` 按照比例分配`android:layout_weight=”1”`` 點擊後在程式碼將點擊的layout_weight 改成你要的比例在把字體放大 Fragment1234567mFragment = new ArrayList&lt;Fragment&gt;(); Fragment mTab01 = new TrendFragment(); Fragment mTab02 = new SurroundingFragment(); Fragment mTab03 = new AppliancesFragment(); mFragment.add(mTab01); mFragment.add(mTab02); mFragment.add(mTab03); FragmentPagerAdapter1234567891011121314151617181920212223242526272829303132333435mAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragment.get(position); &#125; @Override public int getCount() &#123; return mFragment.size(); &#125; &#125;; mViewPager.setAdapter(mAdapter); // Touch Replace the content area mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; 重置 這邊來判斷字的寬度 來依照讀取的寬度來設定線的長度 這邊只貼其中一組 textview ImageView 請在自行補上其他的1234567891011private void resetColor() &#123; mTvTrend.setTextColor(getResources().getColor(R.color.tab_not_selectedl_Color)); mTvTrend.setTextSize(NOT_SELECTED); mTvTrend.setText(one); mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayoutCompat.LayoutParams.WRAP_CONTENT, 1.0f)); mTabtrendImg.setBackgroundResource(R.drawable.tabline); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); 點擊 在點擊的時候先呼叫一次resetColor(); 在設定布局比例 文字大小 123456public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.id_tab_trend: setSelect(0); break; 12345678910111213141516public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 滑動 別忘了上面寫的ViewPage事件 12345public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; 123456789101112131415public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 結尾 程式碼可以在寫一個class來去放 這樣會比較好維護一點 下底線圖片要改成.9會比較好一點]]></content>
    </entry>

    
  
  
</search>
