<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python學習紀錄]]></title>
      <url>%2F2017%2F04%2F01%2Fpython%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[python 前陣子買了幾本python的書連續假期終於有空看了這些書紀錄一下一些用法與說明讓自己方便查詢 ##python 變數 資料類型## Python中資料類型1.整數 Python可以處理任意大小的整數，當然包括負整數，在Python程序中，整數的表示方法和數學上的寫法一模一樣，例如：1，100，-8080，0，等。計算機由於使用二進制，所以，有時候用十六進製表示整數比較方便，十六進制用0x前綴和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 12print(0xff00)print(0xa5b4c3d2) 結果652802780087250 2.浮點數 浮點數也就是小數，之所以稱為浮點數，是因為按照科學記數法表示時，一個浮點數的小數點位置是可變的，比如，1.23x10^9和12.3x10^8是相等的。浮點數可以用數學寫法，如1.23，3.14，-9.01，等等。但是對於很大或很小的浮點數，就必須用科學計數法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以寫成1.2e-5，等等。整數和浮點數在計算機內部存儲的方式是不同的，整數運算永遠是精確的（除法難道也是精確的？是的！），而浮點數運算則可能會有四捨五入的誤差。 3.字串 字串是以&#39;&#39;或&quot;&quot;括起來的任意，比如&#39;abc&#39;，&quot;xyz&quot;等等。請注意，’’或””本身只是一種表示方式，不是字符串的一部分，因此，字串’abc’只有a，b，c這3個字符。 4.布林值 布林值和布爾代數的表示完全一致，一個布林值只有True、False兩種值，True，False，在Python中，可以直接用True、False表示布林值（請注意大小寫），也可以通過布爾運算計算出來。布林值可以用and、or和not運算。and運算是與運算，只有所有都為 True，and運算結果才是 True。or運算是或運算，只要其中有一個為 True，or 運算結果就是 True。not運算是非運算，它是一個單目運算符，把 True 變成 False，False 變成 True。 5.空值 空值是Python裡一個特殊的值，用None表示。 None不能理解為0，因為0是有意義的，而None是一個特殊的空值。此外，Python還提供了列表、字典等多種數據類型，還允許創建自定義數據類型， python printprint print語句也可以跟上多個字串，用逗號“,”隔開，就可以連成一串輸出：1print ('The quick brown fox', 'jumps over', 'the lazy dog' ,'The quick brown fox jumps over the lazy dog') 結果 The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog print會依次打印每個字符串，遇到逗號“,”會輸出一個空格，因此，輸出的字符串是這樣拼起來的： python中定義字串如果字符串既包含&#39;又包含&quot;怎麼辦？這個時候，就需要對字符串的某些特殊字符進行“轉義”，Python字符串用\進行轉義。要表示字符串 Bob said “I’m OK”.由於 ‘ 和 “ 會引起歧義，因此，我們在它前面插入一個\表示這是一個普通字符，不代表字符串的起始，因此，這個字符串又可以表示為 ‘Bob said \”I\’m OK\”.’ 注意：轉義字符 \ 不計入字符串的內容中。 常用的轉義字符還有： \n 表示換行\t 表示一個製表符\ 表示 \ 字串本身 Python中raw字符串與多行字串如果一個字符串包含很多需要轉義的字符，對每一個字符都進行轉義會很麻煩。為了避免這種情況，我們可以在字符串前面加個前綴 r ，表示這是一個 raw 字符串，裡面的字符就不需要轉義了。例如： r’(~~)/ (~~)/‘ 但是r&#39;...&#39;表示法不能表示多行字串，也不能表示包含&#39;和&quot;的字串（為什麼？） 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： ‘’’Line 1Line 2Line 3’’’ 上面這個字符串的表示方法和下面的是完全一樣的： ‘Line 1\nLine 2\nLine 3’ 還可以在多行字符串前面添加 r ，把這個多行字符串也變成一個raw字符串： r’’’Python is created by “Guido”.It is free and easy to learn.Let’s start learn Python in imooc!’’’ Python中Unicode字符串字串還有一個編碼問題。 因為計算機只能處理數字，如果要處理文本，就必須先把文本轉換為數字才能處理。最早的計算機在設計時採用8個比特（bit）作為一個字節（byte），所以，一個字節能表示的最大的整數就是255（二進制11111111=十進制255），0 - 255被用來表示大小寫英文字母、數字和一些符號，這個編碼表被稱為ASCII編碼，比如大寫字母A 的編碼是65，小寫字母z 的編碼是122。 如果要表示中文，顯然一個字節是不夠的，至少需要兩個字節，而且還不能和ASCII編碼衝突，所以，中國製定了GB2312編碼，用來把中文編進去。 類似的，日文和韓文等其他語言也有這個問題。為了統一所有文字的編碼，Unicode應運而生。 Unicode把所有語言都統一到一套編碼裡，這樣就不會再有亂碼問題了。 Unicode通常用兩個字節表示一個字符，原有的英文編碼從單字節變成雙字節，只需要把高字節全部填為0就可以。 因為Python的誕生比Unicode標準發布的時間還要早，所以最早的Python只支持ASCII編碼，普通的字符串&#39;ABC&#39;在Python內部都是ASCII編碼的。 Python在後來添加了對Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： print u’中文’中文 注意: 不加 u ，中文就不能正常顯示。 Unicode字符串除了多了一個 u 之外，與普通字符串沒啥區別，轉義字符和多行表示法仍然有效： 轉義： u’中文\n日文\n韓文’ 多行： u’’’第一行第二行’’’ raw+多行： ur’’’Python的Unicode字符串支持”中文”,“日文”,“韓文”等多種語言’’’ 如果中文字符串在Python環境下遇到 UnicodeDecodeError，這是因為.py文件保存的格式有問題。可以在第一行增加註釋 – coding: utf-8 – 目的是告訴Python解釋器，用UTF-8編碼讀取源代碼。然後用Notepad++ 另存為… 並選擇UTF-8格式保存。 Python中整數和浮點數Python支持對整數和浮點數直接進行四則混合運算，運算規則和數學上的四則運算規則完全一致。 基本的運算： 1 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括號可以提升優先級，這和數學運算完全一致，注意只能使用小括號，但是括號可以嵌套很多層： (1 + 2) 3 # ==&gt; 9(2.2 + 3.3) / (1.5 (9 - 0.3)) # ==&gt; 0.42145593869731807 和數學運算不同的地方是，Python的整數運算結果仍然是整數，浮點數運算結果仍然是浮點數： 1 + 2 # ==&gt; 整數 31.0 + 2.0 # ==&gt; 浮點數 3.0 但是整數和浮點數混合運算的結果就變成浮點數了： 1 + 2.0 # ==&gt; 浮點數 3.0 為什麼要區分整數運算和浮點數運算呢？這是因為整數運算的結果永遠是精確的，而浮點數運算的結果不一定精確，因為計算機內存再大，也無法精確表示出無限循環小數，比如 0.1 換成二進製表示就是無限循環小數。 那整數的除法運算遇到除不盡的時候，結果難道不是浮點數嗎？我們來試一下： 11 / 4 # ==&gt; 2 令很多初學者驚訝的是，Python的整數除法，即使除不盡，結果仍然是整數，餘數直接被扔掉。不過，Python提供了一個求餘的運算 % 可以計算餘數： 11 % 4 # ==&gt; 3 如果我們要計算 11 / 4 的精確結果，按照“整數和浮點數混合運算的結果是浮點數”的法則，把兩個數中的一個變成浮點數再運算就沒問題了： 11.0 / 4 # ==&gt; 2.75 Python中布爾類型我們已經了解了Python支持布爾類型的數據，布爾類型只有True和False兩種值，但是布爾類型有以下幾種運算： and 運算：只有兩個布爾值都為 True 時，計算結果才為 True。 True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False or運算：只要有一個布爾值為 True，計算結果就是 True。 True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False not運算：把True變為False，或者把False變為True： not True # ==&gt; Falsenot False # ==&gt; True 布爾運算在計算機中用來做條件判斷，根據計算結果為True或者False，計算機可以自動執行不同的後續代碼。 在Python中，布爾類型還可以與其他數據類型做 and、or和not運算，請看下面的代碼： a = Trueprint a and ‘a=T’ or ‘a=F’ 計算結果不是布爾類型，而是字符串 ‘a=T’，這是為什麼呢？ 因為Python把0、空字串&#39;&#39;和None看成 False，其他數值和非空字符串都看成 True，所以：&gt;True and ‘a=T’ 計算結果是 ‘a=T’繼續計算 ‘a=T’ or ‘a=F’ 計算結果還是 ‘a=T’要解釋上述結果，又涉及到 and 和 or 運算的一條重要法則：短路計算。 在計算 a and b 時，如果 a 是 False，則根據與運算法則，整個結果必定為 False，因此返回 a；如果 a 是 True，則整個計算結果必定取決與 b，因此返回 b。 在計算 a or b 時，如果 a 是 True，則根據或運算法則，整個計算結果必定為 True，因此返回 a；如果 a 是 False，則整個計算結果必定取決於 b，因此返回 b。 所以Python解釋器在做布爾運算時，只要能提前確定計算結果，它就不會往後算了，直接返回結果。 List和Tuple類型Pytho建立listPython內置的一種數據類型是列表：list。 list是一種有序的集合，可以隨時添加和刪除其中的元素。 比如，列出班裡所有同學的名字，就可以用一個list表示： [‘Michael’, ‘Bob’, ‘Tracy’][‘Michael’, ‘Bob’, ‘Tracy’] list是數學意義上的有序集合，也就是說，list中的元素是按照順序排列的。 構造list非常簡單，按照上面的代碼，直接用[ ]把list的所有元素都括起來，就是一個list對象。通常，我們會把list賦值給一個變量，這樣，就可以通過變量來引用list： classmates = [‘Michael’, ‘Bob’, ‘Tracy’]classmates # 打印classmates變量的內容[‘Michael’, ‘Bob’, ‘Tracy’] 由於Python是動態語言，所以list中包含的元素並不要求都必須是同一種數據類型，我們完全可以在list中包含各種數據： L = [‘Michael’, 100, True] 一個元素也沒有的list，就是空list： empty_list = [] Python按照索引訪問list由於list是一個有序集合，所以，我們可以用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 那我們如何從list中獲取指定第 N 名的同學呢？方法是通過索引來獲取list中的指定元素。 需要特別注意的是，索引從 0 開始，也就是說，第一個元素的索引是0，第二個元素的索引是1，以此類推。因此，要列印第一名同學的名字，用 L[0]: print L[0]Adam 要打印第二名同學的名字，用 L[1]: print L[1]Lisa 要打印第三名同學的名字，用 L[2]: print L[2]Bart 要打印第四名同學的名字，用 L[3]: print L[3]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range 報錯了！ IndexError意思就是索引超出了範圍，因為上面的list只有3個元素，有效的索引是 0，1，2。 所以，使用索引時，千萬注意不要越界。 Python之倒序訪問list我們還是用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 這時，老師說，請分數最低的同學站出來。 要寫代碼完成這個任務，我們可以先數一數這個 list，發現它包含3個元素，因此，最後一個元素的索引是2： print L[2]Bart 有沒有更簡單的方法？ 有！ Bart同學是最後一名，俗稱倒數第一，所以，我們可以用 -1 這個索引來表示最後一個元素： print L[-1]Bart Bart同學表示躺槍。 類似的，倒數第二用 -2 表示，倒數第三用 -3 表示，倒數第四用 -4 表示： print L[-2]Lisaprint L[-3]Adamprint L[-4]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range L[-4] 報錯了，因為倒數第四不存在，一共只有3個元素。 使用倒序索引時，也要注意不要越界。 Python之添加新元素現在，班裡有3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 今天，班裡轉來一名新同學 Paul，如何把新同學添加到現有的 list 中呢？ 第一個辦法是用 list 的 append() 方法，把新同學追加到 list 的末尾： L = [‘Adam’, ‘Lisa’, ‘Bart’]L.append(‘Paul’) print L[‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] append()總是把新的元素添加到 list 的尾部。 如果 Paul 同學表示自己總是考滿分，要求添加到第一的位置，怎麼辦？ 方法是用list的 insert()方法，它接受兩個參數，第一個參數是索引號，第二個參數是待添加的新元素： L = [‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, ‘Paul’) print L[‘Paul’, ‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, &#39;Paul&#39;) 的意思是，’Paul’將被添加到索引為0 的位置上（也就是第一個），而原來索引為0 的Adam同學，以及後面的所有同學，都自動向後移動一位。 Python從list刪除元素Paul同學剛來幾天又要轉走了，那麼我們怎麼把Paul 從現有的list中刪除呢？ 如果Paul同學排在最後一個，我們可以用list的pop()方法刪除： L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] L.pop()‘Paul’ print L[‘Adam’, ‘Lisa’, ‘Bart’] pop()方法總是刪掉list的最後一個元素，並且它還返回這個元素，所以我們執行 L.pop() 後，會打印出 ‘Paul’。 如果Paul同學不是排在最後​​一個怎麼辦？比如Paul同學排在第三： L = [‘Adam’, ‘Lisa’, ‘Paul’, ‘Bart’] 要把Paul踢出list，我們就必須先定位Paul的位置。由於Paul的索引是2，因此，用 pop(2)把Paul刪掉： L.pop(2)‘Paul’print L[‘Adam’, ‘Lisa’, ‘Bart’] Python中替换元素假設現在班裡仍然是3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 現在，Bart同學要轉學走了，碰巧來了一個Paul同學，要更新班級成員名單，我們可以先把Bart刪掉，再把Paul添加進來。另一個辦法是直接用Paul把Bart給替換掉： L[2] = ‘Paul’ print LL = [‘Adam’, ‘Lisa’, ‘Paul’] 對list中的某一個索引賦值，就可以直接用新的元素替換掉原來的元素，list包含的元素個數保持不變。 由於Bart還可以用 -1 做索引，因此，下面的代碼也可以完成同樣的替換工作： L[-1] = ‘Paul’ Python之創建tupletuple是另一種有序的列表，中文翻譯為“ 元組 ”。 tuple 和 list 非常類似，但是，tuple一旦創建完畢，就不能修改了。 同樣是表示班裡同學的名稱，用tuple表示如下： t = (‘Adam’, ‘Lisa’, ‘Bart’) 創建tuple和創建list唯一不同之處是用( )替代了[ ]。 現在，這個t 就不能改變了，tuple沒有 append()方法，也沒有insert()和pop()方法。所以，新同學沒法直接往 tuple 中添加，老同學想退出 tuple 也不行。 獲取 tuple 元素的方式和 list 是一模一樣的，我們可以正常使用 t[0]，t[-1]等索引方式訪問元素，但是不能賦值成別的元素，不信可以試試： t[0] = ‘Paul’Traceback (most recent call last): File ““, line 1, in TypeError: ‘tuple’ object does not support item assignment Python之創建單元素tupletuple和list一樣，可以包含 0 個、1個和任意多個元素。 包含多個元素的 tuple，前面我們已經創建過了。 包含 0 個元素的 tuple，也就是空tuple，直接用 ()表示： t = () print t()創建包含1個元素的 tuple 呢？來試試： t = (1) print t1 好像哪裡不對！ t 不是 tuple ，而是整數1。為什麼呢？ 因為()既可以表示tuple，又可以作為括號表示運算時的優先級，結果 (1) 被Python解釋器計算出結果 1，導致我們得到的不是tuple，而是整數 1。 正是因為用()定義單元素的tuple有歧義，所以 Python 規定，單元素 tuple 要多加一個逗號“,”，這樣就避免了歧義： t = (1,) print t(1,) Python在打印單元素tuple時，也自動添加了一個“,”，為了更明確地告訴你這是一個tuple。多元素 tuple 加不加這個額外的“,”效果是一樣的： t = (1, 2, 3,) print t(1, 2, 3) Python之”可變”的tuple前面我們看到了tuple一旦創建就不能修改。現在，我們來看一個“可變”的tuple： t = (‘a’, ‘b’, [‘A’, ‘B’]) 注意到 t 有 3 個元素：&#39;a&#39;，&#39;b&#39;和一個list：[&#39;A&#39;, &#39;B&#39;]。 list作為一個整體是tuple的第3個元素。 list對象可以通過 t[2] 拿到： L = t[2] 然後，我們把list的兩個元素改一改： L[0] = ‘X’ L[1] = ‘Y’ 再看看tuple的內容： print t(‘a’, ‘b’, [‘X’, ‘Y’]) 不是說tuple一旦定義後就不可變了嗎？怎麼現在又變了？ 別急，我們先看看定義的時候tuple包含的3個元素​​： 當我們把list的元素&#39;A&#39;和&#39;B&#39;修改為&#39;X&#39;和&#39;Y&#39;後，tuple變為： 表面上看，tuple的元素確實變了，但其實變的不是 tuple 的元素，而是list的元素。 tuple一開始指向的list並沒有改成別的list，所以，tuple所謂的“不變”是說，tuple的每個元素，指向永遠不變。即指向’a’，就不能改成指向’b’，指向一個list，就不能改成指向其他對象，但指向的這個list本身是可變的！ 理解了“指向不變”後，要創建一個內容也不變的tuple怎麼做？那就必須保證tuple的每一個元素本身也不能變。 條件判斷和循環Python之if語句計算機之所以能做很多自動化的任務，因為它可以自己做條件判斷。 比如，輸入用戶年齡，根據年齡打印不同的內容，在Python程序中，可以用if語句實現： age = 20if age &gt;= 18: print ‘your age is’, age print ‘adult’print ‘END’ 注意: Python代碼的縮進規則。具有相同縮進的代碼被視為代碼塊，上面的3，4行 print 語句就構成一個代碼塊（但不包括第5行的print）。如果 if 語句判斷為 True，就會執行這個代碼塊。 縮進請嚴格按照Python的習慣寫法：4個空格，不要使用Tab，更不要混合Tab和空格，否則很容易造成因為縮進引起的語法錯誤。 注意: if 語句後接表達式，然後用:表示代碼塊開始。 age = 20 if age &gt;= 18:… print ‘your age is’, age… print ‘adult’…your age is 20adult Python之 if-else當if語句判斷表達式的結果為True時，就會執行 if 包含的代碼塊： if age &gt;= 18: print ‘adult’ 如果我們想判斷年齡在18歲以下時，印出 ‘teenager’，怎麼辦？ 方法是再寫一個 if: if age &lt; 18: print ‘teenager’ 或者用 not 運算： if not age &gt;= 18: print ‘teenager’ 細心的同學可以發現，這兩種條件判斷是“非此即彼”的，要么符合條件1，要么符合條件2，因此，完全可以用一個if ... else ... 語句把它們統一起來： if age &gt;= 18: print ‘adult’else: print ‘teenager’ 利用 if … else … 語句，我們可以根據條件表達式的值為 True或者 False，分別執行if代碼塊或者else 代碼塊。 注意: else 後面有個“:”。 Python之 if-elif-else有的時候，一個 if … else … 還不夠用。比如，根據年齡的劃分： 條件1：18歲或以上：adult條件2：6歲或以上：teenager條件3：6歲以下：kid 我們可以用一個 if age &gt;= 18 判斷是否符合條件1，如果不符合，再通過一個 if 判斷 age &gt;= 6 來判斷是否符合條件2，否則，執行條件3： if age &gt;= 18: print ‘adult’else: if age &gt;= 6: print ‘teenager’ else: print ‘kid’這樣寫出來，我們就得到了一個兩層嵌套的 if … else … 語句。這個邏輯沒有問題，但是，如果繼續增加條件，比如3歲以下是 baby： if age &gt;= 18: print ‘adult’else: if age &gt;= 6: print ‘teenager’ else: if age &gt;= 3: print ‘kid’ else: print ‘baby’這種縮進只會越來越多，代碼也會越來越難看。 要避免嵌套結構的 if … else …，我們可以用 if … 多個elif … else … 的結構，一次寫完所有的規則： if age &gt;= 18: print ‘adult’elif age &gt;= 6: print ‘teenager’elif age &gt;= 3: print ‘kid’else: print ‘baby’elif 意思就是 else if。這樣一來，我們就寫出了結構非常清晰的一系列條件判斷。 特別注意: 這一系列條件判斷會從上到下依次判斷，如果某個判斷為 True，執行完對應的代碼塊，後面的條件判斷就直接忽略，不再執行了。 請思考下面的代碼： age = 8if age &gt;= 6: print ‘teenager’elif age &gt;= 18: print ‘adult’else: print ‘kid’當 age = 8 時，結果正確，但 age = 20 時，為什麼沒有打印出 adult？ 如果要修復，應該如何修復？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將excel-讀到JAVA上]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87excel-%E8%AE%80%E5%88%B0JAVA%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[使用 jxl 把Excel讀取到java 上一篇 把資料寫入到Excel 這篇就順便將讀取到java補上了說明都打在註解上了!!就不在多做說明了 java123456789101112131415161718192021222324252627282930313233343536373839404142package excel;import java.io.File;import java.io.IOException;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;import jxl.read.biff.BiffException;public class ReadExcel&#123; //JXL讀取EXCEL public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //建立 workbook Workbook workbook = Workbook.getWorkbook(new File("C:/jxl_test.xls")); //得到第一個工作表 Sheet sheet = workbook.getSheet(0); //取得資料 for (int i = 0; i &lt; sheet.getRows(); i++) //行 &#123; for (int j = 0; j &lt; sheet.getColumns(); j++)//列 &#123; Cell cell= sheet.getCell(j,i); System.out.print(cell.getContents()+" "); &#125; System.out.println(); //換行 &#125; workbook.close(); //將workbook關閉 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將java資料導入excel]]></title>
      <url>%2F2017%2F03%2F27%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87java%E8%B3%87%E6%96%99%E5%B0%8E%E5%85%A5excel%2F</url>
      <content type="text"><![CDATA[使用java_將資料導入excel 最近在把公司舊的ERP HR系統 移植出來必須要用最快的方式移植出來不然我本來的專案會趕不上進度順便找時間記錄一下最近開發紀錄 excel 幾種實現方式!POI poi 是 apache poi開放源碼函式庫提供java對 Microsoft office 格式檔案讀寫功能通過HSSF可以使用純JAVA代碼來讀取 寫入 修改EXCELHSSF -讀寫Microsoft Excel格式檔案功能(只支援97-2003)XSSF -讀寫Microsoft Excel OOXML格式檔案功能HWPF -讀寫讀寫Microsoft Word格式檔案功能HSLF -讀寫讀寫Microsoft PowerPoint格式檔案功能HDGF -讀寫讀寫Microsoft Visio格式檔案功能-iText 可以通過iText 來建立PDF 只需在classpath加入iText.jar JXL 有興趣的在去查一下 FASTEXCEL 是一個採用純java 開發的excel文件讀寫組件 支持Excel 97-2003fastExcel 只能讀取單元格的字串資料其他屬性 像是顏色 字體就不支持 但也因為這樣FastExcel 需要用到的記憶體很少 JXL java excel 可以讀取Excel文件內容 建立excel文件 更新已存在的excel POI JXK 比較 效率高 功能強大使用上比較複雜 支持公式 圖表 能夠修改單元屬性格 支持字體 數字 日期操作 JXL 效率低 操作簡單 部分支援 能夠修改單元格屬性 但不比POI強大 支援字體 數字 日期 使用JXL程式碼實例 程式都註解上去了!由於時間的關係需要快速的去開發就嘗試幾個方法開發 需要更快速的來去完成工作才是目標所以選擇使用 JXL 有空再把POI程式碼貼上來 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package excel;import java.awt.Label;import java.io.File;import java.io.IOException;import jxl.Workbook;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class excel&#123; //jxl 建立 excel public static void main(String[] args) &#123; String[] title = &#123;"id","name","sex"&#125;; //建立文件 File file = new File("C:/jxl_test.xls"); try &#123; file.createNewFile(); //建立 工作簿 WritableWorkbook workbook = Workbook.createWorkbook(file); //建立 Sheet WritableSheet sheet = workbook.createSheet("sheet1", 0); jxl.write.Label label=null; for (int i = 0; i &lt; title.length; i++) &#123; //第一行 設定列名 label = new jxl.write.Label(i, 0, title[i]); sheet.addCell(label); &#125; //增加資料 for (int i = 1; i &lt; 10; i++) &#123; label = new jxl.write.Label(0, i, "a"+1); sheet.addCell(label); label = new jxl.write.Label(1, i, "user"+1); sheet.addCell(label); label = new jxl.write.Label(2, i, "男"+1); sheet.addCell(label); &#125; //寫入 workbook.write(); //關閉 workbook.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果圖 ``` JXL.jar 下載點分享 JXL.jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-txt資料讀取存入SQL]]></title>
      <url>%2F2017%2F03%2F24%2Fjava-txt%E8%B3%87%E6%96%99%E8%AE%80%E5%8F%96%E5%AD%98%E5%85%A5SQL%2F</url>
      <content type="text"><![CDATA[java-txt資料讀取存入SQL前言 最近實在太忙了.沒什麼時間更新blog.本來打算寫專案過程可以抓時間學習python主管最近突然跟我說10天要把舊ERP的一個員工教育訓練的程式移植出來.由於舊ERP太爛了沒有用SQL..資料是儲存在txt..!!!就只好寫個程式來匯入 由於時間太趕了..就不太注重細節趕快把這寫出來如果是csv檔案的話稍微修改就可以用了! txt資料 “345”|”456”|”xxxx”|4|12/05/11|12/05/11|0|””|0|””|”name”|12/06/01先寫程式把資料的 “ | 這兩個符號先更改改完如下 #345#@#456#@#xxxx#@4@12/05/11@12/05/11@0@##@0@##@#name#@12/06/01 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import utils.sqlconnection;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Array;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class SQL extends sqlconnection&#123; public static void main(String[] args) &#123; try &#123; java.sql.Connection conn; try &#123; conn = DriverManager.getConnection(CONNURL, SQL_NAME,SQL_PASSWORD); PreparedStatement pstmt = conn.prepareStatement(SQL_INSERT); FileReader fr = new FileReader(FILE_PATH); BufferedReader brdFile = new BufferedReader(fr); String strLine = null; while ((strLine = brdFile.readLine()) != null) &#123; strLine = strLine.replace("#", "");//先將資料夾裡面的#改成"" String[] array = strLine.split("@");// 因為是用"@"分開所以用split切開存入字串陣列 System.out.println(strLine); for (int i = 0; i &lt; array.length; i++) &#123;// System.out.println(array[i]); 可以用來檢視分割的檔案是否正確 pstmt.setString(i+1,array[i]); &#125; pstmt.execute(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL語法紀錄]]></title>
      <url>%2F2017%2F03%2F05%2FSQL%E8%AA%9E%E6%B3%95%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[SQL語法紀錄前言一直以來只記得 select insert drop…每次要用都忘記..還是來記錄一下! 基礎語法 操作功能 SQL 語法 說明 建立資料庫 create database 資料庫名稱; 列出所有資料庫 show databases; 刪除資料庫 drop database 資料庫名稱; 使用資料庫 use 資料庫名稱; 建立資料表 create table 資料表名稱(&lt;br&gt;sn integer auto_increment primary key,&lt;br&gt;name char(20),&lt;br&gt;mail char(50),&lt;br&gt;home char(50),&lt;br&gt;messages char(50)); 常用資料庫資料型態 1. INT (整數) 2. CHAR (1~255字元字串) 3. VARCHAR (不超過255字元不定長度字串) 4. TEXT (不定長度字串最多65535字元) 列出資料表欄位資訊 describe 資料表名稱; 修改資料表欄位 alter table 資料表名稱&lt;br&gt;change column 原來欄位名稱&lt;br&gt;新欄位名稱資料型態; 新增資料表欄位 alter table 資料表名稱 add &lt;br&gt;column 欄位名稱 資料型態; 刪除資料表欄位 alter table 資料表名稱 drop column 欄位名稱; 刪除資料表 drop table 資料表名稱; 清空資料表 truncate table 資料表名稱; 只清除資料並保留結構、欄位、索引 … 插入欄位資料 insert into 資料表名稱(欄位1,欄位2,欄位3,欄位4, ...... 欄位N)&lt;br&gt;values(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;,&#39;值4&#39;, ...... &#39;值N&#39;); 更新修改欄位資料 update 資料表名稱 set 欄位1=&#39;值1&#39;,欄位2=&#39;值2&#39;,欄位3=&#39;值3&#39;,... &lt;br&gt;欄位N=&#39;值N&#39;where 條件式 (例如 sn=&#39;5&#39; 或 name=&#39;塔司尼&#39; ); 查詢單一欄位資料 select 欄位名 from 資料表名稱; 查詢多個欄位資料 select 欄位名, 欄位名, 欄位名 from 資料表名稱; 查詢欄位資料的唯一值 select distinct 欄位名 from 資料表名稱; 重複值只列一次 查詢所有欄位資料 select * from 資料表名稱; 條件式查詢 select * from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39;); （=, &lt;, &gt;, !=） 條件式查詢 and select * from 資料表名稱 where 條件式1 and 條件式2; 條件式查詢 or select * from 資料表名稱 where 條件式1 or 條件式2; 查詢某一範圍 between select * from 資料表名稱 where 欄位名 between 值1 and 值2; 值為數字 查詢空值欄位的資料 select * from 資料表名稱 where 欄位名 is null not null; 查詢特定筆數資料 select * from 資料表名稱 limit 8, 10; 第9筆開始選取10筆 查詢結果遞增排序 select * from 資料表名稱 order by 欄位名; 查詢結果遞減排序 select * from 資料表名稱 order by 欄位名 desc ; 查詢比對字串列出單一欄位 select 欄位名 from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 查詢比對字串列出所有欄位 select * from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 刪除條件值資料 delete from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39; 或 id=&#39;91001&#39; ); 刪除條件值資料 delete from 資料表名稱 where 條件式1 and 條件式2; 刪除條件值資料 delete from 資料表名稱 where 條件式1 or 條件式2; 比對刪除條件值資料 delete from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 一筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;; 兩筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;and xxxx=&#39;xxxx&#39;; 一筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39;; 兩筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39; and xxxx=&#39;xxxx&#39;; 進階語法 操作功能 SQL 語法 說明 查看正在執行的行程 show processlist; 查看 Master 狀態 show master status; 查看 Slave 狀態 show slave status\G; 查看 binlog 狀態 show binary logs; 清除過時的 binlog purge binary logs to &#39;mysql-bin.000006&#39;; 將刪除 mysql-bin.000001 ~ 5 的 binlog 參考資料 SQL常用參考資料1 SQL常用參考資料2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[詳細解讀DialogFragment]]></title>
      <url>%2F2017%2F01%2F20%2F%E8%A9%B3%E7%B4%B0%E8%A7%A3%E8%AE%80DialogFragment%2F</url>
      <content type="text"><![CDATA[DialogFragment 版權聲明：轉載請保留原文連結及作者http://www.cnblogs.com/tianzhijiexian/p/4161811.html 相信看這篇文章的人都應該知道android中的Dialog了吧，如果對於Dialog還不是很了解可以看我之前的一篇詳解文章：Dialog詳解：http://www.cnblogs.com/tianzhijiexian/p/3867731.html隨著Fragment這個類的引入，Google官方推薦大家使用DialogFragment來代替傳統的Dialog，那麼是不是說我們之前學習的Dialog知識都沒有用處了呢？非也，新的fragment是來方便大家更好的管理和重用Dialog，之前的知識其實都是可以拿來就用的，僅僅需要少許的改變。 Dialog和DialogFragment的區別和優劣 新來的DialogFragment讓dialog也變成了碎片，相比之前來說應該做了很多優化和處理，對於程序員來看對話框現在更加具體了，就是一個activity上的一個fragment，我們也可以用fragment的知識來管理對話框了。我們看看之前是怎麼運用對話框對象的 1234AlertDialog dialog = new AlertDialog.Builder( this ) .setTitle( "Dialog" ) .setMessage( "thisis a dialog" ) .show(); 如果這個時候屏幕方向發生變化，就會導致Activity重建，然後之前顯示的對話框就不見了。查看log可以發現這個錯誤： 04-1917:30:06.999: E/WindowManager(14495): Activitycom.example.androidtest.MainActivity has leaked windowcom.android.internal.policy.impl.PhoneWindow$DecorView{42ca3c18 V.E…..R……. 0,0-1026,414} that was originally added here 當然我們也可以無視這個錯誤，因為程序不會因此崩潰（看來android本身就已經預料到這種情況了）。 如果我們想要在旋轉屏幕的時候也能保證這個對話框顯示就需要做一定的處理了，在activity要銷毀前設立一個標誌，看這時對話框是否是顯示狀態，如果是那麼activity在下次建立時直接顯示對話框。 在onSaveInstanceState中1234567@Override protected void onSaveInstanceState(Bundle outState) &#123; super .onSaveInstanceState(outState); if (dialog != null &amp;&amp; dialog.isShowing()) &#123; outState.putBoolean( "DIALOG_SHOWN", true ); &#125; &#125; 在onCreat中123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null ) &#123; boolean isShown = savedInstanceState.getBoolean("DIALOG_SHOWN" ); if (isShown) &#123; AlertDialog dialog = new AlertDialog.Builder( this ).setTitle("Dialog" ) .setMessage( "thisis a dialog" ).show(); &#125; &#125; ……&#125; 使用DialogFragment來管理對話框就不會有這種問題了，代碼也少了很多的邏輯處理。當你旋轉屏幕的時候，fragmentManager會自定管理DialogFragment的生命週期，如果當前已經顯示在屏幕上了，那麼旋轉屏幕後夜會自動顯示，下面就是在屏幕旋轉時的log輸出。12345678910111213141516171819202122234-1917:45:41.289: D/==========(16156): MyDialogFragment : onAttach04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreate04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:41.309: D/==========(16156): MyDialogFragment : onStart04-1917:45:50.619: D/==========(16156): MyDialogFragment : onStop04-1917:45:50.619: D/==========(16156): third activity on destroy04-1917:45:50.619:D/==========(16156): MyDialogFragment : onDestroyView04-1917:45:50.619: D/==========(16156): MyDialogFragment : onDetach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onAttach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onCreate04-1917:45:50.659: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:50.659: D/==========(16156): MyDialogFragment : onStart Ok，當然你可以不以為然，你說我的應用就是豎著用的，旋轉屏幕畢竟是小概率事件，誰會開著對話框旋轉來旋轉去啊。那麼相信下面的好處你一定不能否定吧。 我們之前用Dialog的時候，在activity中必須要建立這個對象，而且一般我們都是需要給它放監聽器的，比如下面的代碼： 12345678910111213141516171819202122@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.guid_main); new AlertDialog.Builder(GuideActivity. this ).setTitle("用戶申明" ) .setMessage(getResources().getString(R.string.statement)) .setPositiveButton( "我同意", new positiveListener()) .setNegativeButton( "不同意", new negativeListener()) .setCancelable( false ) .show(); &#125; private class positiveListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; prefs.setIsFirstTime( false ); &#125; &#125; private class negativeListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Util.virtualHome(GuideActivity. this ); &#125; &#125; 你會發現這麼長的代碼很破壞activity中的邏輯性，有木有！！！在activity中我們處理的各種控件的顯示和邏輯，但對於dialog這種不屬於activity並且建立和處理邏輯都自成一體的東西，我們為什麼要在activity中建立呢？而且為了方便重用，我們在實際過程中基本都會建立一個dialog的工具類來做處理，所以為什麼不用DialogFragment來實現呢？如果通過它來實現，我們就能很方便的進行管理對話框。 此外，當旋轉屏幕和按下後退鍵時可以更好的管理其聲明周期，它和Fragment有著基本一致的聲明周期。且DialogFragment也允許開發者把Dialog作為內嵌的組件進行重用，類似Fragment（可以在大屏幕和小屏幕顯示出不同的效果）。有可能我們在大屏幕上就不需要彈出一個對話框了，直接內嵌在activity界面中顯示即可。這點也很贊！ DialogFragment的最簡單用法使用DialogFragment很簡單，甚至比用Fragment還簡單，因為在api中已經實現了fragment切換對象了。 建立一個fragment對象123456789101112131415161718package com.kale.dialogfragmenttest;import android.app.DialogFragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup;public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); // tag which is from acitivity which started this fragment return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 我們建立了一個fragment，讓他繼承了DialogFragment，在onCreatView中通過佈局文件建立了一個view，這和fragment完全一致。 佈局文件如下： 1234567891011121314151617181920212223242526272829303132&lt;? xml version="1.0" encoding="utf-8" ?&gt;&lt; LinearLayout xmlns:android ="http://schemas.android.com/apk/res/android" android:layout_width ="match_parent" android:layout_height ="match_parent" android:orientation ="vertical" android:padding ="16dp" &gt; &lt; TextView android:id ="@+id/textView1" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Large Text" android:textAppearance ="?android:attr/textAppearanceLarge" /&gt; &lt; EditText android:layout_marginTop ="10dp" android:id ="@+id/editText1" android:layout_width ="match_parent" android:layout_height ="wrap_content" android:ems ="10" &gt; &lt; requestFocus /&gt; &lt;/ EditText &gt; &lt; Button android:id ="@+id/button1" android:layout_marginTop ="10dp" android:layout_gravity ="center_horizo​​ntal" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Button" /&gt;&lt;/ LinearLayout &gt; 在activity中啟用這個dialog12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new DialogFragmentTest() .show(getFragmentManager(), "dialog_fragment" ); &#125; 很像Dialog吧，也是支持鍊式編程的。這裡面的參數： ① 一個fragmentManager，在低版本中用getSupport來獲取；② 一個tag（String）通過這個tag可以告訴fragment是誰啟動了它，當然這僅僅是這個tag的一種使用方式啦。在fragment中可以通過getTag()方法來獲取這個tag 這裡多說一句，在一年前我還一直說要兼容要兼容，不兼容的demo是很不負責任的，但是現在來看，低版本的用戶真的很少很少了，而且這些低版本的用戶已經不能是我們的主流用戶了，所以在2014年末，我可以負責任的說，可以不用兼容2.x的系統了。我之前寫過很多兼容的文章，actionbar啊，對話框的兼容啊，但現在都變得無所謂了，其實任何事物的發展都是如此。很多之前很重要的技術，在新的發展中已經慢慢變得無足輕重了，但我們之前為之付出的東西卻不是無價值的。一個原因是為自己之前的工作找到價值，一種是在那段時光中我們慢慢體會到了很多東西，這些東西就是我們的閱歷也是一種談資。 好，閒話少敘，下面是運行效果： 有人會說，上面的那個空白的title好醜，我想去掉。當然可以，這就是fragment的好處，用這個方法： getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); 12345678910public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 現在它變成了這個樣子： 所以你可以看到，任何改變都是要付出代價的，如果你還是像之前一樣用match_parent來製定控件的寬度，那麼就是這種結果。可以說那個title欄就是一個房梁，支撐著對話框的寬度，沒了它就只能自適應了。解決辦法就是自定義控件的寬度，寫個幾百dp啥的，沒任何技術難度。 注意： 如果你的DialogFragment是Activity的內部類，必須將DialogFragment定義為靜態的。否則會報錯！！！ 123456789public static class DialogFragmentTest extends DialogFragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // TODO自動生成的方法存根 return inflater.inflate(R.layout.dialog, null ); &#125; &#125; DialogFragment啟動、終止過程分析之前說了，我們沒有像fragment那樣建立一個fragment加載對象進行fragment的加載，也沒有commit，但卻能使用dialogFragment對象，這是為什麼呢？ 我們先來回顧下fragment是怎麼使用的。 ① 建立FragmentManager對象，用來管理fragment ② 建立fragmentTransaction對象，用來添加和fragment ③ 提交fragment切換（commit） 123456FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction ft = fragmentManager.beginTransaction(); ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE); ft.add(R.id.container_fragment, new MyFragment()) .commit(); 替換fragment的方法 1234getSupportFragmentManager().beginTransaction(). replace(R.id.container_fragment02, fragment) .addToBackStack( null ) .commit(); 現在，我們通過源碼來分析下DialogFragment的啟動方式 我們在使用它的時候沒有去用fragmentTransaction對象，也沒有執行add，也沒有執行commit，僅僅提供了一個fragmentManager，那麼它是怎麼被添加的呢？我們知道這個對話框是用show方法顯示的，那麼就來看看這個方法吧。 DialogFragment源碼：1.show()1234567public void show(FragmentManager manager, String tag)&#123; mDismissed = false ; mShownByMe = true ; FragmentTransaction ft = manager.beginTransaction(); // creat a fragmentTransaction ft.add( this , tag); // add fragment with tag ft.commit(); &#125; 真相大白，api自動給你實現了一個fragment切換的對象，而且在show的時候就已經add了fragment，所以沒有任何問題~ 在add方法中沒有提供容器的id，所以表示是加載到當前activity中的，在添加後也的確調用了commit方法3 show()的另一種形式12345678public int show(FragmentTransaction transaction, String tag) &#123; mDismissed = false ; mShownByMe = true ; transaction.add( this , tag); mViewDestroyed = false ; mBackStackId = transaction.commit(); return mBackStackId; &#125; 上面的show方法傳入的是一個fragmentTransaction對象，這個也很容易理解。我們之前傳入fragmentManager對象的目的就是生成這個fragmentTransaction對象，這回我們可以在傳入一個已經配置好的fragmentTransaction對象，大大增加了可定制性。所以api的製訂也是大神們心血的結晶啊。 dimiss()1234567891011121314151617181920212223242526272829303132333435** * Dismiss the fragment and its dialog. If the fragment was added to the * back stack, all back stack state up to and including this entry will * be popped. Otherwise, a new transaction will be committed to remove * the fragment. */ public void dismiss() &#123; dismissInternal( false ); &#125; void dismissInternal( boolean allowStateLoss) &#123; if (mDismissed) &#123; return ; &#125; mDismissed = true ; mShownByMe = false ; if (mDialog != null ) &#123; mDialog.dismiss(); mDialog = null ; &#125; mViewDestroyed = true ; if (mBackStackId &gt;= 0 ) &#123; getFragmentManager().popBackStack(mBackStackId, FragmentManager.POP_BACK_STACK_INCLUSIVE); mBackStackId = -1 ; &#125; else &#123; FragmentTransaction ft = getFragmentManager().beginTransaction(); ft.remove( this ); if (allowStateLoss) &#123; ft.commitAllowingStateLoss(); &#125; else &#123; ft.commit(); &#125; &#125; &#125; 我們知道瞭如果一個DialogFragment關閉的時候會檢查堆棧裡面有沒有其他的對象，如果有就pop出來，如果沒有就直接remove和commit。也就是說：如果back stack堆棧有該Dialog，將其pop出來，否則ft.remove(this); ft.commit();。估計pop的操作也包含ft.remove()和ft.commit()。調用dismiss()會觸發onDismiss()回調函數。 跟踪狀態，如下： 通過onCreateView()來建立對話框佈局 上面的例子中我們已經在onCreateView()建立的對話框佈局，這時fragment中建立佈局的傳統寫法， 很適合用於自定義的對話框，我們可以修改任何的東西，包括對話框的style。 上面的例子中我們已經乾掉了對話框上面title的區域，而我們也沒發現可以設置標題的方法， 感覺上面那個標題欄就是個標題黨，毫無意義（之後會說到這塊區域的用處） 。 我們在onCreat中可以設置對話框的風格和各種屬性，但是千萬別設置關於view的東西，因為這時候對話框還沒建立呢，有關於view的東西在onCreatView中去設置吧，這裡我簡單設置了一個button的點擊事件——關閉對話框 123456789101112131415161718192021222324252627282930public class MyDialogFragment extends DialogFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); // 如果setCancelable()中參數為true，若點擊dialog覆蓋不到的activity的空白或者按返回鍵， // 則進行cancel，狀態檢測依次onCancel()和onDismiss()。如參數為false，則按空白處或返回鍵無反應。缺省為true setCancelable( true ); // 可以設置dialog的顯示風格 // setStyle(style,theme); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View rootView = inflater.inflate(R.layout.dialog, null ); Button btn = (Button)rootView.findViewById(R.id.button); btn.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO自動生成的方法存根 dismiss(); &#125; &#125;); return rootView; &#125;&#125; 補充：實現信息保存在activity橫豎屏切換的時候，dialog現在可以自動重建了，如果你在editText中輸入了信息，在重建的時候會不會保留之前的呢？在4.2和4.4中對話框人性化的自定保存了之前輸入的內容，我們無須手動處理。但如果你測試的手機被奇葩的定制了，那就乖乖的保存數據吧。 123456789101112131415161718192021222324public class MyDialogFragment extends DialogFragment &#123; EditText editText; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.dialog, null ); editText = (EditText) rootView.findViewById(R.id.editText); if (savedInstanceState != null ) &#123; CharSequence text = savedInstanceState.getCharSequence( "input data" ); editText.setText(text == null ? "" : text); &#125; return rootView; &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; outState.putCharSequence( "input data" , editText.getText()); super .onSaveInstanceState(outState); &#125;&#125; 通過onCreateDialog()來快捷的建立對話框我們上面建立的對話框都是用自定義佈局的，難道我們之前學過的dialog知識都沒用了麼？我們如果沒自定義對話框的需求，怎麼辦？就沒有一種快一點的方式來建立對話框麼？快用onCreatDialog吧！！！這個回調方法是DialogFragment獨有的，通過它返回的是一個Dialog對象，這個對象就會被顯示到屏幕上。千萬別同時使用onCreatView和onCreatDialog方法，他們僅僅是為了完成同樣一個目的的兩條路而已。 PS：從生命週期的順序而言，先執行onCreateDialog()，後執行onCreateView() 我在onCreatDialog建立一個警告對話框的builder，通過這個builder的create()方法來生成一個AlertDialog對象，因為AlertDialog是Dialog的子類，所以可以直接返回給Dialog。這裡可以用其他不同對話框的builder，代碼類似，只不過就是通過builder的creat()方法返回的是不同的對象而已。builder模式也是蠻巧妙的~ 1234567891011121314151617181920public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener&#123; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ) .setNegativeButton( "不同意", this ) .setCancelable( false ); //.show(); // show cann't be use here return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 &#125;&#125; 顯示效果： 看到了麼，這裡的標題欄終於有用了，原來那個標題欄是為了給我們在這裡用的啊~ 注意： ① 因為這裡創建的是一個dialog，所以用的onclickListener自然是對話框中的listener了。 ② 千萬別在構建對話框對象的時候順手寫了show()方法，我們現在是在fragment中初始化一個對話框，真正讓他顯示的時候是在activity中用這個dialogFragment對象顯示的。如果這裡寫了show方法不會報錯，但是會出現兩個對話框！ 那麼，我們能不能在這裡自定義對話框呢？當然可以啦，本身Dialog.builder就提供了自定義view的方法，和之前用Dialog一樣自定義下viwe就搞定了。 123456789101112131415161718192021@Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.fragment_login_dialog, null ); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout builder.setView(view) // set your own view // Add action buttons .setPositiveButton("Sign in" , new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int id) &#123; &#125; &#125;).setNegativeButton( "Cancel", null ); return builder.create(); &#125; 這裡貼下我在另一篇文章的自定義對話框view的代碼片段： 詳細看這裡：http://www.cnblogs.com/tianzhijiexian/p/3867731.html 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定義視圖對話框 * * @param title */ public void viewDialog(String title) &#123; // LayoutInflater是用來找layout文件夾下的xml佈局文件，並且實例化 LayoutInflater factory = LayoutInflater.from(mContext); // 把activity_login中的控件定義在View中 View view = factory.inflate(R.layout.dialog_layout, null ); // 將LoginActivity中的控件顯示在對話框中 // 獲取用戶輸入的“用戶名”，“密碼” // 注意：view.findViewById很重要，因為上面factory.inflate(R.layout.activity_login, // null)將頁面佈局賦值給了view了 TextView titleTv = (TextView) view .findViewById(R.id.dialog_textView_id); titleTv.setText(title); Button btn = (Button) view.findViewById(R.id.dialog_logout_button_id); btn.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; showToast( "按下自定義視圖的按鈕了~" ); &#125; &#125;); builder // 設定顯示的View .setView(view); // 設置dialog是否為模態，false表示模態，true表示非模態 // ab.setCancelable(false); // 對話框的創建、顯示,這裡顯示的位置是在屏幕的最下面，但是很不推薦這個種做法，因為距底部有一段空隙 AlertDialog dialog = builder.create(); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); // 此處可以設置dialog顯示的位置 window.setWindowAnimations(R.style.myAnimationstyle); // 添加動畫 dialog.show(); &#125; DialogFragment與Activity之前進行通信思路很簡單，就是定義一個傳輸數據的接口，強制activity實現這個接口，在fragment需要傳遞數據的時候去調用這個接口的方法，activity就能在這個方法中得到相應的數據了。這點在之前的fragment傳遞數據中已經介紹過了， 可以參考這篇文章：http://www.cnblogs.com/tianzhijiexian/p/3888330.html 在真正項目中，fragment的編寫並不需要了解activity的各類方法，好的編程風格是將fragment所涉及的方法以接口的方式封裝起來，我在此寫一個例子來說明一下。 寫一個接口——DataCallback123456package com.kale.dialogfragmenttest;public interface DataCallback &#123; public void getData(String data);&#125; activity實現這個接口123456789101112131415161718public class MainActivity extends Activity implements DataCallback&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new MyDialogFragment() .show(getFragmentManager(), "dialog_fragment" ); &#125; @Override public void getData(String data) &#123; // TODO自動生成的方法存根 System.out.println("data = "+ data); &#125;&#125; 在DialogFragment中使用這個接口在DialogFragment中使用這個接口，並且用instanceof來看啟動它的activity是否實現了這個接口，如果沒實現就拋出異常。這樣我們就能保證在大型項目中不會出現忘記實現這個接口的問題了。 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Activity; import android.app.AlertDialog; import android.app.AlertDialog.Builder; import android.app.Dialog; import android.app.DialogFragment; import android.content.DialogInterface; import android.os.Bundle ;public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener &#123; @Override public void onAttach(Activity activity) &#123; // onAttach()是合適的早期階段進行檢查MyActivity是否真的實現了接口。 // 採用接口的方式，dialog無需詳細了解MyActivity，只需了解其所需的接口函數，這是真正項目中應採用的方式。 if (!(activity instanceof DataCallback)) &#123; throw new IllegalStateException("fragment所在的Activity必須實現Callbacks接口" ); &#125; super .onAttach(activity); &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ).setNegativeButton("不同意", this ) .setCancelable( false ); // show(); return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 DataCallback callback = (DataCallback) getActivity(); callback.getData( "test" ); &#125;&#125; 此外fragment也可以通過fragment管理器，通過tag，獲取其他fragment實例，從而進行fragment之間的通信。當然從編程思想的角度看，fragment之間的過多進行交叉調用，不利於程序的管控。 用DialogFragment實現再次彈窗有時候我們可能有這樣的需求，點擊對話框中的一個按鈕後又彈出一個對話框，這個該怎麼做呢？首先在點擊事件中將這個對話框在屏幕上移除，然後把這個fragment壓棧，最後建立一個新的dialogFragment對象，show出來。我們雖然讓這個fragment在屏幕上消失，但還是可以通過fragment管理器到回退棧中找到它。 二次彈窗的代碼：123456789101112131415161718FragmentTransaction ft = getFragmentManager().beginTransaction(); /* * 如果不執行remove()，對話框即不會進入onDismiss()狀態。會被顯示在新的對話框下方，是可見的。 * 主要考慮美觀的問題，如果下面的對話框大於上面的對話框就很難看了。對於Dialog，container為0或者null。 */ ft.remove( this ); /* * 將當前的PromptDialogFragment加入到回退堆棧，當用戶按返回鍵，或者通過按幫助框的Close按鈕dismiss幫助框是， * 重新顯示提示框。對於back stack的處理，系統具有一定的智能。例如：執行兩次addToStackStack()，實際不會重複壓棧。 * 有例如：註釋掉remove()語句，即提示框不消失，而是在幫助框的下面。 * 但是在實驗中發現是否有addToBackStack()都不會結果有影響，系統能夠分析到對象存在，不需要壓棧。沒有去查源代碼， * 猜測通過mBackStackId比對來進行智能處理。 */ ft.addToBackStack( null ); new OhterDialogFragment() .show(getFragmentManager(), "dialog_fragment"); 利用Fragment的特性，為不同屏幕做適配如果我們想在大屏幕上顯示對話框，而小屏幕中直接把對話框的內容放在activity中顯示呢？ 其實也很簡單，本身這個dialogFragment就是一個fragment，所以完全有fragment的特性，你可以用fragmentTranscation將其放到任何佈局中，你也可以用show()方法把它當作dialog顯示出來。接下來就剩下一個問題了，判斷屏幕大小。 在默認的values下新建一個bools.xml 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; false &lt;/ bool &gt; &lt;/ resources &gt; 然後，在res下新建一個values-large，在values-large下再新建一個bools.xml，通過加載不同的value就能知道是大屏還是小屏幕啦 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; true &lt;/ bool &gt; &lt;/ resources &gt; 在代碼中進行判斷 123456789101112131415161718192021public void showDialogInDifferentScreen(View view) &#123; FragmentManager fragmentManager = getFragmentManager(); EditNameDialogFragment newFragment = new EditNameDialogFragment(); boolean mIsLargeLayout = getResources().getBoolean(R.bool.large_layout) ; Log.e( "TAG", mIsLargeLayout+"" ); if (mIsLargeLayout ) &#123; // The device is using a large layout, so show the fragment as a // dialog newFragment.show(fragmentManager, "dialog" ); &#125; else &#123; // The device is smaller, so show the fragment fullscreen FragmentTransaction transaction = fragmentManager.beginTransaction(); // For a little polish, specify a transition animation transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN); // To make it fullscreen , use the 'content' root view as the // container for the fragment, which is always the root view for the activity transaction.replace(R.id.id_ly, newFragment).commit(); &#125; &#125; 參考http://blog.csdn.net/huangyabin001/article/details/30053835 http://blog.csdn.net/lmj623565791/article/details/37815413 http://www.cnblogs.com/tianzhijiexian/p/4161811.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升倉管備料效率-小程式]]></title>
      <url>%2F2017%2F01%2F19%2Favexir%E5%82%99%E6%96%99%2F</url>
      <content type="text"><![CDATA[計算bom表 小程式前言 版權聲明：轉載請保留原文連結及作者由於公司產品種類太多,User RMA回來數量都一樣兩樣很散一個User要去ERP開一張單,但ERP沒辦法把多張單合併包材集中在一張單,導致倉管必須一張單一張單備料由於這樣實在沒效率,所以寫個小程式把User購買的外部料號KEY在程式裡自動會算出需要的包材數量 效果 把外部料號,內部料號打進去會自動算出,倉管需要備東西把客戶名稱日期打上,可以記錄倉管幾月幾號幫RMA備料倉管可以自行反查紀錄,也會紀錄備料人員是誰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Textinputlayout使用及自訂義顏色]]></title>
      <url>%2F2017%2F01%2F16%2FTextinputlayout%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%87%AA%E8%A8%82%E7%BE%A9%E9%A1%8F%E8%89%B2%2F</url>
      <content type="text"><![CDATA[版權聲明：轉載請保留原文連結及作者http://blog.csdn.net/android_freshman/article/details/51136657 Textinputlayout gradle 配置12compile ‘com.Android.support:design:22.2.0’compile ‘com.android.support:appcompat-v7:22.2.0’ xml1234private android.widget.LinearLayout.LayoutParams setEditText(EditText editText, LayoutParams lp) &#123; if(this.mEditText != null) &#123; throw new IllegalArgumentException("We already have an EditText, can only have one"); &#125; else &#123; 注意點：部分源代碼中的內容，TextInputLayout 繼承LinearLayout 且裡面只能有一個editEditText，和scrollView 很像。下面是佈局文件： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.design.widget.TextInputLayout android:id="@+id/titleTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:layout_marginLeft="40dp" android:layout_marginRight="15dp" app:errorTextAppearance="@style/TextInput_Error_style"&gt; &lt;EditText android:id="@+id/title" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/white" android:singleLine="true" android:hint="Title"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/descriptionsTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="40dp" android:layout_marginRight="15dp"&gt; &lt;EditText android:id="@+id/descriptions" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp" android:textColor="@color/white" android:hint="Descriptions"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; java 注意：不能重寫TextInputLayout的OnFocusChangeListener的監聽事件，因為在源代碼中定義了動畫效果和editText注入，重寫了會導致動畫失效。設置浮動標籤動畫效果titleTextInput.setHint(“Title”); 123456if(titleEditText.getText().toString().length()&lt;6)&#123; titleTextInput.setErrorEnabled(true); titleTextInput.setError("title length must &gt;= 6");&#125;else &#123; titleTextInput.setErrorEnabled(false);&#125; 這一部分是動態錯誤提示的相關代碼 完成上面的，基本就可以出現TextInputLayout 的動畫效果了，但是默認的顏色不是很好看，所以我們需要自定義相關的顏色，比如hint 字的顏色，下劃線的顏色，錯誤字體的顏色大小等，下面就是自定義顏色的部分： google把Design Support Library寫的很好。每一個控件的顏色都是直接通過主題顏色繪製的，在style.xml 中指定。打開它添加colorAccent 到主題以改變表單的顏色。在style.xml 中修改相關的屬性 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/primary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt; &lt;!--&lt;item name="colorAccent"&gt;#3498db&lt;/item&gt;--&gt; &lt;item name="android:textColorHint"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlNormal"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlActivated"&gt;@color/white&lt;/item&gt; &lt;item name="colorControlHighlight"&gt;@color/white&lt;/item&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; colorAccent 是什麼意思，哪裡的顏色 這張圖片基本說明了colorAccent代表的顏色，而在google的官網上：https://www.google.com/design/spec/style/color.html#color-color-schemes 也有相關的說明 其他相關顏色的說明 android:textColorHint代表hint的顏色colorControlNormal代表下劃線沒有獲取焦點的顏色colorControlActivated，colorControlHighlight代表了獲取焦點或者點擊的時候下劃線的顏色 錯誤提示的顏色說明：默認的錯誤提示的顏色是紅色：在這種背景色下面，紅色不是很好看，所以需要自定義顏色 在設置佈局的時候errorTextAppearance這個屬性，自定義style 寫顏色和大小就可以了，至於另一個屬性hintTextAppearance 這個屬性修改顏色，好像沒有什麼效果，不起作用。 修改之後的效果，如下圖：有的機器上面可能沒有效果，下面提供一種解決方案： 123456789101112public static void setErrorTextColor(TextInputLayout textInputLayout, int color) &#123; try &#123; Field fErrorView = TextInputLayout.class.getDeclaredField("mErrorView"); fErrorView.setAccessible(true); TextView mErrorView = (TextView) fErrorView.get(textInputLayout); Field fCurTextColor = TextView.class.getDeclaredField("mCurTextColor"); fCurTextColor.setAccessible(true); fCurTextColor.set(mErrorView, color); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 這個是material design 的說明文檔：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText 的拍擋 - TextInputLayout]]></title>
      <url>%2F2017%2F01%2F14%2FTextInputLayout%2F</url>
      <content type="text"><![CDATA[toggleButtong 版權聲明：轉載請保留原文連結及作者http://blog.30sparks.com/material-design-6-textinputlayout/ Android Design Support Library 提供一個TextInputLayout 元件，可用來包著 EditText，令 EditText 得到 focus 時，自動將 hints 變成標題： 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" &gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Your name" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 效果 一個 TextInputLayout 只能容納一個 EditText，所以每個 EditText都需要自訂各自的 TextInputLayout。 關於 HintTextInputLayout 可直接使用 EditText 上的 hint，用來當成 header 。不過，你也可直接設定 hint 到 TextInputLayout 上，它們的效果也是相同的，值得留意的是，你可同時設定 hint 到 TextInputLayout 和 EditText 上。這樣的話，它們一開始會重叠，而當拿到 focus 時，在 TextInputLayout 上的 hint 會被拿來當 header ，而在 EditText 上的會跟以往一樣，有文字輸入後 hint 會消失。不過我想，在正常情況下應該不會這樣做吧？ 字數統計可使用 app:counterEnabled=&quot;true&quot; 和 app:counterMaxLength 可設定顯示輸入文字的長度。 錯誤訊息 TextInputLayout 還有另一好處，是可以顯示錯誤訊息。透過 textInputLayout.setError(&quot;Erorr in name input&quot;)便在底部可顯示錯誤訊息。 例如為我們之前加的 EditText 加進驗証的的話，可以這樣做 123456789101112131415 final TextInputLayout nameLayout = (TextInputLayout)findViewById(R.id.til_et_name);final EditText nameEditText = (EditText)findViewById(R.id.et_name);final Button button = (Button) findViewById(R.id.btn_submit);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(nameEditText.length() == 0)&#123; nameLayout.setError("Error in name input"); &#125; else&#123; nameLayout.setError(null); &#125; &#125;&#125;); 這樣當按 button 時，若 nameEditText 沒有文字的話，便會顯示 “Error in name input”。 不過有留意到顯示錯誤訊息時，整個 messageEditText 會被推下，因為當初 TextInputLayout 沒有預留空間去顯示錯誤訊息！想避免此情況，可以先設定1nameLayout.setErrorEnabled(true); 或者在 layout xml 上加入app:errorEnabled=&quot;true&quot; 123456&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" app:errorEnabled="true" &gt; 這樣，TextInputLayout 便會預留空間去顯示錯誤訊息了。留意的是，你可用 nameLayout. setErrorEnabled(false) 的話，去消除錯誤訊息，但整個layout 會被拉上去 (因錯誤訊息的位置也會被消除)。若不想 layout 移動的話，便應用nameLayout.setError(null) 去消除。 Style顏色想簡單更改底線顏色的話，可到 style.xml 修改 colorAccent 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- ...other style settings --&gt; &lt;item name="colorAccent"&gt;#0000FF&lt;/item&gt;&lt;/style&gt; header若只想改變 header 顏色 ，可使用 app:hintTextAppearance=&quot;style&quot;。先到 style.xml 中加入 TextInputHint 1234&lt;style name="TextInputHint" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#AA2288&lt;/item&gt;&lt;/style&gt; 然後加到 TextInputLayout 加入 app:hintTextAppearance=&quot;@style/TextInputHint &quot; 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:hintTextAppearance ="@style/TextInputHint "&gt; 佷簡單便可修改 header 的風格了。 錯誤訊息要更改錯誤訊息的顏色的話，跟改 header顏色的方法差不多，這次使用的是app:errorTextAppearance。 style.xml: 1234&lt;style name="TextInputError" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#FF00FF&lt;/item&gt;&lt;/style&gt; layout: 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:errorTextAppearance="@style/TextInputError"&gt; 這樣便可以自訂錯誤訊息的風格了。 結語要令文字輸入的 UI 更具動感，TextInputLayout 是一個很方便簡單的工具。快加到你的 UI 中吧。 相關連結 Material Design Patterns 官方文件 - TextInputLayout Working with the EditText]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-line聊天分割]]></title>
      <url>%2F2017%2F01%2F13%2Fjava-line%2F</url>
      <content type="text"><![CDATA[line 聊天記錄 分割 版權聲明：轉載請保留原文連結及作者以前想看line紀錄但太長了寫了一個以日期來分聊天記錄的小程式但效率不是很好也沒有太多時間回去在優化他了如果剛學java的可以自己寫一個看看 效果 主要思路 把txt讀近來後每一行判斷字串 是否有日期例如2016/01/31（日） 先把日期改成你想要的方式 先儲存一份在讀取新的txt 讀到你更改後的日期格式,把日期存成檔案名稱裡面的內容存到txt裡,讀到下一個日期停止先存一份更改日期的用意是.聊天內容或許會有日期或是/ 會抓錯其他應該很簡單就不再詳細敘述了分割好的內容會自動存在C:\LINE 資料夾內 下載點 下載點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toggleButton]]></title>
      <url>%2F2017%2F01%2F05%2FtoggleButton%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下 效果 程式碼 程式碼分成兩類 圖片繪製 點擊事件 布局XML 直接打上自定義原件類別名就可 12345678&lt;com.togg.toggiebutton.CustomToggleButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tb_backround" android:id="@+id/view"&gt;&lt;/com.togg.toggiebutton.CustomToggleButton&gt; onMeasure12345678910protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //底層圖片 backBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tb_backround); //上層圖片 overBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.slide_backround); //寬高和底層圖片一樣 setMeasuredDimension(backBitmap.getWidth(), backBitmap.getHeight()); &#125; onDraw1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; //2.繪制上層圖片 if (isTounching) &#123;//上層圖片跟随滑動 /** * * 防止上層圖片滑動出下層圖片的范围 */ //算出當前觸碰點為上層圖片的中心點時，上層圖片的左侧座標距離 int left = currentX - overBitmap.getWidth() / 2; System.out.println(left + "left 數值" + currentX + "currentx"); if (left &lt; 0) &#123;//防止左侧出界 left = 0; &#125; else if (left &gt; backBitmap.getWidth() - overBitmap.getWidth()) &#123;//防止右侧出界 left = backBitmap.getWidth() - overBitmap.getWidth(); &#125; canvas.drawBitmap(overBitmap, left, 0, null); &#125; else &#123;//上層圖片直接跳到開或關的位置 if (state) &#123; //開 canvas.drawBitmap(overBitmap, backBitmap.getWidth() - overBitmap.getWidth(), 0, null); listener.rightClick(); &#125; else &#123; //關 canvas.drawBitmap(overBitmap, 0, 0, null); listener.leftClick(); &#125; &#125; &#125; onTouchEvent123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //按下為true isTounching = true; //當前觸碰點的x座標 currentX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: isTounching = true; currentX = (int) event.getX(); break; case MotionEvent.ACTION_UP: //抬起時觸碰狀態為false isTounching = false; currentX = (int) event.getX(); break; &#125; //觸碰點超過底層圖片的一半，則state為true,開的狀態 state = currentX &gt; backBitmap.getWidth() / 2; //重新繪制 invalidate(); return true; &#125; 點擊1234567891011private topbarClickListener listener; public interface topbarClickListener &#123; public void leftClick(); public void rightClick(); &#125; public void setOntopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; MainActivity12345678910111213CustomToggleButton cust = (CustomToggleButton) findViewById(R.id.view); cust.setOntopbarClickListener(new CustomToggleButton.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left click", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,"right click",Toast.LENGTH_SHORT).show(); &#125; &#125;); 結尾 這個樣子可直接在你要使用的類 直接new就可以直接使用了 如果要使用各式各樣的開關 只需更改圖片 就可直接使用了 如果一個程式要使用多種開關 把onMeasure 裡面的底層 上層圖寫成外部輸入圖就可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 end]]></title>
      <url>%2F2016%2F12%2F31%2F2016-end%2F</url>
      <content type="text"><![CDATA[離起點又遠了一些,離終點又進了一點無論今天在困難,明天終究會到來無論今年發生多少事,到了明年還是會變成回憶中的故事這一切終究會拼湊成一個一個完整的人生新的一年,不要忘了完成那些該完成的事情謝謝周遭的許多人幫助了我非常非常多的事情有了你們這一切才會變成可行的事情 2016年度總結 今年接了幾個開發的案子,經歷了一大段很挫折壓力大到爆表的日子也接了幾個私人伺服器的協助開發,這段日子應該算是最快樂的,有錢賺還可以玩遊戲XDD也謝謝幾位高材生協助指導讓我完成這一串事情..整年度大部分時間都在學著嵌入式開發,當要開發的時候C已經忘得差不多了,花了很多的時間在學這一部分,在硬體開發部分由於對於電路不是很懂,有時候並不是代碼有寫錯而是電路的問題,常常在浪費時間在原地打轉.每當回去寫APP的時候都會忘記那時候到底在寫什麼,寫到了哪裡,那時候在想什麼年初給自己的目標,完成了六成,希望明年可以在努力一點今年應該算是最枯燥的一年,但今年的知識吸收量應該是以前的好幾倍,已結果來說還蠻滿意的年底架設了這個部落格,慢慢的會把自己所開發的過程放上來,如果有時間會把一些開源也慢慢的會把evernote上記錄的資料也移過來 2016書單 學失敗：創業熱時代看不見的退場故事 創業投資聖經：Startup募資、天使投資人、投資契約、談判策略全方位教戰法則 免費！揭開零定價的獲利祕密 自己的品牌自己做：企業自媒化，營造忠實顧客群的品牌經營方針 競爭論 創業的藝術 工作大解放：這樣做事反而更成功 從0到1：打開世界運作的未知祕密，在意想不到之處發現價值 全方位把玩Android 400個API：精挑細選365個實例說明 ARM Cortex-M4+Wi-Fi MCU應用指南：CC3200 CCS基礎篇 ARM Cortex-M3與Cortex-M4權威指南 拖延心理學：為什麼我老是愛拖延？是與生俱來的壞習慣，還是身不由己？ 創新者的窘境 30年心血，品牌之父艾克終於說出的品牌王道：微軟、可口可樂、麥當勞、三星、P&amp;G，全球行銷長都在讀的20終極法則 今年淺讀了這些書,雖然還有幾本還沒讀完..!!!!!2016也訂了一年份的空中英語教室月刊希望明年的今天語言部分可以進步很多 20172017 年度計畫 今年預計後半年要花點時間學python 今年也會開始學Machine Learning很大部分會完成2016該完成還沒完成的事情,加上一點突發狀況明年應該就這樣結束了慢慢的習慣把學習紀錄,資料記錄寫到部落格上 2017 書單 引爆社群：移動互聯網時代的新4C法則 稀缺：我們是如何陷入貧窮與忙碌的 TED TALKS 說話的力量：你可以用言語來改變自己，也改變世界 TED唯一官方版演講指南 不懂帶團隊，那就大家一起死！：行為科學教你把豬一般的隊友變菁英 沒經驗，是你最大優勢 賽局理論，解決問題最簡單的方法 文案力：如果沒有文案，這世界會有多無聊？ 釣愚：操縱與欺騙的經濟學 Python 自動化的樂趣｜搞定重複瑣碎 &amp;單調無聊的工作 解事者：複雜的事物我簡單說明白 如果這樣，會怎樣？：胡思亂想的搞怪趣問 正經認真的科學妙答 商業冒險：華爾街的12個經典故事 債的歷史：從文明的初始到全球負債時代 我的思考，我的光：諾貝爾獎得主中村修二創新突破的7個思考原點 如果中途有看到喜歡的書在新增上來 END 想起前陣子跟朋友討論一本俄羅斯的小說裡面有段話挺有趣的真正的窮人,是那種群聚在一起的人,而孑然一身的窮人,不過是沒賺到錢的有錢人罷了 任何值得去的地方 都沒有捷徑努力配得上你的夢想那麼你的夢想也不會辜負你的努力送給自己一句話自律能讓你更優秀 加油！！！！2016再見 2017加油!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout]]></title>
      <url>%2F2016%2F12%2F15%2FMy-New-post%2F</url>
      <content type="text"><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下在安卓5.0有新增了TabLauout但他並不能滿足很多時候想顯示的樣子所以使用V4下的FragmentPagerAdapter來實現.請記得都要import v4 否則會報錯呈現的效果如下 效果 程式碼 程式碼分成四類 FragmentPagerAdapter ArrayList&lt;Fragment&gt;() 初始化三個布局 更改點擊的布局屬性 布局XML 從上面的效果可以看的出來 沒選重的狀況下其他兩個字體大小要一置 選重的要變大 下底線要與字體長度一樣 程式碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:orientation="horizontal"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/id_tab_trend" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_trend" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_trend_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_surrounding" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_sourrounding" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_surrounding_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_appliances" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_appliances" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_appliances_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在一個LinearLayout裡面 再放三個`LinearLayout`` 按照比例分配`android:layout_weight=”1”`` 點擊後在程式碼將點擊的layout_weight 改成你要的比例在把字體放大 Fragment1234567mFragment = new ArrayList&lt;Fragment&gt;(); Fragment mTab01 = new TrendFragment(); Fragment mTab02 = new SurroundingFragment(); Fragment mTab03 = new AppliancesFragment(); mFragment.add(mTab01); mFragment.add(mTab02); mFragment.add(mTab03); FragmentPagerAdapter1234567891011121314151617181920212223242526272829303132333435mAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragment.get(position); &#125; @Override public int getCount() &#123; return mFragment.size(); &#125; &#125;; mViewPager.setAdapter(mAdapter); // Touch Replace the content area mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; 重置 這邊來判斷字的寬度 來依照讀取的寬度來設定線的長度 這邊只貼其中一組 textview ImageView 請在自行補上其他的1234567891011private void resetColor() &#123; mTvTrend.setTextColor(getResources().getColor(R.color.tab_not_selectedl_Color)); mTvTrend.setTextSize(NOT_SELECTED); mTvTrend.setText(one); mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayoutCompat.LayoutParams.WRAP_CONTENT, 1.0f)); mTabtrendImg.setBackgroundResource(R.drawable.tabline); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); 點擊 在點擊的時候先呼叫一次resetColor(); 在設定布局比例 文字大小 123456public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.id_tab_trend: setSelect(0); break; 12345678910111213141516public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 滑動 別忘了上面寫的ViewPage事件 12345public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; 123456789101112131415public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 結尾 程式碼可以在寫一個class來去放 這樣會比較好維護一點 下底線圖片要改成.9會比較好一點]]></content>
    </entry>

    
  
  
</search>
