<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[scikit-learn machine learning (一) (學習筆記整理)]]></title>
      <url>%2F2018%2F03%2F01%2Fscikit-learn-machine-learning-1%2F</url>
      <content type="text"><![CDATA[整理一下自己學習的筆記 也希望可以幫助到正在學習機器學習的人這篇程式是在Jupyter Notebook 上執行編譯的 創建 Numpy.array 的方法 import numpy as np 創建0矩陣 1np.zeros(10) 結果array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 創建的數值 默認是浮點數 1np.zeros(10).dtype 結果dtype(‘float64’) 建立10個整數 1np.zeros(10 , dtype = int ) 結果array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 也可以傳入二維 1np.zeros( (3 , 5 ) ) 結果array([[0., 0., 0., 0., 0.],[0., 0., 0., 0., 0.],[0., 0., 0., 0., 0.]]) 第一個參數他是名子的 也可以這樣寫 1np.zeros( shape = (3 , 5 ) , dtype = int ) 結果array([[0, 0, 0, 0, 0],[0, 0, 0, 0, 0],[0, 0, 0, 0, 0]]) 獲得全1的向量 1np.ones(10) 結果array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) 當然這也可以傳入二維 1np.ones( ( 3 , 5 ) ) 結果array([[1., 1., 1., 1., 1.],[1., 1., 1., 1., 1.],[1., 1., 1., 1., 1.]]) 傳入指定值 傳入555 是 整型 要浮點型 要輸入555.0 1np.full ( ( 3 , 5 ) , 555 ) 加入參數名 這邊fill_value 可以傳變數名稱 也可以不傳 加入變數名稱 維護會比較容易一些 1np.full ( shape = ( 3 , 5 ) , fill_value = 555 ) 傳入的這兩個值 可以交換 1np.full ( fill_value = 555 , shape = ( 3 , 5 ) ) 結果array([[555, 555, 555, 555, 555],[555, 555, 555, 555, 555],[555, 555, 555, 555, 555]]) arange用生成表達式的方式建立 第一個參數=起始點 第二個參數=中止點 第三個參數=補償(不填默認唯1)結果不包刮20 python 的range 是不可以傳浮點數的 1[i for i in range (0 , 20 , 2) ] 結果[0, 2, 4, 6, 8, 10, 12, 14, 16, 18] numpy 的arange 可以傳浮點數 第三個參數=補償 (預設值也是1) 1np.arange(0, 1 , 0.2) 結果array([0. , 0.2, 0.4, 0.6, 0.8]) 只傳一個參數的話 起始值預設 是0 1np.arange(10 ) 結果array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) linspace參數與arange 一樣 第三個值不是補償( 這邊是0 - 20 的區間裡等長的擷出10個點 這邊10個點是包含 0 和20 )0 是起始點 20是終止點 中間8個值 與起始點 終止點 形成等差數列 他們的間距是相等的 1np.linspace( 0 , 20 ,10 ) 結果array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889,11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 如果要以2為補償使用linspace的話 1np.linspace( 0 , 20 ,11 ) 結果array([ 0., 2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]) random生成0 - 9的隨機數(區間是0-10 但這隨機數是取不到10的) 1np.random.randint( 0 , 10 ) 結果9 生成 0 - 9 隨機數的向量 1np.random.randint( 0 , 10 , 10) 結果array([9, 0, 9, 8, 2, 5, 7, 8, 4, 3]) 生成 0 - 9 隨機數二維矩陣(第三個參數 可以給他一個名稱會比較好閱讀)) 1np.random.randint( 0 , 10 , size = (3 , 5 )) 結果array([[8, 0, 3, 0, 1],[7, 6, 4, 6, 8],[7, 1, 3, 1, 2]]) 讓隨機數產生一致如果機器學習算法中要驗證這些隨機的向量 或是隨機的矩陣但是每次取的值都是不一致的 這會沒辦法驗證隨機數通常都是偉隨機數 都會有一個key 12np.random.seed(500)np.random.randint( 0 , 10 , size = (3 , 5 )) 這樣子生成 生成的都會是一致的結果array([[7, 1, 1, 8, 7],[1, 1, 5, 9, 2],[2, 3, 6, 8, 7]]) 生成隨機的浮點數 (是在0 - 1 之間分布的值)如果不輸入值 默認會產生一個 1np.random.random(10) 結果array([0.31647204, 0.36173317, 0.45072243, 0.91526806, 0.45995858,0.27367946, 0.91749612, 0.45953222, 0.54459121, 0.69069037]) 也可以生成一個二維0 - 1 之間的隨機浮點數 1np.random.random((3 ,5)) 結果array([[0.83083808, 0.63590931, 0.64981717, 0.95375833, 0.56995437],[0.6352015 , 0.03646224, 0.74912676, 0.85806843, 0.48540734],[0.23216177, 0.50338804, 0.13613189, 0.1730703 , 0.10495834]]) 產生符合正態分佈的浮點數 符合均值為0 方差為1分佈的隨機浮點數 1np.random.normal() 結果0.7543888054016835 指定 均值 方差(指定均值為10 方差為100 分佈的隨機數) 1np.random.normal(10 , 100) 結果114.58354338987674 也可以指定他的大小(均值為0 方差為1 3*5的隨機矩陣) 1np.random.normal(0 , 1 , (3 ,5 )) 結果array([[-0.23283302, 0.20643376, 0.3993155 , 1.46962845, -0.86042417],[ 0.90035145, -0.34036856, 0.59739536, -0.40102587, -1.59174938],[-0.56669195, 0.33081722, 0.58673318, 0.18174824, 0.87216409]]) Numpy.array 基本操作 import numpy as np 先建立一個一維的數組 與二維數組 接下來會使用到 12x = np.arange(10)x 結果array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 二維數組 12X = np.arange(15).reshape(3 , 5)X 結果array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) ###基本屬性### 查看幾維的數組 1x.ndim 結果1 1X.ndim 結果2 shape 返回是一個原組 1x.shape 結果(10,) 1X.shape 結果(3, 5) size 元素個數 1x.size 結果10 1X.size 結果15 ###Unmpy.array資料訪問### x 值 = array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])X 值 = array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 1x[0] 結果0 1x[-1] 結果9 python 寫法 1X[0][0] 結果0 建議使用Numpy的方式 後面會到為什麼 1X[2,2] 結果12 使用欺騙方法 從0開始一直到5不包含5 1x[0:5] 結果array([0, 1, 2, 3, 4]) 如果:前面不輸入值的話 就是從頭一直訪問到第5元素 1x[:5] 結果array([0, 1, 2, 3, 4]) 如果:後面不輸入值得話 就是從第5個元素訪問到最後 1x[5:] 結果array([0, 1, 2, 3, 4]) 可傳入第三個參數 第三個參數=補償 如果前面兩個不填寫就是從頭訪問到尾 每次補償為2 1x[::2] 結果array([0, 2, 4, 6, 8]) 補償也可以傳入-1 代表從倒數的訪問方式 1x[::-1] 結果array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) X 值 = array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 如果想要得到前兩行的前三列 1X[:2, :3] 結果array([[0, 1, 2], [5, 6, 7]]) 如果使用python 的兩個[]來取值的話來看一下會發生什麼事 1X[:2][:3] 結果array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 1X[:2] 結果array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) [:2]結果與 [:2][:3] 一樣的[:2]代表取X這個數組的前兩個元素 也就是前兩行的內容[:2][:3]這邊的[:3] python 在解析的時候是取array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])的前三元素 但這個數組裡面只有兩個元素最終的結果依然是這兩個元素[][]來搜尋數組的時候會沒辦法表達我們的語意的情況 所以真正表達取 前兩行的前三列的話 必須使用[:2,:3]使用Numpy的話 一維數組 也盡量使用[2,2]這種表達式 訪問前兩行 每一行從頭到尾 但是間隔為2數組 1X[:2 , ::2] 結果array([[0, 2, 4], [5, 7, 9]]) 訪問行從最後一行到第一行 到著數 列也是從最後一列到著數 1X[::-1,::-1] 結果array([[14, 13, 12, 11, 10], [ 9, 8, 7, 6, 5], [ 4, 3, 2, 1, 0]]) 矩陣降維處理 只取第一行 1X[0] 結果array([0, 1, 2, 3, 4]) 也可以用二維的表達方式 1X[0,:] 結果array([0, 1, 2, 3, 4]) 這樣會變成一維的向量 1X[0,:].ndim 結果1 要取一列的話 :代表取全部的行 列的維度上只取0 只看第一列 1X[: , 0 ] 結果array([ 0, 5, 10]) 這樣得到也是一維的數組 1X[: , 0].ndim 結果1 子矩陣 12subX = X[:2, :3]subX 結果array([[0, 1, 2], [5, 6, 7]]) 如果將subX 將其中的值修改 12subX[0 , 0 ] = 100subX 結果array([[100, 1, 2], [ 5, 6, 7]]) 但X原矩陣 有沒有被改變?在python 使用這種方式 是建立一個新的矩陣subX 與 原本的X 是沒有關係的但是在Numpy不是這樣的在Numpy為了效率的關係 所以他會影響到原矩陣如果修改原矩陣的元素 subX子矩陣也會跟著更改 1X 結果array([[100, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [ 10, 11, 12, 13, 14]]) COPY要用Numpy建立一個 與子矩陣沒關係的元素的話 要使用.copy 12subX = X[:2 , :3].copy()subX 結果array([[100, 1, 2], [ 5, 6, 7]]) subX 0 0 修改值 12subX [0,0 ] = 0subX 結果array([[0, 1, 2], [5, 6, 7]]) 1X 結果array([[100, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [ 10, 11, 12, 13, 14]]) ###Reshape ### x 值 = array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 如果要將這10個值 變成2 * 5的矩陣 1x.reshape(2,5) 結果 array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) ####使用reshape 是沒有改變x 本身的#### 1x 結果array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 如果要將改變的存起來的話 需要給他新的值 12A = x.reshape(2,5)A 結果array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 如果要將 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 變成二維數組 12B =x.reshape(1,10)B 結果 是有兩個[][]array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]) 1B.ndim 結果2 1B.shape 結果(1 , 10) 如果想要10行 有多少 不管列有多少 1x.reshape(10 , -1) 結果array([[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]) 也可以 我想要有5列 不管它有多少行 1x.reshape(-1 , 5) 結果array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 合併操作如果只需要合併兩個的話也可以傳兩個進去就好 123456import numpy as npx = np.array([1 , 2 , 3])y = np.array([3 , 2 , 1 ])z = np.array([555, 555, 55])np.concatenate([x , y , z]) 結果array([ 1, 2, 3, 3, 2, 1, 555, 555, 55]) 二維矩陣也可以合併 123A = np.array([[ 1 , 2 ,3], [4 , 5 ,6]])np.concatenate([A , A]) 結果array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]]) 沿著列的方向合併 1np.concatenate([A , A] , axis = 1) 結果array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) 二維與一維合併 1np.concatenate([ A , z.reshape(1, -1)]) 結果array([[ 1, 2, 3], [ 4, 5, 6], [555, 555, 55]]) 這樣A還是原來的值 1A 結果array([[1, 2, 3], [4, 5, 6]]) 如果想要保存起來需要賦上一個新的值 12A2 = np.concatenate([ A , z.reshape(1, -1)])A2 結果array([[ 1, 2, 3], [ 4, 5, 6], [555, 555, 55]]) 如果使用concatenate 又要加上reshape 覺得太麻煩的話可以使用vstack 可以直接二維與一維合併 12345678910111213np.vstack([ A , z])``` &gt;結果array([[ 1, 2, 3], [ 4, 5, 6], [555, 555, 55]])####有vstack 也有hstack水平方向####```pythonB = np.full(( 2 , 2 ) , 100)B 結果array([[100, 100], [100, 100]]) 1np.hstack([ A , B]) 結果array([[ 1, 2, 3, 100, 100], [ 4, 5, 6, 100, 100]]) 分割12x = np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) split 傳入兩個參數 (切割三段)第一個參數分割的數組第二個參數分割點 1x1 , x2 ,x3 =np.split(x, [ 3 , 7 ]) x1 0-3 不包含3 array([0, 1, 2])x2 3 , 7 中間的內容array([3, 4, 5, 6])X3 7到結尾的內容array([7, 8, 9]) ####split (切割兩段)#### 1x2 ,x3 =np.split(x, [ 5]) x2 array([0, 1, 2, 3, 4]) x3 array([5, 6, 7, 8, 9]) 二維 1A = np.arange(16).reshape(( 4 , 4 )) 結果array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 分成兩部分 1A1 , A2 = np.split(A , [2] ) A1 array([[0, 1, 2, 3], [4, 5, 6, 7]]) A2 array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) ####列的方向分割 axis 默認=0#### 1A1 , A2 = np.split(A , [2] , axis = 1) A1 array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]) A2 array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]) ####也可用vsplit 垂直方向分割#### A垂直的方向 以2這個點作為分割點 進行分割 1upper , lower = np.vsplit(A , [2]) upper array([[0, 1, 2, 3], [4, 5, 6, 7]]) lower array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) hvsplit 水平方向分割1left , right = np.hsplit(A , [2]) left array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]) right array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]) 如果前面三個代表三個特徵 最後一個代表目標值將特徵矩陣 與目標值向量 分割 12data = np .arange(16).reshape((4 , 4 ))data array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1x , y =np.hsplit(data , [-1]) x array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]) y array([[ 3], [ 7], [11], [15]]) 很多時候希望目標值 是個向量 1y[ : , 0 ] array([ 3, 7, 11, 15])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Labview將自動化機台資料傳出來使用Socket]]></title>
      <url>%2F2018%2F02%2F05%2FLabviewSocket%2F</url>
      <content type="text"><![CDATA[很多時候需要將設備的數據儲存起來 或是需要設備的資料可視化花點時間學了LabView 使用NI的IOBOX將設備的資料 傳入到自己寫的java Socket Labview labView 使用DAQ 將資料使用Tcpip 的方式 傳到對應的位置上皆可可參考下圖 由於LabView 好像沒辦法傳送JSON格式 這邊使用,區分剛學習 如果LabView 有更好的方式 也請留言或寫信告訴我 謝謝!! 實際運行效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android使用懸浮窗體製作腳本]]></title>
      <url>%2F2018%2F01%2F06%2Fandroid%E4%BD%BF%E7%94%A8%E6%87%B8%E6%B5%AE%E7%AA%97%E9%AB%94%E8%A3%BD%E4%BD%9C%E8%85%B3%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[有時候玩遊戲 或是需要一直持續重複動作的事情太浪費時間了 所以做了一個腳本使用ADB來讓他自動完成一些事情 畫面 實際RUN的過程就不演示了 也可將UI顯示成多個格子來顯示距離 來計算每個距離需要點擊多久前陣子微信的小遊戲跳一跳 也可以用這方法來實現 來得到滿分 中國手機有些廠家也有使用懸浮窗體的方式結合OCR 來將圖像辨識 選擇區域後會將文字大爆炸顯示出來讓你複製等等之類的功能 實現思路 這邊只說明其中一部分 顏色辨識的部分 如果要辨識許多文字 或是數字可以考慮先學習一份ocr用學習的來辨識會比較好一些 1234567891011121314151617181920212223242526//讀取畫面的座標點 的RGB數值 將R G B 分開讀出的值 減掉允許的+-誤差值 來確定是否當前是你要的畫面//確定後 在使用ADB來去做你要做的事情 類似代碼如下pixel=bitmap.getPixel(GameColorUtils.getDialog_checkbtntwo()[0],GameColorUtils.getDialog_checkbtntwo()[1]); if ((GameColorUtils.getColors()[3][0] - Color.red(pixel) &gt;= GameColorUtils.getAx()[1][0] &amp;&amp; GameColorUtils.getColors()[3][0] - Color.red(pixel) &lt;= GameColorUtils.getAx()[0][0]) &amp;&amp; (GameColorUtils.getColors()[3][1] - Color.green(pixel) &gt;= GameColorUtils.getAx()[1][1] &amp;&amp; GameColorUtils.getColors()[3][1] - Color.green(pixel) &lt;= GameColorUtils.getAx()[0][1])&amp;&amp; (GameColorUtils.getColors()[3][2] - Color.blue(pixel) &gt;= GameColorUtils.getAx()[1][2] &amp;&amp; GameColorUtils.getColors()[3][2] - Color.blue(pixel) &lt;= GameColorUtils.getAx()[0][2])) &#123; CommandResult result = Shell.SU.run("input tap 695 515"); Log.i("PalyGame", " sleep 5 ms"); return 400; &#125;//畫面座標值static int[][] colors = &#123; &#123;152, 117, 60&#125;,//廣告 &#123;255, 240, 214&#125;, // 主畫面&#125;;// 允許的誤差static int[][] ax = &#123; &#123;10, 10, 10&#125;, &#123;-10, -10, -10&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vaadin 響應式即時看板]]></title>
      <url>%2F2017%2F12%2F05%2Fvaadin-%E9%9F%BF%E6%87%89%E5%BC%8F%E5%8D%B3%E6%99%82%E7%9C%8B%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[撈取公司MES的生產資料 將資料圖表化 顯示即時看板要花時間想前端又要做後端 好累阿…… 網頁端 手機端 這邊CSS使用 width-range 來去監聽寬度的變化 來去改變 panel的 width height 12345678910111213141516171819202122232425262728.responsive &#123; &amp;[width-range~="0-300px"] &#123; .panel&#123; margin-top:10px; width: 100%!important; height: 100%; &#125; &#125; &amp;[width-range~="301-800px"] &#123; .panel&#123; margin-top:10px; width: 100%!important; height: 100%; &#125; &#125; &amp;[width-range~="801px-"] &#123; .panel&#123; margin-top:10px; margin-left:10px; width: 49%!important; height: 330px; &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python使用sklearn進行資料預處理(學習筆記)]]></title>
      <url>%2F2017%2F11%2F05%2Fpython%E4%BD%BF%E7%94%A8sklearn%E9%80%B2%E8%A1%8C%E8%B3%87%E6%96%99%E9%A0%90%E8%99%95%E7%90%86(%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98)%2F</url>
      <content type="text"><![CDATA[處理大量原始資料。機器學習算法期望數據在開始訓練過程之前以某種方式被格式化。為了準備機器學習算法攝取的數據，必須對其進行預處理並將其轉換為正確的格式 導入的包123import numpy as npfrom sklearn import preprocessing 測試資料1234input_data = np.array([[5.1, -2.9, 3.3], [-1.2, 7.8, -6.1], [3.9, 0.4, 2.1], [7.3, -9.9, -4.5]]) 二值化 當如果想要將數值轉換成布林值的時候，可以使用這個方法如果&gt;2.1的話 1 否則 0 123data_binarized = preprocessing.Binarizer(threshold=2.1).transform(input_data)print(data_binarized) 輸出結果1234[[ 1. 0. 1.][ 0. 1. 0.][ 1. 0. 0.][ 1. 0. 0.]] 矩陣平均值去除平均值是機器學習中常用的預處理技術。從我們的特徵向量中去除均值通常是有用的，因此每個特徵都以零為中心。 123456#mean() 计算矩阵均值 axis=0 每一列print("\nBEFORE:")print("Mean =", input_data.mean(axis=0))#std 計算 矩陣標準差print("Std deviation =", input_data.std(axis=0)) 輸出結果123BEFORE:Mean = [ 3.775 -1.15 -1.3 ]Std deviation = [ 3.12039661 6.36651396 4.0620192 ] 去除均值12345data_scaled = preprocessing.scale(input_data)print("\nAFTER:")print("Mean =", data_scaled.mean(axis=0))print("Std deviation =", data_scaled.std(axis=0)) 輸出結果123AFTER:Mean = [ 1.11022302e-16 0.00000000e+00 2.77555756e-17]Std deviation = [ 1. 1. 1.] 缩放 在特徵向量中，每個特徵的值可以在許多隨機值之間變化。因此，擴展這些特徵變得非常重要，這樣對於機器學習算法來說，這是一個公平的競爭環境。僅僅因為測量的性質 1234#將屬性縮放到一個指定的範圍data_scaler_minmax = preprocessing.MinMaxScaler(feature_range=(0, 1))data_scaled_minmax = data_scaler_minmax.fit_transform(input_data)print("\nMin max scaled data:\n", data_scaled_minmax) 輸出結果12345Min max scaled data: [[ 0.74117647 0.39548023 1. ] [ 0. 1. 0. ] [ 0.6 0.5819209 0.87234043] [ 1. 0. 0.17021277]] 每行被縮放，最大值是1所有其他值是相對於這個值。 正規化 正規化指的是最小絕對偏差，通過確保絕對值之和在每一行中為1來工作。L2 歸一化，指的是最小二乘法，確保平方和為1。 1234data_normalized_l1 = preprocessing.normalize(input_data, norm='l1')data_normalized_l2 = preprocessing.normalize(input_data, norm='l2')print("\nL1 normalized data:\n", data_normalized_l1)print("\nL2 normalized data:\n", data_normalized_l2) 輸出結果12345678910L1 normalized data: [[ 0.45132743 -0.25663717 0.2920354 ] [ -0.0794702 0.51655629 -0.40397351] [ 0.609375 0.0625 0.328125 ] [ 0.33640553 -0.4562212 -0.20737327]]L2 normalized data: [[ 0.75765788 -0.43082507 0.49024922] [ -0.12030718 0.78199664 -0.61156148] [ 0.87690281 0.08993875 0.47217844] [ 0.55734935 -0.75585734 -0.34357152]] 參考資料sklearnnumpy axis概念整理筆記numpy.std() 計算矩陣標準差]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Deeplearning4j(DL4J)使用Word2Vec 讓機器學習WIKI]]></title>
      <url>%2F2017%2F11%2F01%2FDeeplearning4j-DL4J-%E4%BD%BF%E7%94%A8Word2Vec-%E8%AE%93%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92WIKI%2F</url>
      <content type="text"><![CDATA[word2vec 是基於非監督式學習，訓練集一定一定要越大越好，語料涵蓋的越全面，訓練出來的結果也會越漂亮，本篇所採用的是維基百科的備份， 取得資料維基百科備份下載我這邊下載的是 zhwiki-20171001-pages-meta-current.xml.bz2解壓縮後zhwiki-20171001-pages-meta-current.xml 處理XML我是使用Ruby來處理XMLGithub使用 $ wp2txt --input-file zhwiki-20171001-pages-meta.xml 這樣會將wiki xml分割成許多的txt像是這樣如果你不想要訓練太多，想測試一下，可以將他分割的一部分給機器訓練就好了比較不會花太久時間訓練他將分割的txt合併請輸入$ cat zhwiki-20171001-pages-meta-* | grep -v &#39;^\s*$&#39; &gt; zhwiki-corpus.txt跑完後應該會像這樣內容會是這樣 自然語言分詞簡體要轉繁體 「不然数学」與「數學」會被 word2vec 當成兩個不同的詞簡轉繁可以使用 OpenCC 這速度很快分詞我這邊是使用HanLP也可以使用 StanfordNlp就看個人喜好與實作效率來決定使用哪一個就好了分詞完資料像這樣 DL4J訓練 訓練完畢保存這邊訓練的文件使用剛剛分割完的001其中一個Txt目前使用CPU學習的話學習整個wiki 我的電腦要學習兩天 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Word2VecCmd &#123; private static Logger log = LoggerFactory.getLogger(Word2VecRawTextExample.class); public static void main(final String[] args) throws Exception &#123; log.info("Load data...."); SentenceIterator iter = new LineSentenceIterator(new File("D:\\wp2txt-master\\wiki\\001.txt")); iter.setPreProcessor(new SentencePreProcessor() &#123; @Override public String preProcess(String sentence) &#123; return sentence.toLowerCase(); &#125; &#125;); TokenizerFactory t = new DefaultTokenizerFactory(); t.setTokenPreProcessor(new CommonPreprocessor()); log.info("Build model..."); int batchSize = 1000; int iterations = 5; int layerSize = 150; Word2Vec vec = new Word2Vec.Builder() .batchSize(batchSize) .minWordFrequency(5) .useAdaGrad(false) .layerSize(layerSize) .iterations(iterations) .seed(7485) .windowSize(5) .learningRate(0.025) .minLearningRate(1e-3) .negativeSample(10) .iterate(iter) .tokenizerFactory(t) .workers(6) .build(); log.info("Fitting Word2Vec model...."); vec.fit(); WordVectorSerializer.writeWordVectors(vec, "pathToWriteto.txt"); log.info("Closest Words:"); Collection&lt;String&gt; lst = vec.wordsNearest("數學", 3); System.out.println(lst); double lst1 = vec.similarity("數學", "物理"); System.out.println(lst1); log.info("Save......."); WordVectorSerializer.writeWordVectors(vec, "D:\\wordvectors.txt"); &#125;&#125; 輸出結果 訓練讀取123456789101112131415161718public class Word2VecPredictCmd &#123; public static void main (final String[] args) throws Exception &#123; WordVectors vec = WordVectorSerializer.loadTxtVectors(new File("D:\\wordvectors.txt")); String[] names = &#123;"數學"&#125;; for(String name:names) &#123; System.out.println(name+"&gt;&gt;&gt;&gt;&gt;&gt;"); Collection&lt;String&gt; lst = vec.wordsNearest(name, 5); System.out.println(lst); double lst1 = vec.similarity("數學", "物理"); System.out.println(lst1); &#125; &#125;&#125; 輸出結果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android-Handler Message]]></title>
      <url>%2F2017%2F10%2F02%2Fandroid-HandlerMessage%2F</url>
      <content type="text"><![CDATA[網路抓取圖片，或是讀很大量的資料，如果在主執行緒中超過五秒還沒完成的話會收到android系統的錯誤強制關閉，這時候需要把這些耗時的工作放在一個子執行續上因為子執行緒涉及到UI更新，為了避免避免多個子執行緒去更新發生錯誤為了避免這種錯誤，更新UI只能在主執行緒更新由於Handler運行在主執行緒中(UI執行緒中)，它與子執行緒可以通過Message對象來傳遞資料， 最近比較常用到順便紀錄一下!! 注意 如果要使用要在Handler使用startActivity的話因為上下文的關係 要注意Context 123 static Context mContext;Intent intent = new Intent(mContext, InferenceActivity.class);mContext.startActivity(intent); Handler 範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends AppCompatActivity &#123; @InjectView(R.id.btn_update) Button mBtnUpdate; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main_); ButterKnife.inject(this); &#125; @OnClick(&#123;R.id.btn_update&#125;) public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.btn_update: Login(); break; &#125; &#125; private void Login() &#123; Runnable run = new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = 1000; &#125; mHandler.sendMessage(msg); &#125; &#125;; new Thread(run).start(); &#125; Handler mHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case 1000: break; case 1001: break; &#125; &#125; &#125;;&#125; Handler 範例二MainActivity123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; @InjectView(R.id.btn_start) Button mBtnStart; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main_); ButterKnife.inject(this); &#125; @OnClick(R.id.btn_start) public void onClick(View view) &#123; DateUpdate dateUpdate = new DateUpdate(); &#125; public Handler getHandler() &#123; return this.mHandler; &#125; Handler mHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case 1000: //程式碼 break; case 1001: //程式碼 break; &#125; &#125; &#125;;&#125; DateUpdate123456789101112131415161718192021222324252627public class DateUpdate &#123; public DateUpdate() &#123; Runnable run = new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); if () &#123; msg.what = 1000; &#125; else &#123; msg.what = 1001; &#125; &#125; mHandler.sendMessage(msg); &#125; &#125;; new Thread(run).start(); &#125; StartSuccessActivity startSuccessActivity = new StartSuccessActivity(); Handler mHandler = startSuccessActivity.getHandler();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android AsyncTask(轉)]]></title>
      <url>%2F2017%2F10%2F01%2Fandroid-AsyncTask-%E8%BD%89%2F</url>
      <content type="text"><![CDATA[AsyncTask非同步任務，或稱異步任務，是一個相當常用的類別，是專門用來處理背景任務與UI的類別。Android 4.0 之後，有明文規定所有的網路行為都不能在主執行緒(Main Thread)執行，主執行緒又稱UI執行緒(UI Thread)，任何有關UI的東西都在主執行緒中執行，若是你的程式佔據主執行緒很久，使用者體驗會非常的差。 AsyncTask 想像一下，按了一個按鈕後，整個App停住五秒會是怎樣的感覺，因此許多耗時的程式建議寫在背景執行，而其中最常見的就是網路的功能。在此先介紹一下有關ANR(Application Not Responding)的問題，也就是應用程式沒有回應。你可以試著加入一個Button，在onClick事件裡面做一件很花時間的事情。 123456789button = (Button)findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; for(int i = 0 ; i &lt; 10000000 ; i++)&#123; Log.d("Tag = " , "HI"); &#125; &#125; &#125;); 跑了一個很大的迴圈，過一下子你的手機會跑出這個警告。 這就是典型的ANR，因為onClick事件是在主執行緒，你佔據主執行緒太久的時間，因此跳出了這個警告，若是按下確定就會關閉你的程式。要怎麼知道我是不是在主執行緒呢，你可以用以下的程式碼來判斷。Thread.currentThread().getId()`` 像是你在onClick裡面加入這個Log，Log.d(“onClick = “ , String.valueOf(Thread.currentThread().getId()));` 然後試著印出來，你會發現他會寫1，1就是主執行緒的ID，也是UI Thread。 這樣你大概了解其中一種會產生ANR的問題。 接下來來談談AsyncTask的用法吧，這次舉的例子是從網路下載圖片。 你可能會想，只是下載一張小圖片應該不會花費太久時間，那我寫在主執行緒就好了。 然後就在onClick`裡面寫了以下的程式碼。12345678910try &#123; URL url = new URL("http://i.imgur.com/Uki7N9T.jpg"); //取得圖片的URL Bitmap bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream()); //透過BitmapFactory來下載URL的圖片 imageView.setImageBitmap(bitmap); //設置圖片到ImageView之中&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 透過BitmapFactory來下載圖片，在使用Try Catch來捕捉一些可能的例外，看起來滿正確的，但是實際執行會發現有一個例外。 android.os.NetworkOnMainThreadException 意思是，你不能在主執行緒做網路的事情，還是乖乖用AsyncTask吧XD AsyncTask&lt;Params, Progress, Result&gt;，這是基本的架構，使用泛型來定義參數，泛型意思是，你可以定義任意的資料型態給他。 Params ： 參數，你要餵什麼樣的參數給它。 Progress ： 進度條，進度條的資料型態要用哪種 Result ： 結果，你希望這個背景任務最後會有什麼樣的結果回傳給你。 此外，AsyncTask會有四個步驟。 onPreExecute ： 執行前，一些基本設定可以在這邊做。 doInBackground ： 執行中，在背景做任務。 onProgressUpdate ： 執行中，當你呼叫publishProgress的時候會到這邊，可以告知使用者進度。 onPostExecute ： 執行後，最後的結果會在這邊。 拿下載圖片的例子來寫，繼承AsyncTask，並實作四個步驟， 參數說明 ： 丟入網址(String)，進度條用整數(Integer)，拿到圖片(Bitmap) 1234567891011121314151617181920212223242526private class GetImage extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123; @Override protected void onPreExecute() &#123; //執行前 設定可以在這邊設定 super.onPreExecute(); &#125; @Override protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //執行中 可以在這邊告知使用者進度 super.onProgressUpdate(values); &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; //執行後 完成背景任務 super.onPostExecute(bitmap); &#125; &#125; 這邊你可能不明白String...是什麼意思，這東西的意思是你可以傳單一一個String，或者是一個String陣列都可以。 假如你丟一個String進去，你只要取得第一個元素即可。 String urlStr = params[0]; 接著在把剛才下載圖片的程式改寫到doInBackground之中。 123456789101112protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 String urlStr = params[0]; try &#123; URL url = new URL(urlStr); Bitmap bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream()); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 如此一來，你就會在背景下載圖片，當沒有例外的時候就會回傳。 此時，你可能會想，那我不要等回傳，我直接在doInBackground去改我的圖片就好了。 12345678910111213protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 String urlStr = params[0]; try &#123; URL url = new URL(urlStr); Bitmap bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream()); imageView.setImageBitmap(bitmap); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 這時候會跳出一個例外： Only the original thread that created a view hierarchy can touch its views. 意思是，你只能在UI Thread去修改UI，因為你現在是在背景，因此你必須回到UI Thread才能對UI做事情，很勤勞的跑去Google找解，最後你的程式碼可能變成這樣。 123456789101112131415161718192021private Bitmap bitmap; @Override protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 String urlStr = params[0]; try &#123; URL url = new URL(urlStr); bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream()); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageView.setImageBitmap(bitmap); &#125; &#125;); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 事實上，這樣是可以運作沒錯，但是有點太多此一舉。 主執行緒沒辦法用網路 -&gt; 用背景執行 -&gt; 背景執行沒辦法改UI -&gt; 在回去主執行緒。 我們有提到，AsyncTask有四個步驟，我們試著將這四個步驟的執行緒ID都印出來。 1234567891011121314151617181920212223242526272829303132private class GetImage extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123; @Override protected void onPreExecute() &#123; //執行前 設定可以在這邊設定 super.onPreExecute(); Log.d("Tag onPreExecute" , String.valueOf(Thread.currentThread().getId())); &#125; @Override protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 Log.d("Tag doInBackground" , String.valueOf(Thread.currentThread().getId())); publishProgress(100); return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //執行中 可以在這邊告知使用者進度 super.onProgressUpdate(values); Log.d("Tag onProgressUpdate", String.valueOf(Thread.currentThread().getId())); &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; //執行後 完成背景任務 super.onPostExecute(bitmap); Log.d("Tag onPostExecute", String.valueOf(Thread.currentThread().getId())); &#125; &#125; 除了背景任務以外都回到主執行緒了，因此你可以在結果的部分在對UI做修改，不用特定在背景那邊在呼叫回主執行緒，這樣太多此一舉了。 如此一來基本的認識應該有了，這裏提供兩個範例。 ##範例## 傳入一個網址 1.傳入一個網址，下載網路圖片後顯示在ImageView之中 123456789101112131415161718192021222324252627282930313233343536private class GetImage extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123; @Override protected void onPreExecute() &#123; //執行前 設定可以在這邊設定 super.onPreExecute(); &#125; @Override protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 String urlStr = params[0]; try &#123; URL url = new URL(urlStr); return BitmapFactory.decodeStream(url.openConnection().getInputStream()); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //執行中 可以在這邊告知使用者進度 super.onProgressUpdate(values); &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; //執行後 完成背景任務 super.onPostExecute(bitmap); imageView.setImageBitmap(bitmap); &#125; &#125; 執行背景程式的方法1new GetImage().execute("http://i.imgur.com/Uki7N9T.jpg"); 實作進度條的功能 模擬下載三張圖，可是下載完後沒有回傳圖片回去，這個例子是說明怎麼使用進度條。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private class GetImage extends AsyncTask&lt;String , Integer , Bitmap&gt;&#123; private ProgressDialog progressBar; //進度條元件 @Override protected void onPreExecute() &#123; //執行前 設定可以在這邊設定 super.onPreExecute(); progressBar = new ProgressDialog(MainActivity.this); progressBar.setMessage("Loading..."); progressBar.setCancelable(false); progressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); progressBar.show(); //初始化進度條並設定樣式及顯示的資訊。 &#125; @Override protected Bitmap doInBackground(String... params) &#123; //執行中 在背景做事情 int progress = 0; for (String urlStr : params) &#123; try &#123; URL url = new URL(urlStr); Bitmap bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; publishProgress(progress+=33); //有三張圖 每張圖33% &#125; publishProgress(100); //最後達到100% return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; //執行中 可以在這邊告知使用者進度 super.onProgressUpdate(values); progressBar.setProgress(values[0]); //取得更新的進度 &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; //執行後 完成背景任務 super.onPostExecute(bitmap); progressBar.dismiss(); //當完成的時候，把進度條消失 imageView.setImageBitmap(bitmap); &#125; &#125; 當你呼叫publishProgress時，丟入一個值，會到onProgressUpdate之中，在這邊更新進度條的進度。 當完成之時，在呼叫dismiss將進度條除去。 看完這篇文章你應該對AsyncTask有一些基本的認識了。 文章轉自]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-OEE]]></title>
      <url>%2F2017%2F09%2F23%2FAndroid-OEE%2F</url>
      <content type="text"><![CDATA[工廠24H生產,每個生產設備要確實的自己的產能預估產能,與每日實際產能的落差紀錄產品良率/不良率,流水號追朔不良率產品,了解當下生產相關資訊業務去接單的時候,有著生產資料準確的產能來與客戶溝通,也可以改善工廠的生產效率。 前言 這篇就只介紹APP部分電腦端程式就不說明了 介面 ICON怎們看都怪怪的，好多ICON找不到好看的，就空著不放了等哪天比較有空再來好好找找 流程 工廠辦公室的人會將要生產的料號與生產的模具等等的資料輸入電腦端的程式 每個模具每日的產能都不一樣，這會在下班的時候來去計算預估生產值，與實際生產值 電腦端程式可以看到每日報表，當前生產狀況。 手機點擊，電腦標籤列印等比較有空的時候在整理新增上來 工廠端在電腦端的程式輸入&gt;OP每天上班點擊平板上要生產的料號&gt;每一樣產品正常或不良都需點擊平版記錄&gt;QC檢驗也會在電腦端輸入檢驗成果與流水號]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ButtonShape]]></title>
      <url>%2F2017%2F09%2F19%2FButtonShape%2F</url>
      <content type="text"><![CDATA[Android的Button預設樣式真的很難看，如果要修改樣式必須寫一個XML來改寫,只是要改變外觀只需要用shape但如果要有點擊效果的話 要使用selector。 btn.xml 請新增在drawable下貼xml程式碼 部落格一直會報錯 就先貼圖片找時間在來找找問題在哪 Button在Button 下增加1android:background="@drawable/btn" 這樣就可以點擊變色了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用StateListAnimator讓Button動起來]]></title>
      <url>%2F2017%2F09%2F15%2FAndroidDesignButton%2F</url>
      <content type="text"><![CDATA[讓原件狀態改變是通過StateListAnimator動畫集來改變View的狀態的它可以使View在不同狀態下發生不同的變化 DEMO 實作StateListAnimator.xml 在drawable 下新增一個 StateListAnimator.xmlvalueTo 可以依照喜好設定大一點讓他轉動角度變大一點 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="rotationX" android:duration="@android:integer/config_shortAnimTime" android:valueTo="90" android:valueType="floatType"/&gt; &lt;/set&gt; &lt;/item&gt; &lt;item android:state_pressed="false"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="rotationX" android:duration="@android:integer/config_shortAnimTime" android:valueTo="0" android:valueType="floatType"/&gt; &lt;/set&gt; &lt;/item&gt;&lt;/selector&gt; activity_main 在你的Button下 將下面的程式碼貼上這樣點擊他就會有像Demo 第一個的效果了 1android:stateListAnimator="@drawable/StateListAnimator" 將Button改成線條 單單只有點擊動畫實在太醜了將Button美化一下 drawable 下新增一個 btn_loginsuccess.xml 可以在自己修改要的寬度高度顏色 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;corners android:radius="3dp" /&gt; &lt;stroke android:width="1dp" android:color="#03A9F4" /&gt;&lt;/shape&gt; activity_main.xml Button下將background添加剛剛新增的xml皆可 這樣就達到上面DEMO第二個的效果了 1android:background="@drawable/btn_loginsuccess"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment生命週期]]></title>
      <url>%2F2017%2F09%2F01%2FFragment%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[什麼是Fragment?Fragment片段(或稱為區塊)是Android提供的一個畫面區塊，可將Fragment放在一個Activity中 最近在使用Fragment順便記錄一下 Fragment的生命週期 Fragment Fragment不能獨立存在，必須嵌入到Activity中Fragment具有自己的生命週期，接收它自己的事件，並可以在Activity運行時被增加或刪除Fragment的生命週期直接受所在的Activity的影響。如：當Activity暫停時，它擁有的所有Fragment們都暫停Fragment從 Android 3.0後引入在低版本Android 3.0前使用 Fragment，需要採用android-support-v4.jar 生命週期 來看一下關方介紹的生命周期圖每個Fragment擁有自己的生命週期，也就是說，在特定的狀況會自動呼叫特定的方法供使用者依功能需求覆寫這些方法，加入必要的程式碼。依照Fragment產生與出現的順序會執行的方法描述如下 onAttach當Fragment被加到某個Activity畫面中時，會自動呼叫此方法。 onCreateFragment被建立時會自動呼叫此方法，可加入初始化元件或資料的程式碼。 onCreateView將在畫面中第一次顯示Fragment時會自動呼叫此方法，必須回傳Fragment畫面的View元件，設計時，請使用方法中的LayoutInflater物件，在此方法中產生畫面元件並回傳。 onActivityCreated當加入本Fragment的Activity被建立時，該Activity的onCreate方法執行完成後會自動執行此方法。執行完此方法後，Fragment才出現在畫面上。 onStart當Fragment出現在畫面中時先執行此方法。 onResume執行完onStart方法後，再自動執行本方法。完成後即在畫面中與使用者互動。 暫停階段當使用者按下返回鍵，或是程式中將Fragment自某個Activity中移除時，會自動執行以下方法： onPause進入暫停前第一個執行的方法。 onStop執行完onPause方法後，自動執行本方法。 onDestroyView此時Fragment已不在畫面中，呼叫此方法。 onDestroy當Fragment要被清除之前，會執行此方法。 onDetach與當初被加入的Activity卸載時，會自動執行此方法。 實作Fragment 為了呈現效果 增加個底色 效果 MainActivity12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FragmentManager fm = getSupportFragmentManager(); Fragment fragment = fm.findFragmentById(R.id.fragmentContainer); if (fragment == null) &#123; fragment = new MainFragment(); fm.beginTransaction() .add(R.id.fragmentContainer, fragment) .commit(); &#125; &#125;&#125; activity_main.xml1234567&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:id="@+id/fragmentContainer"android:layout_width="match_parent"android:layout_height="match_parent"tools:context=".MainActivity"&gt;&lt;/FrameLayout&gt; MainFragment1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainFragment extends Fragment &#123; public MainFragment() &#123; // Required empty public constructor &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; Logger.d("onCreate"); super.onCreate(savedInstanceState); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Logger.d("onCreateView"); return inflater.inflate(R.layout.fragment_blank, container, false); &#125; @Override public void onStart() &#123; Logger.v("onStart"); super.onStart(); &#125; @Override public void onResume() &#123; Logger.d("onResume"); super.onResume(); &#125; @Override public void onPause() &#123; Logger.d("onPause"); super.onPause(); &#125; @Override public void onStop() &#123; Logger.d("onStop"); super.onStop(); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; Logger.d("onActivityCreated"); super.onActivityCreated(savedInstanceState); &#125; @Override public void onDetach() &#123; Logger.d("onDetach"); super.onDetach(); &#125; @Override public void onDestroy() &#123; Logger.d("onDestroy"); super.onDestroy(); &#125; @Override public void onDestroyView() &#123; Logger.d("onDestroyView"); super.onDestroyView(); &#125; public void onAttach(Context context) &#123; Logger.d("onAttach"); super.onAttach(context); &#125;&#125; fragment_blank.xml1234567891011121314151617&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.dustin.fragment.MainFragment"&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#321d" android:text="@string/hello_blank_fragment" /&gt;&lt;/FrameLayout&gt; 測試觀察生命週期程式啟動 執行專案後，MainActivity將Fragment加入畫面中 , 在系統中產生物件時，執行的順序如下 onAttac onCreate onCreateView 取得View物件 執行 onActivityCreated後 Fragment即顯示在畫面中 之後執行onStart&gt; onResume 按下HOME 按下HOME鍵 執行的順序如下 與Activity的生命週期相同，先執行onPause，再執行onStop方法後，進入背景。 按下Recents 回到程式後執行順序如下 onStart onResume 按下返回鍵 按下返回鍵 順序如下 onPause onStop 應用程式消失在畫面後 執行onDestroyView onDestroy 最後執行onDetach]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-Swing-tiptop 財務報表(三)]]></title>
      <url>%2F2017%2F08%2F03%2Fjava-Swing-tiptop-%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[前言 版權聲明：轉載請保留原文連結及作者在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-Swing-tiptop 財務報表(二)]]></title>
      <url>%2F2017%2F07%2F22%2Fjava-Swing-tiptop-%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[前言 版權聲明：轉載請保留原文連結及作者在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing tiptop 財務報表(一)]]></title>
      <url>%2F2017%2F07%2F10%2Fjava%20swing%20tiptop-%E8%B2%A1%E5%8B%99%E5%A0%B1%E8%A1%A8-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[教育訓練小程式前言&gt;在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing tiptop 財務資料與別廠區資料比對 小程式]]></title>
      <url>%2F2017%2F07%2F01%2Fjava%20swing%20tiptop-%E8%B2%A1%E5%8B%99%E8%B3%87%E6%96%99%E8%88%87%E5%88%A5%E5%BB%A0%E5%8D%80%E8%B3%87%E6%96%99%E6%AF%94%E5%B0%8D-%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[教育訓練小程式前言&gt;由於財務每次都需要去tiptop很多個地方抓資料然後記錄在EXCEL與客戶提供的收發或明細核對也需要與客戶的財務 金額比對 花了非常多時間在做件事情時常人工比對 容易出錯誤就來幫忙財務 減輕一下工作量資料是這樣的內銷 訂單&gt;出通單&gt;出貨單 &gt;發票號碼&gt;金額外銷 訂單&gt;出通單&gt;invoice&gt;金額 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing -教育訓練程式(第二版)]]></title>
      <url>%2F2017%2F06%2F20%2Fjava%20swing%20-%E6%95%99%E8%82%B2%E8%A8%93%E7%B7%B4%E7%A8%8B%E5%BC%8F(%E7%AC%AC%E4%BA%8C%E7%89%88)%2F</url>
      <content type="text"><![CDATA[教育訓練小程式前言&gt;本來仿製公司舊ERP做的教育訓練程式發現實在很不好用 決定重新開發一個使用流程建立課程&gt;講師課程邀請&gt;發送mail課程邀請信&gt;講師評分 程式主畫面課程建立 課程邀請 Mail回覆是否要上課 這邊有一個server 來判斷 使用這點入 確定後 所回傳url值 來去判斷使用者 將資料寫入資料庫講師評分 課程講義上傳 由於會不知道有幾個人上課 這邊的Button 是使用checkBox來去監聽按鈕狀況]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-swing-tiptop 程式代號查詢小程式]]></title>
      <url>%2F2017%2F06%2F10%2Fjava-swing-tiptop-%E7%A8%8B%E5%BC%8F%E4%BB%A3%E8%99%9F%E6%9F%A5%E8%A9%A2%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[程式代號查詢小程式前言&gt;每次要查oracle的程式代號都要進去查又很難看實在很沒效率或是要用程式名稱來去查詢他的資料庫位置實在很浪費時間就開發這個小程式來讓自己方便查詢了 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-swt 線上人數查看器]]></title>
      <url>%2F2017%2F06%2F05%2Fjava-swt-%E7%B7%9A%E4%B8%8A%E4%BA%BA%E6%95%B8%E6%9F%A5%E7%9C%8B%E5%99%A8%2F</url>
      <content type="text"><![CDATA[程式線上人數查看器前言&gt;由於幫公司同仁開發的程式如果有在使用我就沒辦法更新 需要踢他們下限等到更新完畢後程式會自動在幫他們開啟也可以很好的看到他們使用的狀況 來知道他們使用程式的狀況 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-swing-tiptop 調撥清單]]></title>
      <url>%2F2017%2F05%2F30%2Fjava-swing-tiptop-%E8%AA%BF%E6%92%A5%E6%B8%85%E5%96%AE%2F</url>
      <content type="text"><![CDATA[調撥清單前言&gt;這個程式主要是讓庫房查詢調撥多少庫存去外面例如!pchome倉 可以方便查詢調撥多少庫存出去 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing 教育訓練小程式]]></title>
      <url>%2F2017%2F05%2F25%2Fjava-swing-tiptop%E6%95%99%E8%82%B2%E8%A8%93%E7%B7%B4%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[教育訓練小程式前言&gt;由於公司常常會有內部訓練與安排人員外部訓練課程寫這個的用意是要讓人員訓練可以做個紀錄 以便反查與訓練完畢是否可以當內部課程講師 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-swing-tiptop 採購單價查詢]]></title>
      <url>%2F2017%2F05%2F15%2Fjava-swing-tiptop-%E6%8E%A1%E8%B3%BC%E5%96%AE%E5%83%B9%E6%9F%A5%E8%A9%A2%2F</url>
      <content type="text"><![CDATA[採購單價查詢前言&gt;有時候不得不說Tiptop有些地方真的很爛走分量計價的單價查詢要一筆一筆查..如果有舊單價要看或是要看本來單價多少 現在單價多少 真的很不好查所以就幫公司開發一個方便的查詢工具 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing tiptop異動數量查詢]]></title>
      <url>%2F2017%2F05%2F08%2Fjava-swing-tiptop%E7%95%B0%E5%8B%95%E6%95%B8%E9%87%8F%E6%9F%A5%E8%A9%A2%2F</url>
      <content type="text"><![CDATA[異動數量查詢前言&gt;由於Tiptop裡面查看異動 沒有數量公司人員要反查單據與數量的時候要很多時間去查看來去找尋錯誤很浪費時間由於用4gl開發好花時間加上自己不是很熟還有其他專案時間的壓力就選擇都用java開發比較快 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BOM查詢系統小程式]]></title>
      <url>%2F2017%2F05%2F04%2Fjava-swing-tiptop%20BOM%E6%9F%A5%E8%A9%A2%E7%B3%BB%E7%B5%B1%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[BOM查詢系統小程式前言 版權聲明：轉載請保留原文連結及作者這個小程式主要用途在於讓資材key上料號把bom展出來 有替代料的點下右鍵會在下方出現替代料比較麻煩的部分是 一階BOM展開二階時候二階*上1階的數量這樣才對 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-swing tiptop出貨排程小程式]]></title>
      <url>%2F2017%2F04%2F30%2Fjava-swing-tiptop%E5%87%BA%E8%B2%A8%E6%8E%92%E7%A8%8B%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[出貨排程小程式前言&gt;幫公司開發一個內銷應收程式後就順便開發一個出貨排程給倉庫使用主要是給倉庫看出貨排程也降低他們工作的負擔 程式主畫面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java swing tiptop內銷應收小程式]]></title>
      <url>%2F2017%2F04%2F26%2Fjava-swing-tiptop%E5%85%A7%E9%8A%B7%E6%87%89%E6%94%B6%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[內銷應收小程式前言&gt;我們公司業助每個月都要用Excel來去紀錄或是去tiptop查詢單據來記錄到excle上這個月有哪些訂單出貨了 那些訂單還沒出貨那些訂單開發票了?那些訂單收到錢了?花費太多時間在這上面就決定幫牠開發一個減輕她工作負擔 程式主畫面 查詢未開立出通單的訂單 table 欄位名稱 table 欄位名稱如下結案碼訂單日期業務代號地區代碼客戶名稱客戶代碼產品規格系列機種訂單料號訂單數量幣別單價銷售額(未稅)銷售額(含稅)已出貨數量已出貨金額鼎新訂單號碼鼎新出貨通知單客戶訂單號碼週別預計出貨日發票號碼發票日期預計付款日實際收款日財務備註出貨備註總出貨數量總出貨金額 程式介紹結案碼代表這張單有沒有收到錢了資料上方式可以類似Excel的篩選功能詳細之後在演示一下效果可以依照日期或是季度來篩選資料這些資料不是一次串出來的很多部分是使用程式來去搭配達成效果的由於對sql不是非常厲害 這要從訂單串到財務的單據驗證資料是否有重複正確性這部分花比較多時間在這上面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python學習筆記]]></title>
      <url>%2F2017%2F04%2F01%2Fpython%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%2F</url>
      <content type="text"><![CDATA[python 入門前言 前陣子買了幾本python的書連續假期終於有空看了這些書發現要打個for 都還要看書看一下怎們打也常常打到最後都加上;紀錄一下一些用法與說明讓自己方便查詢花了好幾個小時終於把他打完了..程式語言邏輯上其實都是一樣的這篇對於沒學過程式語言的想學python 也是很棒的寫過程式語言的 剛踏入python 也是很有幫助的 python 官方文檔 python 變數 資料類型Python中資料類型1.整數 Python可以處理任意大小的整數，當然包括負整數，在Python程序中，整數的表示方法和數學上的寫法一模一樣，例如：1，100，-8080，0，等。計算機由於使用二進制，所以，有時候用十六進製表示整數比較方便，十六進制用0x前綴和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 12print(0xff00)print(0xa5b4c3d2) 結果652802780087250 2.浮點數 浮點數也就是小數，之所以稱為浮點數，是因為按照科學記數法表示時，一個浮點數的小數點位置是可變的，比如，1.23x10^9和12.3x10^8是相等的。浮點數可以用數學寫法，如1.23，3.14，-9.01，等等。但是對於很大或很小的浮點數，就必須用科學計數法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以寫成1.2e-5，等等。整數和浮點數在計算機內部存儲的方式是不同的，整數運算永遠是精確的（除法難道也是精確的？是的！），而浮點數運算則可能會有四捨五入的誤差。 3.字串 字串是以&#39;&#39;或&quot;&quot;括起來的任意，比如&#39;abc&#39;，&quot;xyz&quot;等等。請注意，’’或””本身只是一種表示方式，不是字串的一部分，因此，字串’abc’只有a，b，c這3個字符。 4.布林值 布林值和布爾代數的表示完全一致，一個布林值只有True、False兩種值，True，False，在Python中，可以直接用True、False表示布林值（請注意大小寫），也可以通過布爾運算計算出來。布林值可以用and、or和not運算。and運算是與運算，只有所有都為 True，and運算結果才是 True。or運算是或運算，只要其中有一個為 True，or 運算結果就是 True。not運算是非運算，它是一個單目運算符，把 True 變成 False，False 變成 True。 5.空值 空值是Python裡一個特殊的值，用None表示。 None不能理解為0，因為0是有意義的，而None是一個特殊的空值。此外，Python還提供了列表、字典等多種數據類型，還允許創建自定義數據類型， python printprint print語句也可以跟上多個字串，用逗號“,”隔開，就可以連成一串輸出：1print ('The quick brown fox', 'jumps over', 'the lazy dog' ,'The quick brown fox jumps over the lazy dog') 結果 The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog print會依次列印每個字串，遇到逗號“,”會輸出一個空格，因此，輸出的字串是這樣拼起來的： python中定義字串如果字串既包含&#39;又包含&quot;怎麼辦？這個時候，就需要對字串的某些特殊字符進行“轉義”，Python字串用\進行轉義。要表示字串 Bob said “I’m OK”.由於 ‘ 和 “ 會引起歧義，因此，我們在它前面插入一個\表示這是一個普通字符，不代表字串的起始，因此，這個字串又可以表示為 ‘Bob said \”I\’m OK\”.’ 注意：轉義字符 \ 不計入字串的內容中。 常用的轉義字符還有： \n 表示換行\t 表示一個製表符\ 表示 \ 字串本身 Python中raw字串與多行字串如果一個字串包含很多需要轉義的字符，對每一個字符都進行轉義會很麻煩。為了避免這種情況，我們可以在字串前面加個前綴 r ，表示這是一個 raw 字串，裡面的字符就不需要轉義了。例如： r’(~~)/ (~~)/‘ 但是r&#39;...&#39;表示法不能表示多行字串，也不能表示包含&#39;和&quot;的字串（為什麼？） 如果要表示多行字串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： ‘’’Line 1Line 2Line 3’’’ 上面這個字串的表示方法和下面的是完全一樣的： ‘Line 1\nLine 2\nLine 3’ 還可以在多行字串前面添加 r ，把這個多行字串也變成一個raw字串： r’’’Python is created by “Guido”.It is free and easy to learn.Let’s start learn Python in imooc!’’’ Python中Unicode字串字串還有一個編碼問題。 因為計算機只能處理數字，如果要處理文本，就必須先把文本轉換為數字才能處理。最早的計算機在設計時採用8個比特（bit）作為一個字節（byte），所以，一個字節能表示的最大的整數就是255（二進制11111111=十進制255），0 - 255被用來表示大小寫英文字母、數字和一些符號，這個編碼表被稱為ASCII編碼，比如大寫字母A 的編碼是65，小寫字母z 的編碼是122。 如果要表示中文，顯然一個字節是不夠的，至少需要兩個字節，而且還不能和ASCII編碼衝突，所以，中國製定了GB2312編碼，用來把中文編進去。 類似的，日文和韓文等其他語言也有這個問題。為了統一所有文字的編碼，Unicode應運而生。 Unicode把所有語言都統一到一套編碼裡，這樣就不會再有亂碼問題了。 Unicode通常用兩個字節表示一個字符，原有的英文編碼從單字節變成雙字節，只需要把高字節全部填為0就可以。 因為Python的誕生比Unicode標準發布的時間還要早，所以最早的Python只支持ASCII編碼，普通的字串&#39;ABC&#39;在Python內部都是ASCII編碼的。 Python在後來添加了對Unicode的支持，以Unicode表示的字串用u’…’表示，比如： print u’中文’中文 注意: 不加 u ，中文就不能正常顯示。 Unicode字串除了多了一個 u 之外，與普通字串沒啥區別，轉義字符和多行表示法仍然有效： 轉義： u’中文\n日文\n韓文’ 多行： u’’’第一行第二行’’’ raw+多行： ur’’’Python的Unicode字串支持”中文”,“日文”,“韓文”等多種語言’’’ 如果中文字串在Python環境下遇到 UnicodeDecodeError，這是因為.py文件保存的格式有問題。可以在第一行增加註釋 –coding: utf-8– 目的是告訴Python解釋器，用UTF-8編碼讀取源代碼。然後用Notepad++ 另存為… 並選擇UTF-8格式保存。 Python中整數和浮點數Python支持對整數和浮點數直接進行四則混合運算，運算規則和數學上的四則運算規則完全一致。 基本的運算： 1 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括號可以提升優先級，這和數學運算完全一致，注意只能使用小括號，但是括號可以嵌套很多層： (1 + 2) 3 # ==&gt; 9(2.2 + 3.3) / (1.5 (9 - 0.3)) # ==&gt; 0.42145593869731807 和數學運算不同的地方是，Python的整數運算結果仍然是整數，浮點數運算結果仍然是浮點數： 1 + 2 # ==&gt; 整數 31.0 + 2.0 # ==&gt; 浮點數 3.0 但是整數和浮點數混合運算的結果就變成浮點數了： 1 + 2.0 # ==&gt; 浮點數 3.0 為什麼要區分整數運算和浮點數運算呢？這是因為整數運算的結果永遠是精確的，而浮點數運算的結果不一定精確，因為計算機內存再大，也無法精確表示出無限循環小數，比如 0.1 換成二進製表示就是無限循環小數。 那整數的除法運算遇到除不盡的時候，結果難道不是浮點數嗎？我們來試一下： 11 / 4 # ==&gt; 2 令很多初學者驚訝的是，Python的整數除法，即使除不盡，結果仍然是整數，餘數直接被扔掉。不過，Python提供了一個求餘的運算 % 可以計算餘數： 11 % 4 # ==&gt; 3 如果我們要計算 11 / 4 的精確結果，按照“整數和浮點數混合運算的結果是浮點數”的法則，把兩個數中的一個變成浮點數再運算就沒問題了： 11.0 / 4 # ==&gt; 2.75 Python中布爾類型我們已經了解了Python支持布爾類型的數據，布爾類型只有True和False兩種值，但是布爾類型有以下幾種運算： and 運算：只有兩個布爾值都為 True 時，計算結果才為 True。 True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False or運算：只要有一個布爾值為 True，計算結果就是 True。 True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False not運算：把True變為False，或者把False變為True： not True # ==&gt; Falsenot False # ==&gt; True 布爾運算在計算機中用來做條件判斷，根據計算結果為True或者False，計算機可以自動執行不同的後續代碼。 在Python中，布爾類型還可以與其他數據類型做 and、or和not運算，請看下面的代碼： a = Trueprint a and ‘a=T’ or ‘a=F’ 計算結果不是布爾類型，而是字串 ‘a=T’，這是為什麼呢？ 因為Python把0、空字串&#39;&#39;和None看成 False，其他數值和非空字串都看成 True，所以：&gt;True and ‘a=T’ 計算結果是 ‘a=T’繼續計算 ‘a=T’ or ‘a=F’ 計算結果還是 ‘a=T’要解釋上述結果，又涉及到 and 和 or 運算的一條重要法則：短路計算。 在計算 a and b 時，如果 a 是 False，則根據與運算法則，整個結果必定為 False，因此返回 a；如果 a 是 True，則整個計算結果必定取決與 b，因此返回 b。 在計算 a or b 時，如果 a 是 True，則根據或運算法則，整個計算結果必定為 True，因此返回 a；如果 a 是 False，則整個計算結果必定取決於 b，因此返回 b。 所以Python解釋器在做布爾運算時，只要能提前確定計算結果，它就不會往後算了，直接返回結果。 List和Tuple類型Pytho建立listPython內置的一種數據類型是列表：list。 list是一種有序的集合，可以隨時添加和刪除其中的元素。 比如，列出班裡所有同學的名字，就可以用一個list表示： [‘Michael’, ‘Bob’, ‘Tracy’][‘Michael’, ‘Bob’, ‘Tracy’] list是數學意義上的有序集合，也就是說，list中的元素是按照順序排列的。 構造list非常簡單，按照上面的代碼，直接用[ ]把list的所有元素都括起來，就是一個list對象。通常，我們會把list賦值給一個變量，這樣，就可以通過變量來引用list： classmates = [‘Michael’, ‘Bob’, ‘Tracy’]classmates # 列印classmates變量的內容[‘Michael’, ‘Bob’, ‘Tracy’] 由於Python是動態語言，所以list中包含的元素並不要求都必須是同一種數據類型，我們完全可以在list中包含各種數據： L = [‘Michael’, 100, True] 一個元素也沒有的list，就是空list： empty_list = [] Python按照索引訪問list由於list是一個有序集合，所以，我們可以用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 那我們如何從list中獲取指定第 N 名的同學呢？方法是通過索引來獲取list中的指定元素。 需要特別注意的是，索引從 0 開始，也就是說，第一個元素的索引是0，第二個元素的索引是1，以此類推。因此，要列印第一名同學的名字，用 L[0]: print L[0]Adam 要列印第二名同學的名字，用 L[1]: print L[1]Lisa 要列印第三名同學的名字，用 L[2]: print L[2]Bart 要列印第四名同學的名字，用 L[3]: print L[3]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range 報錯了！ IndexError意思就是索引超出了範圍，因為上面的list只有3個元素，有效的索引是 0，1，2。 所以，使用索引時，千萬注意不要越界。 Python之倒序訪問list我們還是用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 這時，老師說，請分數最低的同學站出來。 要寫代碼完成這個任務，我們可以先數一數這個 list，發現它包含3個元素，因此，最後一個元素的索引是2： print L[2]Bart 有沒有更簡單的方法？ 有！ Bart同學是最後一名，俗稱倒數第一，所以，我們可以用 -1 這個索引來表示最後一個元素： print L[-1]Bart Bart同學表示躺槍。 類似的，倒數第二用 -2 表示，倒數第三用 -3 表示，倒數第四用 -4 表示： print L[-2]Lisaprint L[-3]Adamprint L[-4]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range L[-4] 報錯了，因為倒數第四不存在，一共只有3個元素。 使用倒序索引時，也要注意不要越界。 Python之添加新元素現在，班裡有3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 今天，班裡轉來一名新同學 Paul，如何把新同學添加到現有的 list 中呢？ 第一個辦法是用 list 的 append() 方法，把新同學追加到 list 的末尾： L = [‘Adam’, ‘Lisa’, ‘Bart’]L.append(‘Paul’) print L[‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] append()總是把新的元素添加到 list 的尾部。 如果 Paul 同學表示自己總是考滿分，要求添加到第一的位置，怎麼辦？ 方法是用list的 insert()方法，它接受兩個參數，第一個參數是索引號，第二個參數是待添加的新元素： L = [‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, ‘Paul’) print L[‘Paul’, ‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, &#39;Paul&#39;) 的意思是，’Paul’將被添加到索引為0 的位置上（也就是第一個），而原來索引為0 的Adam同學，以及後面的所有同學，都自動向後移動一位。 Python從list刪除元素Paul同學剛來幾天又要轉走了，那麼我們怎麼把Paul 從現有的list中刪除呢？ 如果Paul同學排在最後一個，我們可以用list的pop()方法刪除： L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] L.pop()‘Paul’ print L[‘Adam’, ‘Lisa’, ‘Bart’] pop()方法總是刪掉list的最後一個元素，並且它還返回這個元素，所以我們執行 L.pop() 後，會列印出 ‘Paul’。 如果Paul同學不是排在最後​​一個怎麼辦？比如Paul同學排在第三： L = [‘Adam’, ‘Lisa’, ‘Paul’, ‘Bart’] 要把Paul踢出list，我們就必須先定位Paul的位置。由於Paul的索引是2，因此，用 pop(2)把Paul刪掉： L.pop(2)‘Paul’print L[‘Adam’, ‘Lisa’, ‘Bart’] Python中替换元素假設現在班裡仍然是3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 現在，Bart同學要轉學走了，碰巧來了一個Paul同學，要更新班級成員名單，我們可以先把Bart刪掉，再把Paul添加進來。另一個辦法是直接用Paul把Bart給替換掉： L[2] = ‘Paul’ print LL = [‘Adam’, ‘Lisa’, ‘Paul’] 對list中的某一個索引賦值，就可以直接用新的元素替換掉原來的元素，list包含的元素個數保持不變。 由於Bart還可以用 -1 做索引，因此，下面的代碼也可以完成同樣的替換工作： L[-1] = ‘Paul’ Python之創建tupletuple是另一種有序的列表，中文翻譯為“ 元組 ”。 tuple 和 list 非常類似，但是，tuple一旦創建完畢，就不能修改了。 同樣是表示班裡同學的名稱，用tuple表示如下： t = (‘Adam’, ‘Lisa’, ‘Bart’) 創建tuple和創建list唯一不同之處是用( )替代了[ ]。 現在，這個t 就不能改變了，tuple沒有 append()方法，也沒有insert()和pop()方法。所以，新同學沒法直接往 tuple 中添加，老同學想退出 tuple 也不行。 獲取 tuple 元素的方式和 list 是一模一樣的，我們可以正常使用 t[0]，t[-1]等索引方式訪問元素，但是不能賦值成別的元素，不信可以試試： t[0] = ‘Paul’Traceback (most recent call last): File ““, line 1, in TypeError: ‘tuple’ object does not support item assignment Python之創建單元素tupletuple和list一樣，可以包含 0 個、1個和任意多個元素。 包含多個元素的 tuple，前面我們已經創建過了。 包含 0 個元素的 tuple，也就是空tuple，直接用 ()表示： t = () print t()創建包含1個元素的 tuple 呢？來試試： t = (1) print t1 好像哪裡不對！ t 不是 tuple ，而是整數1。為什麼呢？ 因為()既可以表示tuple，又可以作為括號表示運算時的優先級，結果 (1) 被Python解釋器計算出結果 1，導致我們得到的不是tuple，而是整數 1。 正是因為用()定義單元素的tuple有歧義，所以 Python 規定，單元素 tuple 要多加一個逗號“,”，這樣就避免了歧義： t = (1,) print t(1,) Python在列印單元素tuple時，也自動添加了一個“,”，為了更明確地告訴你這是一個tuple。多元素 tuple 加不加這個額外的“,”效果是一樣的： t = (1, 2, 3,) print t(1, 2, 3) Python之”可變”的tuple前面我們看到了tuple一旦創建就不能修改。現在，我們來看一個“可變”的tuple： t = (‘a’, ‘b’, [‘A’, ‘B’]) 注意到 t 有 3 個元素：&#39;a&#39;，&#39;b&#39;和一個list：[&#39;A&#39;, &#39;B&#39;]。 list作為一個整體是tuple的第3個元素。 list對象可以通過 t[2] 拿到： L = t[2] 然後，我們把list的兩個元素改一改： L[0] = ‘X’ L[1] = ‘Y’ 再看看tuple的內容： print t(‘a’, ‘b’, [‘X’, ‘Y’]) 不是說tuple一旦定義後就不可變了嗎？怎麼現在又變了？ 別急，我們先看看定義的時候tuple包含的3個元素​​： 當我們把list的元素&#39;A&#39;和&#39;B&#39;修改為&#39;X&#39;和&#39;Y&#39;後，tuple變為： 表面上看，tuple的元素確實變了，但其實變的不是 tuple 的元素，而是list的元素。 tuple一開始指向的list並沒有改成別的list，所以，tuple所謂的“不變”是說，tuple的每個元素，指向永遠不變。即指向’a’，就不能改成指向’b’，指向一個list，就不能改成指向其他對象，但指向的這個list本身是可變的！ 理解了“指向不變”後，要創建一個內容也不變的tuple怎麼做？那就必須保證tuple的每一個元素本身也不能變。 條件判斷和循環Python之if語句計算機之所以能做很多自動化的任務，因為它可以自己做條件判斷。 比如，輸入用戶年齡，根據年齡列印不同的內容，在Python程序中，可以用if語句實現： age = 20if age &gt;= 18: print ‘your age is’, age print ‘adult’print ‘END’ 注意: Python代碼的縮進規則。具有相同縮進的代碼被視為代碼塊，上面的3，4行 print 語句就構成一個代碼塊（但不包括第5行的print）。如果 if 語句判斷為 True，就會執行這個代碼塊。 縮進請嚴格按照Python的習慣寫法：4個空格，不要使用Tab，更不要混合Tab和空格，否則很容易造成因為縮進引起的語法錯誤。 注意: if 語句後接表達式，然後用:表示代碼塊開始。 age = 20 if age &gt;= 18:… print ‘your age is’, age… print ‘adult’…your age is 20adult Python之 if-else當if語句判斷表達式的結果為True時，就會執行 if 包含的代碼塊： if age &gt;= 18: print ‘adult’ 如果我們想判斷年齡在18歲以下時，印出 ‘teenager’，怎麼辦？ 方法是再寫一個 if: if age &lt; 18: print ‘teenager’ 或者用 not 運算： if not age &gt;= 18: print ‘teenager’ 細心的同學可以發現，這兩種條件判斷是“非此即彼”的，要么符合條件1，要么符合條件2，因此，完全可以用一個if ... else ... 語句把它們統一起來： if age &gt;= 18: print ‘adult’else: print ‘teenager’ 利用 if … else … 語句，我們可以根據條件表達式的值為 True或者 False，分別執行if代碼塊或者else 代碼塊。 注意: else 後面有個“:”。 Python之 if-elif-else有的時候，一個 if … else … 還不夠用。比如，根據年齡的劃分： 條件1：18歲或以上：adult條件2：6歲或以上：teenager條件3：6歲以下：kid 我們可以用一個 if age &gt;= 18 判斷是否符合條件1，如果不符合，再通過一個 if 判斷 age &gt;= 6 來判斷是否符合條件2，否則，執行條件3： 1234567if age &gt;= 18: print 'adult'else: if age &gt;= 6: print 'teenager' else: print 'kid' 這樣寫出來，我們就得到了一個兩層嵌套的 if … else … 語句。這個邏輯沒有問題，但是，如果繼續增加條件，比如3歲以下是 baby： 12345678910if age &gt;= 18: print 'adult'else: if age &gt;= 6: print 'teenager' else: if age &gt;= 3: print 'kid' else: print 'baby' 這種縮進只會越來越多，代碼也會越來越難看。 要避免嵌套結構的 if … else …，我們可以用 if ... 多個elif ... else ...的結構，一次寫完所有的規則： 12345678 if age &gt;= 18: print 'adult'elif age &gt;= 6: print 'teenager'elif age &gt;= 3: print 'kid'else: print 'baby' elif 意思就是 else if。這樣一來，我們就寫出了結構非常清晰的一系列條件判斷。 特別注意: 這一系列條件判斷會從上到下依次判斷，如果某個判斷為 True，執行完對應的代碼塊，後面的條件判斷就直接忽略，不再執行了。 請思考下面的代碼： 1234567age = 8if age &gt;= 6: print 'teenager'elif age &gt;= 18: print 'adult'else: print 'kid' 當 age = 8 時，結果正確，但 age = 20 時，為什麼沒有列印出 adult？ 如果要修復，應該如何修復？ Python之 for循環list或tuple可以表示一個有序集合。如果我們想依次訪問一個list中的每一個元素呢？比如 list： 1234L = ['Adam', 'Lisa', 'Bart']print L[0]print L[1]print L[2] 如果list只包含幾個元素，這樣寫還行，如果list包含1萬個元素，我們就不可能寫1萬行print。 這時，循環就派上用場了。 Python的 for 循環就可以依次把list或tuple的每個元素迭代出來： 123L = ['Adam', 'Lisa', 'Bart']for name in L: print name 注意: name 這個變量是在 for 循環中定義的，意思是，依次取出list中的每一個元素，並把元素賦值給 name，然後執行for循環體（就是縮進的代碼塊）。 這樣一來，遍歷一個list或tuple就非常容易了 Python之 while循環和 for 循環不同的另一種循環是 while 循環，while 循環不會迭代 list 或 tuple 的元素，而是根據表達式判斷循環是否結束。 比如要從 0 開始列印不大於 N 的整數： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循環每次先判斷 x &lt; N，如果為True，則執行循環體的代碼塊，否則，退出循環。 在循環體內，x = x + 1 會讓x不斷增加，最終因為x &lt; N不成立而退出循環。 如果沒有這一個語句，while循環在判斷 x &lt; N 時總是為True，就會無限循環下去，變成死循環，所以要特別留意while循環的退出條 Python之 break退出循環用 for 循環或者 while 循環時，如果要在循環體內直接退出循環，可以使用 break 語句。 比如計算1至100的整數和，我們用while來實現： 12345678 sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 咋一看， while True 就是一個死循環，但是在循環體內，我們還判斷了x &gt; 100 條件成立時，用break語句退出循環，這樣也可以實現循環的結束。 Python之 continue繼續循環在循環過程中，可以用break退出當前循環，還可以用continue跳過後續循環代碼，繼續下一次循環。 假設我們已經寫好了利用for循環計算平均分的代碼： 1234567 L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 現在老師只想統計及格分數的平均分，就要把x &lt; 60 的分數剔除掉，這時，利用continue，可以做到當x &lt; 60的時候，不繼續執行循環體的後續代碼，直接進入下一次循環： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 Python之 多重循環在循環內部，還可以嵌套循環，我們來看一個例子： 123for x in ['A', 'B', 'C']: for y in ['1', '2', '3']: print x + y x 每循環一次，y 就會循環 3 次，這樣，我們可以列印出一個全排列： A1A2A3B1B2B3C1C2C3 Dict和Set類型Python之什麼是dict我們已經知道，list 和 tuple 可以用來表示順序集合，例如，班裡同學的名字： [‘Adam’, ‘Lisa’, ‘Bart’] 或者考試的成績列表： [95, 85, 59] 但是，要根據名字找到對應的成績，用兩個 list 表示就不方便。 如果把名字和分數關聯起來，組成類似的查找表： 123'Adam' ==&gt; 95'Lisa' ==&gt; 85'Bart' ==&gt; 59 給定一個名字，就可以直接查到分數。 Python的 dict 就是專門幹這件事的。用dict表示“名字”-“成績”的查找表如下： 12345d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 我們把名字稱為key，對應的成績稱為value，dict就是通過key來查找value。 花括號{}表示這是一個dict，然後按照 key: value, 寫出來即可。最後一個 key: value 的逗號可以省略。 由於dict也是集合，len() 函數可以計算任意集合的大小： 12len(d)3 注意: 一個 key-value 算一個，因此，dict大小為3。 Python之訪問dict我們已經能創建一個dict，用於表示名字和成績的對應關係： 12345d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 那麼，如何根據名字來查找對應的成績呢？ 可以簡單地使用 d[key] 的形式來查找對應的 value，這和 list 很像，不同之處是，list 必須使用索引返回對應的元素，而dict使用key： 1234567print d['Adam']95 print d['Paul']Traceback (most recent call last): File "index.py", line 11, in &lt;module&gt; print d['Paul']KeyError: 'Paul' 注意: 通過 key 訪問 dict 的value，只要 key 存在，dict就返回對應的value。如果key不存在，會直接報錯：KeyError。 要避免 KeyError 發生，有兩個辦法： 一是先判斷一下 key 是否存在，用 in 操作符： 12if 'Paul' in d: print d['Paul'] 如果 ‘Paul’ 不存在，if語句判斷為False，自然不會執行 print d[‘Paul’] ，從而避免了錯誤。 二是使用dict本身提供的一個 get 方法，在Key不存在的時候，返回None： 1234&gt;&gt;&gt; print d.get('Bart')59&gt;&gt;&gt; print d.get('Paul')None Python中dict的特點dict的第一個特點是查找速度快，無論dict有10個元素還是10萬個元素，查找速度都一樣。而list的查找速度隨著元素增加而逐漸下降。 不過dict的查找速度快不是沒有代價的，dict的缺點是佔用內存大，還會浪費很多內容，list正好相反，佔用內存小，但是查找速度慢。 由於dict是按 key 查找，所以，在一個dict中，key不能重複。 dict的第二個特點就是存儲的key-value序對是沒有順序的！這和list不一樣： 12345 d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 當我們試圖列印這個dict時： 12 &gt;&gt;&gt; print d&#123;'Lisa': 85, 'Adam': 95, 'Bart': 59&#125; 列印的順序不一定是我們創建時的順序，而且，不同的機器列印的順序都可能不同，這說明dict內部是無序的，不能用dict存儲有序的集合。 dict的第三個特點是作為 key 的元素必須不可變，Python的基本類型如字串、整數、浮點數都是不可變的，都可以作為 key。但是list是可變的，就不能作為 key。 可以試試用list作為key時會報什麼樣的錯誤。 不可變這個限制僅作用於key，value是否可變無所謂： 12345&#123; '123': [1, 2, 3], # key 是 str，value是list 123: '123', # key 是 int，value 是 str ('a', 'b'): True # key 是 tuple，並且tuple的每個元素都是不可變對象，value是 boolean&#125; 最常用的key還是字串，因為用起來最方便。 Python更新dictdict是可變的，也就是說，我們可以隨時往dict中添加新的 key-value。比如已有dict： 12345 d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 要把新同學’Paul’的成績 72 加進去，用賦值語句： 1&gt;&gt;&gt; d['Paul'] = 72 再看看dict的內容： 12&gt;&gt;&gt; print d&#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59&#125; 如果 key 已經存在，則賦值會用新的 value 替換掉原來的 value： 123&gt;&gt;&gt; d['Bart'] = 60&gt;&gt;&gt; print d&#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60&#125; Python之 遍歷dict由於dict也是一個集合，所以，遍歷dict和遍歷list類似，都可以通過 for 循環實現。 直接使用for循環可以遍歷 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; for key in d:... print key...LisaAdamBart 由於通過 key 可以獲取對應的 value，因此，在循環體內，可以獲取到value的值。 Python中什麼是setdict的作用是建立一組 key 和一組 value 的映射關係，dict的key是不能重複的。 有的時候，我們只想要 dict 的 key，不關心 key 對應的 value，目的就是保證這個集合的元素不會重複，這時，set就派上用場了。 set 持有一系列元素，這一點和 list 很像，但是set的元素沒有重複，而且是無序的，這點和 dict 的 key很像。 創建 set 的方式是調用 set() 並傳入一個 list，list的元素將作為set的元素： 1&gt;&gt;&gt; s = set(['A', 'B', 'C']) 可以查看 set 的內容： 12&gt;&gt;&gt; print sset(['A', 'C', 'B']) 請注意，上述列印的形式類似 list， 但它不是 list，仔細看還可以發現，列印的順序和原始 list 的順序有可能是不同的，因為set內部存儲的元素是無序的。 因為set不能包含重複的元素，所以，當我們傳入包含重複元素的 list 會怎麼樣呢？12345&gt;&gt;&gt; s = set(['A', 'B', 'C', 'C'])&gt;&gt;&gt; print sset(['A', 'C', 'B'])&gt;&gt;&gt; len(s)3 結果顯示，set會自動去掉重複的元素，原來的list有4個元素，但set只有3個元素。 Python之 訪問set由於set存儲的是無序集合，所以我們沒法通過索引來訪問。 訪問 set中的某個元素實際上就是判斷一個元素是否在set中。 例如，存儲了班裡同學名字的set：1&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart', 'Paul']) 我們可以用 in 操作符判斷： Bart是該班的同學嗎？12&gt;&gt;&gt; 'Bart' in sTrue Bill是該班的同學嗎？12&gt;&gt;&gt; 'Bill' in sFalse bart是該班的同學嗎？12&gt;&gt;&gt; 'bart' in sFalse 看來大小寫很重要，’Bart’ 和 ‘bart’被認為是兩個不同的元素。 Python之 set的特點set的內部結構和dict很像，唯一區別是不存儲value，因此，判斷一個元素是否在set中速度很快。 set存儲的元素和dict的key類似，必須是不變對象，因此，任何可變對像是不能放入set中的。 最後，set存儲的元素也是沒有順序的。 set的這些特點，可以應用在哪些地方呢？ 星期一到星期日可以用字串’MON’, ‘TUE’, … ‘SUN’表示。 假設我們讓用戶輸入星期一至星期日的某天，如何判斷用戶的輸入是否是一個有效的星期呢？ 可以用if 語句判斷，但這樣做非常繁瑣：12345x = '???' # 用戶輸入的字串if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN': print 'input error'else: print 'input ok' 注意：if 語句中的…表示沒有列出的其它星期名稱，測試時，請輸入完整。 如果事先創建好一個set，包含’MON’ ~ ‘SUN’：1weekdays = set(['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']) 再判斷輸入是否有效，只需要判斷該字串是否在set中：12345x = '???' # 用戶輸入的字串if x in weekdays: print 'input ok'else: print 'input error' 這樣一來，代碼就簡單多了。 Python之 遍歷set由於 set 也是一個集合，所以，遍歷 set 和遍歷 list 類似，都可以通過 for 循環實現。 直接使用 for 循環可以遍歷 set 的元素：1234567&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])&gt;&gt;&gt; for name in s:... print name...LisaAdamBart 注意: 觀察 for 循環在遍歷set時，元素的順序和list的順序很可能是不同的，而且不同的機器上運行的結果也可能不同。 Python之 更新set由於set存儲的是一組不重複的無序元素，因此，更新set主要做兩件事： 一是把新的元素添加到set中，二是把已有元素從set中刪除。 添加元素時，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已經存在於set中，add()不會報錯，但是不會加進去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 刪除set中的元素時，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果刪除的元素不存在set中，remove()會報錯： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判斷。 函數Python之什麼是函數我們知道圓的面積計算公式為： S = πr² 當我們知道半徑r的值時，就可以根據公式計算出面積。假設我們需要計算3個不同大小的圓的面積： r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 r1 r1s2 = 3.14 r2 r2s3 = 3.14 r3 r3 當代碼出現有規律的重複的時候，你就需要當心了，每次寫3.14 x x不僅很麻煩，而且，如果要把3.14改成3.14159265359的時候，得全部替換。 有了函數，我們就不再每次寫s = 3.14 x x，而是寫成更有意義的函數調用s = area_of_circle(x)，而函數 area_of_circle 本身只需要寫一次，就可以多次調用。 抽像是數學中非常常見的概念。舉個例子： 計算數列的和，比如：1 + 2 + 3 + ... + 100，寫起來十分不方便，於是數學家發明了求和符號∑，可以把1 + 2 + 3 + … + 100記作： 100∑nn=1 這種抽象記法非常強大，因為我們看到∑就可以理解成求和，而不是還原成低級的加法運算。 而且，這種抽象記法是可擴展的，比如： 100∑(n²+1)n=1 還原成加法運算就變成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1) 可見，借助抽象，我們才能不關心底層的具體計算過程，而直接在更高的層次上思考問題。 寫計算機程序也是一樣，函數就是最基本的一種代碼抽象的方式。 Python不但能非常靈活地定義函數，而且本身內置了很多有用的函數，可以直接調用。 Python之調用函數Python內置了很多有用的函數，我們可以直接調用。 要調用一個函數，需要知道函數的名稱和參數，比如求絕對值的函數 abs，它接收一個參數。 可以直接從Python的官方網站查看文檔：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通過help(abs)查看abs函數的幫助信息。 調用abs函數： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 調用函數的時候，如果傳入的參數數量不對，會報TypeError的錯誤，並且Python會明確地告訴你：abs()有且僅有1個參數，但給出了兩個： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果傳入的參數數量是對的，但參數類型不能被函數所接受，也會報TypeError的錯誤，並且給出錯誤信息：str是錯誤的參數類型： 1234&gt;&gt;&gt; abs('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' 而比較函數cmp(x, y) 就需要兩個參數，如果x&lt;y，返回-1，如果 x==y，返回 0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python內置的常用函數還包括數據類型轉換函數，比如int()函數可以把其他數據類型轉換為整數： 1234&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12 str()函數把其他類型轉換成 str： 1234&gt;&gt;&gt; str(123)'123'&gt;&gt;&gt; str(1.23)'1.23' Python之編寫函數在Python中，定義一個函數要使用def語句，依次寫出函數名、括號、括號中的參數和冒號:，然後，在縮進塊中編寫函數體，函數的返回值用 return 語句返回。 我們以自定義一個求絕對值的 my_abs 函數為例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 請注意，函數體內部的語句在執行時，一旦執行到return時，函數就執行完畢，並將結果返回。因此，函數內部通過條件判斷和循環可以實現非常複雜的邏輯。 如果沒有return語句，函數執行完畢後也會返回結果，只是結果為 None。 return None可以簡寫為return。 Python函數之返回多值函數可以返回多個值嗎？答案是肯定的。 比如在遊戲中經常需要從一個點移動到另一個點，給出坐標、位移和角度，就可以計算出新的坐標： # math包提供了sin()和 cos()函數，我們先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 這樣我們就可以同時獲得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其實這只是一種假象，Python函數返回的仍然是單一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 用print列印返回結果，原來返回值是一個tuple！ 但是，在語法上，返回一個tuple可以省略括號，而多個變量可以同時接收一個tuple，按位置賦給對應的值，所以，Python的函數返回多值其實就是返回一個tuple，但寫起來更方便。 Python之遞歸函數在函數內部，可以調用其他函數。如果一個函數在內部調用自身本身，這個函數就是遞歸函數。 舉個例子，我們來計算階乘n! = 1 * 2 * 3 * ... * n，用函數 fact(n)表示，可以看出： 1fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n 所以，fact(n)可以表示為n * fact(n-1)，只有n=1時需要特殊處理。 於是，fact(n)用遞歸的方式寫出來就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一個遞歸函數。可以試試： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L 如果我們計算fact(5)，可以根據函數定義看到計算過程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 遞歸函數的優點是定義簡單，邏輯清晰。理論上，所有的遞歸函數都可以寫成循環的方式，但循環的邏輯不如遞歸清晰。 使用遞歸函數需要注意防止棧溢出。在計算機中，函數調用是通過棧（stack）這種數據結構實現的，每當進入一個函數調用，棧就會加一層棧幀，每當函數返回，棧就會減一層棧幀。由於棧的大小不是無限的，所以，遞歸調用的次數過多，會導致棧溢出。可以試試計算 fact(10000)。 Python之定義默認參數定義函數的時候，還可以有默認參數。 例如Python自帶的int()函數，其實就有兩個參數，我們既可以傳一個參數，又可以傳兩個參數：1234&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int('123', 8)83 int()函數的第二個參數是轉換進制，如果不傳，默認是十進制 (base=10)，如果傳了，就用傳入的參數。 可見，函數的默認參數的作用是簡化調用，你只需要把必須的參數傳進去。但是在需要的時候，又可以傳入額外的參數來覆蓋默認參數值。 我們來定義一個計算 x 的N次方的函數:123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假設計算平方的次數最多，我們就可以把 n 的默認值設定為 2：123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 這樣一來，計算平方就不需要傳入兩個參數了：12&gt;&gt;&gt; power(5)25 由於函數的參數按從左到右的順序匹配，所以默認參數只能定義在必需參數的後面：123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass Python之定義可變參數如果想讓一個函數能接受任意個參數，我們就可以定義一個可變參數： 12def fn(*args): print args 可變參數的名字前面有個 *號，我們可以傳入0個、1個或多個參數給可變參數：12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b')&gt;&gt;&gt; fn('a', 'b', 'c')('a', 'b', 'c') 可變參數也不是很神秘，Python解釋器會把傳入的一組參數組裝成一個tuple傳遞給可變參數，因此，在函數內部，直接把變量 args 看成一個tuple就好了。 定義可變參數的目的也是為了簡化調用。假設我們要計算任意個數的平均值，就可以定義一個可變參數：12def average(*args): ... 這樣，在調用的時候，可以這樣寫：123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 切割對list進行切割取一個list的部分元素是非常常見的操作。比如，一個list如下： 1&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul'] 取前3個元素，應該怎麼做？ 笨辦法：12&gt;&gt;&gt; [L[0], L[1], L[2]]['Adam', 'Lisa', 'Bart'] 之所以是笨辦法是因為擴展一下，取前N個元素就沒轍了。 取前N個元素，也就是索引為0-(N-1)的元素，可以用循環：1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])...&gt;&gt;&gt; r['Adam', 'Lisa', 'Bart'] 對這種經常取指定索引範圍的操作，用循環十分繁瑣，因此，Python提供了切片（Slice）操作符，能大大簡化這種操作。 對應上面的問題，取前3個元素，用一行代碼就可以完成切片： 12&gt;&gt;&gt; L[0:3]['Adam', 'Lisa', 'Bart'] L[0:3]表示，從索引0開始取，直到索引3為止，但不包括索引3。即索引0，1，2，正好是3個元素。 如果第一個索引是0，還可以省略： 12&gt;&gt;&gt; L[:3]['Adam', 'Lisa', 'Bart'] 也可以從索引1開始，取出2個元素出來： 12&gt;&gt;&gt; L[1:3]['Lisa', 'Bart'] 只用一個 : ，表示從頭到尾： 12&gt;&gt;&gt; L[:]['Adam', 'Lisa', 'Bart', 'Paul'] 因此，L[:]實際上複製出了一個新list。 切片操作還可以指定第三個參數： 12&gt;&gt;&gt; L[::2]['Adam', 'Bart'] 第三個參數表示每N個取一個，上面的 L[::2] 會每兩個元素取出一個來，也就是隔一個取一個。 把list換成tuple，切片操作完全相同，只是切片的結果也變成了tuple。 倒序切割對於list，既然Python支持L[-1]取倒數第一個元素，那麼它同樣支持倒數切片，試試： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L[-2:]['Bart', 'Paul']&gt;&gt;&gt; L[:-2]['Adam', 'Lisa']&gt;&gt;&gt; L[-3:-1]['Lisa', 'Bart']&gt;&gt;&gt; L[-4:-1:2]['Adam', 'Bart'] 記住倒數第一個元素的索引是-1。倒序切片包含起始索引，不包含結束索引。 對字串切割字串 ‘xxx’和 Unicode字串 u’xxx’也可以看成是一種list，每個元素就是一個字符。因此，字串也可以用切片操作，只是操作結果仍是字串： 123456&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[-3:]'EFG'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 在很多編程語言中，針對字串提供了很多各種截取函數，其實目的就是對字串切片。 Python沒有針對字串的截取函數，只需要切片一個操作就可以完成，非常簡單。 任務字串有個方法 upper() 可以把字符變成大寫字母：12&gt;&gt;&gt; 'abc'.upper()'ABC' 但它會把所有字母都變成大寫。請設計一個函數，它接受一個字串，然後返回一個僅首字母變成大寫的字串。 提示：利用切片操作簡化字串操作。 迭代什麼是迭代在Python中，如果給定一個list或tuple，我們可以通過for循環來遍歷這個list或tuple，這種遍歷我們成為迭代（Iteration）。 在Python中，迭代是通過 for ... in 來完成的，而很多語言比如C或者Java，迭代list是通過下標完成的，比如Java代碼： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循環抽象程度要高於Java的for循環。 因為 Python 的 for循環不僅可以用在list或tuple上，還可以作用在其他任何可迭代對像上。 因此，迭代操作就是對於一個集合，無論該集合是有序還是無序，我們用 for 循環總是可以依次取出集合的每一個元素。&gt;注意: 集合是指包含一組元素的數據結構，我們已經介紹的包括： 有序集合：list，tuple，str和unicode； 無序集合：set 無序集合併且具有 key-value 對：dict而迭代是一個動詞，它指的是一種操作，在Python中，就是 for 循環。 迭代與按下標訪問數組最大的不同是，後者是一種具體的迭代實現方式，而前者只關心迭代結果，根本不關心迭代內部是如何實現的。 索引迭代Python中，迭代永遠是取出元素本身，而非元素的索引。 對於有序集合，元素確實是有索引的。有的時候，我們確實想在 for 循環中拿到索引，怎麼辦？ 方法是使用enumerate() 函數： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; for index, name in enumerate(L):... print index, '-', name...0 - Adam1 - Lisa2 - Bart3 - Paul``使用 enumerate() 函數，我們可以在for循環中同時綁定索引index和元素name。但是，這不是 enumerate() 的特殊語法。實際上，enumerate() 函數把：``` python['Adam', 'Lisa', 'Bart', 'Paul'] 變成了類似：1[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')] 因此，迭代的每一個元素實際上是一個tuple：1234for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 如果我們知道每個tuple元素都包含兩個元素，for循環又可以進一步簡寫為：12for index, name in enumerate(L): print index, '-', name 這樣不但代碼更簡單，而且還少了兩條賦值語句。 可見，索引迭代也不是真的按索引訪問，而是由 enumerate() 函數自動把每個元素變成 (index, element) 這樣的tuple，再迭代，就同時獲得了索引和元素本身。 迭代dict的value我們已經了解了dict對象本身就是可迭代對象，用 for 循環直接迭代 dict，可以每次拿到dict的一個key。 如果我們希望迭代 dict 對象的value，應該怎麼做？ dict 對像有一個 values() 方法，這個方法把dict轉換成一個包含所有value的list，這樣，我們迭代的就是 dict的每一個 value： 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔細閱讀Python的文檔，還可以發現，dict除了values()方法外，還有一個 itervalues() 方法，用 itervalues()方法替代 values() 方法，迭代效果完全一樣： 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那這兩個方法有何不同之處呢？ values() 方法實際上把一個 dict 轉換成了包含 value 的list。 但是 itervalues() 方法不會轉換，它會在迭代過程中依次從 dict 中取出 value，所以 itervalues() 方法比 values() 方法節省了生成 list 所需的內存。 列印itervalues() 發現它返回一個 對象，這說明在Python中，for 循環可作用的迭代對象遠不止list，tuple，str，unicode，dict等，任何可迭代對像都可以作用於for循環，而內部如何迭代我們通常並不用關心。 如果一個對像說自己可迭代，那我們就直接用 for 循環去迭代它，可見，迭代是一種抽象的數據操作，它不對迭代對象內部的數據有任何要求。 迭代dict的key和value我們了解瞭如何迭代 dict 的key和value，那麼，在一個 for 循環中，能否同時迭代 key和value？答案是肯定的。 首先，我們看看 dict 對象的 items() 方法返回的值： 123&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; print d.items()[('Lisa', 85), ('Adam', 95), ('Bart', 59)] 可以看到，items() 方法把dict對象轉換成了包含tuple的list，我們對這個list進行迭代，可以同時獲得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, ':', value...Lisa : 85Adam : 95Bart : 59 和values() 有一個itervalues() 類似，items() 也有一個對應的iteritems()，iteritems() 不把dict轉換成list，而是在迭代過程中不斷給出tuple，所以， iteritems() 不佔用額外的內存。 列表生成式生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我們可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎麼做？方法一是循環：123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循環太繁瑣，而列表生成式則可以用一行語句代替循環生成上面的list：12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 這種寫法就是Python特有的列表生成式。利用列表生成式，可以以非常簡潔的代碼生成 list。 寫列表生成式時，把要生成的元素 x * x 放到前面，後面跟 for 循環，就可以把list創建出來，十分有用，多寫幾次，很快就可以熟悉這種語法。 複雜表達式使用for循環的迭代不僅可以迭代普通的list，還可以迭代dict。 假設有如下的dict： 1d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125; 完全可以通過一個複雜的列表生成式把它變成一個 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;' 注：字串可以通過 % 進行格式化，用指定的參數替代 %s。字串的join()方法可以把一個 list 拼接成一個字串。 把列印出來的結果保存為一個html文件，就可以在瀏覽器中看到效果了： 123456&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 條件過濾列表生成式的 for 循環後面還可以加上 if 判斷。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我們只想要偶數的平方，不改動 range()的情況下，可以加上 if 來篩選：12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 條件，只有 if 判斷為 True 的時候，才把循環的當前元素添加到列表中。 多層表達式for循環可以嵌套，因此，在列表生成式中，也可以用多層for循環來生成列表。 對於字串 ‘ABC’ 和 ‘123’，可以使用兩層循環，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻譯成循環代碼就像下面這樣：1234L = []for m in 'ABC': for n in '123': L.append(m + n) python 進階函數式編譯python把函數作為參數前面我們講了高階函數的概念，並編寫了一個簡單的高階函數：12def add(x, y, f): return f(x) + f(y) 如果傳入abs作為參數f的值：1add(-5, 9, abs) 根據函數的定義，函數執行的程式碼實際上是：1abs(-5) + abs(9) 由於參數 x, y 和 f 都可以任意傳入，如果 f 傳入其他函數，就可以得到不同的返回值。 python中map()函數map()是 Python 內置的高階函數，它接收一個函數 f 和一個 list，並通過把函數 f依次作用在list的每個元素上，得到一個新的 list 並返回。 例如，對於list [1, 2, 3, 4, 5, 6, 7, 8, 9] 如果希望把list的每個元素都作平方，就可以用map()函數： 因此，我們只需要傳入函數f(x)=x*x，就可以利用map()函數完成這個計算：123def f(x): return x*xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 輸出結果：1[1, 4, 9, 10, 25, 36, 49, 64, 81] 注意：map()函數不改變原有的 list，而是返回一個新的 list。 利用map()函數，可以把一個 list 轉換為另一個 list，只需要傳入轉換函數。 由於list包含的元素可以是任何類型，因此，map() 不僅僅可以處理只包含數值的 list，事實上它可以處理包含任意類型的 list，只要傳入的函數f可以處理這種數據類型。 python中reduce()函數reduce()函數也是Python內置的一個高階函數。 reduce()函數接收的參數和map()類似，一個函數f，一個list，但行為和map()不同，reduce()傳入的函數f 必須接收兩個參數，reduce()對list的每個元素反複調用函數f，並返回最終結果值。 例如，編寫一個f函數，接收x和y，返回x和y的和：12def f(x, y): return x + y 調用 reduce(f, [1, 3, 5, 7, 9])時，reduce函數將做如下計算：&gt;先計算頭兩個元素：f(1, 3)，結果為4；再把結果和第3個元素計算：f(4, 5)，結果為9；再把結果和第4個元素計算：f(9, 7)，結果為16；再把結果和第5個元素計算：f(16, 9)，結果為25；由於沒有更多的元素了，計算結束，返回結果25。 上述計算實際上是對 list 的所有元素求和。雖然Python內置了求和函數sum()，但是，利用reduce()求和也很簡單。 reduce()還可以接收第3個可選參數，作為計算的初始值。如果把初始值設為100，計算：1reduce(f, [1, 3, 5, 7, 9], 100) 結果將變為125，因為第一輪計算是： 計算初始值和第一個元素：f(100, 1)，結果為101。 python中filter()函數filter()函數是Python 內置的另一個有用的高階函數，filter()函數接收一個函數f和一個list，這個函數f 的作用是對每個元素進行判斷，返回True或False，filter()根據判斷結果自動過濾掉不符合條件的元素，返回由符合條件元素組成的新list。 例如，要從一個list [1, 4, 6, 7, 9, 12, 17]中刪除偶數，保留奇數，首先，要編寫一個判斷奇數的函數： 12def is_odd(x): return x % 2 == 1 然後，利用filter()過濾掉偶數： 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) 結果：[1, 7, 9, 17] 利用filter()，可以完成很多有用的功能，例如，刪除 None 或者空字符串： 123def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END']) 結果：[‘test’, ‘str’, ‘END’] 注意: s.strip(rm) 刪除 s 字符串中開頭、結尾處的 rm 序列的字符。 當rm為空時，默認刪除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下： 12a = ' 123'a.strip() 結果： ‘123’ 12a='\t\t123\r\n'a.strip() 結果：’123’ python中自定義排序函數Python內置的 sorted()函數可對list進行排序： 123&gt;&gt;&gt;sorted([36, 5, 12, 9, 21])[5, 9, 12, 21, 36] 但sorted()也是一個高階函數，它可以接收一個比較函數來實現自定義排序，比較函數的定義是，傳入兩個待比較的元素x, y，如果x 應該排在y 的前面，返回-1，如果x 應該排在y 的後面，返回1。如果 x 和 y 相等，返回 0。 因此，如果我們要實現倒序排序，只需要編寫一個reversed_cmp函數： 123456def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 這樣，調用 sorted() 並傳入 reversed_cmp 就可以實現倒序排序： 12&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] sorted()也可以對字符串進行排序，字符串默認按照ASCII大小來比較： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob'] ‘Zoo’排在’about’之前是因為’​​Z’的ASCII碼比’a’小。 python中返回函數Python的函數不但可以返回int、str、list、dict等數據類型，還可以返回函數！ 例如，定義一個函數 f()，我們讓它返回一個函數 g，可以這樣寫： 1234567def f(): print 'call f()...' # 定義函數g: def g(): print 'call g()...' # 返回函數g: return g 仔細觀察上面的函數定義，我們在函數 f 內部又定義了一個函數 g。由於函數 g 也是一個對象，函數名 g 就是指向函數 g 的變量，所以，最外層函數 f 可以返回變量 g，也就是函數 g 本身。 調用函數 f，我們會得到 f 返回的一個函數： 123456&gt;&gt;&gt; x = f() # 調用f()call f()...&gt;&gt;&gt; x # 變量x是f()返回的函數：&lt;function g at 0x1037bf320&gt;&gt;&gt;&gt; x() # x指向函數，因此可以調用call g()... # 調用x()就是執行g()函數定義的代碼 請注意區分返回函數和返回值： 1234def myabs(): return abs # 返回函數def myabs2(x): return abs(x) # 返回函數調用的結果，返回值是一個數值 返回函數可以把一些計算延遲執行。例如，如果定義一個普通的求和函數： 12def calc_sum(lst): return sum(lst) 調用calc_sum()函數時，將立刻計算並得到結果： 12&gt;&gt;&gt; calc_sum([1, 2, 3, 4])10 但是，如果返回一個函數，就可以“延遲計算”： 1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum 調用calc_sum()並沒有計算出結果，而是返回函數: 123&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])&gt;&gt;&gt; f&lt;function lazy_sum at 0x1037bfaa0&gt; 對返回的函數進行調用時，才計算出結果: 12&gt;&gt;&gt; f()10 由於可以返回函數，我們在後續代碼裡就可以決定到底要不要調用該函數。 python中閉包在函數內部定義的函數和外部定義的函數是一樣的，只是他們無法被外部訪問： 123456def g(): print 'g()...'def f(): print 'f()...' return g 將 g 的定義移入函數 f 內部，防止其他代碼調用 g： 12345def f(): print 'f()...' def g(): print 'g()...' return g 但是，考察上一小節定義的 calc_sum 函數： 1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum 注意: 發現沒法把 lazy_sum 移到 calc_sum 的外部，因為它引用了 calc_sum 的參數 lst。 像這種內層函數引用了外層函數的變量（參數也算變量），然後返回內層函數的情況，稱為閉包（Closure）。 閉包的特點是返回的函數還引用了外層函數的局部變量，所以，要正確使用閉包，就要確保引用的局部變量在函數返回後不能變。舉例如下： 12345678910# 希望一次返回3個函數，分別計算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 你可能認為調用f1()，f2()和f3()結果應該是1，4，9，但實際結果全部都是 9（請自己動手驗證）。 原因就是當count()函數返回了3個函數時，這3個函數所引用的變量 i 的值已經變成了3。由於f1、f2、f3並沒有被調用，所以，此時他們並未計算 i*i，當 f1 被調用時： 12&gt;&gt;&gt; f1()9 # 因為f1現在才計算i*i，但現在i的值已經變為3 因此，返回函數不要引用任何循環變量，或者後續會發生變化的變量。 python中匿名函數高階函數可以接收函數做參數，有些時候，我們不需要顯式地定義函數，直接傳入匿名函數更方便。 在Python中，對匿名函數提供了有限支持。還是以map()函數為例，計算 f(x)=x2 時，除了定義一個f(x)的函數外，還可以直接傳入匿名函數： 12&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 通過對比可以看出，匿名函數 lambda x: x * x 實際上就是：12def f(x): return x * x 關鍵字lambda 表示匿名函數，冒號前面的 x 表示函數參數。 匿名函數有個限制，就是只能有一個表達式，不寫return，返回值就是該表達式的結果。 使用匿名函數，可以不必定義函數名，直接創建一個函數對象，很多時候可以簡化代碼： 12&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))[9, 5, 3, 1, 0] 返回函數的時候，也可以返回匿名函數： 12345&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x&gt;&gt;&gt; myabs(-1)1&gt;&gt;&gt; myabs(1)1 python中編寫無參數decoratorPython的 decorator本質上就是一個高階函數，它接收一個函數作為參數，然後，返回一個新函數。 使用 decorator 用Python提供的@語法，這樣可以避免手動編寫f = decorate(f)這樣的代碼。 考察一個@log的定義： 12345def log(f): def fn(x): print 'call ' + f.__name__ + '()...' return f(x) return fn 對於階乘函數，@log工作得很好： 1234@logdef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) 結果： 12call factorial()...3628800 但是，對於參數不是一個的函數，調用將報錯： 1234@logdef add(x, y): return x + yprint add(1, 2) 結果： 1234Traceback (most recent call last): File "test.py", line 15, in &lt;module&gt; print add(1,2)TypeError: fn() takes exactly 1 argument (2 given) 因為add()函數需要傳入兩個參數，但是@log寫死了只含一個參數的返回函數。 要讓@log自適應任何參數定義的函數，可以利用Python的*args和**kw，保證任意個數的參數總是能正常調用： 12345def log(f): def fn(*args, **kw): print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn 現在，對於任意函數，@log 都能正常工作。 python中編寫帶參數decorator考察上一節的@log裝飾器： 12345def log(f): def fn(x): print 'call ' + f.__name__ + '()...' return f(x) return fn 發現對於被裝飾的函數，log打印的語句是不能變的（除了函數名）。 如果有的函數非常重要，希望打印出’[INFO] call xxx()…’，有的函數不太重要，希望打印出’[DEBUG] call xxx()…’，這時，log函數本身就需要傳入’INFO’或’DEBUG’這樣的參數，類似這樣： 123@log('DEBUG')def my_func(): pass 把上面的定義翻譯成高階函數的調用，就是： 1my_func = log('DEBUG')(my_func) 上面的語句看上去還是比較繞，再展開一下： 12log_decorator = log('DEBUG')my_func = log_decorator(my_func) 上面的語句又相當於： 1234log_decorator = log('DEBUG')@log_decoratordef my_func(): pass 所以，帶參數的log函數首先返回一個decorator函數，再讓這個decorator函數接收my_func並返回新函數： 123456789101112def log(prefix): def log_decorator(f): def wrapper(*args, **kw): print '[%s] %s()...' % (prefix, f.__name__) return f(*args, **kw) return wrapper return log_decorator@log('DEBUG')def test(): passprint test() 執行結果： 12[DEBUG] test()...None 對於這種3層嵌套的decorator定義，你可以先把它拆開： 1234567891011# 標準decorator:def log_decorator(f): def wrapper(*args, **kw): print '[%s] %s()...' % (prefix, f.__name__) return f(*args, **kw) return wrapperreturn log_decorator# 返回decorator:def log(prefix): return log_decorator(f) 拆開以後會發現，調用會失敗，因為在3層嵌套的decorator定義中，最內層的wrapper引用了最外層的參數prefix，所以，把一個閉包拆成普通的函數調用會比較困難。不支持閉包的編程語言要實現同樣的功能就需要更多的代碼。 python中完善decorator@decorator可以動態實現函數功能的增加，但是，經過@decorator“改造”後的函數，和原函數相比，除了功能多一點外，有沒有其它不同的地方？ 在沒有decorator的情況下，打印函數名： 123def f1(x): passprint f1.__name__ 輸出： f1 有decorator的情況下，再打印函數名： 123456789def log(f): def wrapper(*args, **kw): print 'call...' return f(*args, **kw) return wrapper@logdef f2(x): passprint f2.__name__ 輸出： wrapper 可見，由於decorator返回的新函數函數名已經不是&#39;f2&#39;，而是@log內部定義的&#39;wrapper&#39;。這對於那些依賴函數名的代碼就會失效。 decorator還改變了函數的__doc__等其它屬性。如果要讓調用者看不出一個函數經過了@decorator的“改造”，就需要把原函數的一些屬性複製到新函數中： 1234567def log(f): def wrapper(*args, **kw): print 'call...' return f(*args, **kw) wrapper.__name__ = f.__name__ wrapper.__doc__ = f.__doc__ return wrapper 這樣寫decorator很不方便，因為我們也很難把原函數的所有必要屬性都一個一個複製到新函數上，所以Python內置的functools可以用來自動化完成這個“複製”的任務： 1234567import functoolsdef log(f): @functools.wraps(f) def wrapper(*args, **kw): print 'call...' return f(*args, **kw) return wrapper 最後需要指出，由於我們把原函數簽名改成了(*args, **kw)，因此，無法獲得原函數的原始參數信息。即便我們採用固定參數來裝飾只有一個參數的函數： 123456def log(f): @functools.wraps(f) def wrapper(x): print 'call...' return f(x) return wrapper 也可能改變原函數的參數名，因為新函數的參數名始終是 &#39;x&#39;，原函數定義的參數名不一定叫 &#39;x&#39;。 python中偏函數當一個函數有很多參數時，調用者就需要提供多個參數。如果減少參數個數，就可以簡化調用者的負擔。 比如，int()函數可以把字符串轉換為整數，當僅傳入字符串時，int()函數默認按十進制轉換： 12&gt;&gt;&gt; int('12345')12345 但int()函數還提供額外的base參數，默認值為10。如果傳入base參數，就可以做N進制的轉換： 1234&gt;&gt;&gt; int('12345', base=8)5349&gt;&gt;&gt; int('12345', 16)74565 假設要轉換大量的二進製字符串，每次都傳入int(x, base=2)非常麻煩，於是，我們想到，可以定義一個int2()的函數，默認把base=2傳進去： 12def int2(x, base=2): return int(x, base) 這樣，我們轉換二進制就非常方便了： 1234&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 functools.partial就是幫助我們創建一個偏函數的，不需要我們自己定義int2()，可以直接使用下面的代碼創建一個新的函數int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 所以，functools.partial可以把一個參數多的函數變成一個參數少的新函數，少的參數需要在創建時指定默認值，這樣，新函數調用的難度就降低了。 模塊python之導入模塊要使用一個模塊，我們必須首先導入該模塊。 Python使用import語句導入一個模塊。例如，導入系統自帶的模塊math： 1import math 你可以認為math就是一個指向已導入模塊的變量，通過該變量，我們可以訪問math模塊中所定義的所有公開的函數、變量和類： 12345&gt;&gt;&gt; math.pow(2, 0.5) # pow是函數1.4142135623730951&gt;&gt;&gt; math.pi # pi是變量3.141592653589793 如果我們只希望導入用到的math模塊的某幾個函數，而不是所有函數，可以用下面的語句： 1from math import pow, sin, log 這樣，可以直接引用 pow, sin, log 這3個函數，但math的其他函數沒有導入進來： 1234&gt;&gt;&gt; pow(2, 10)1024.0&gt;&gt;&gt; sin(3.14)0.0015926529164868282 如果遇到名字衝突怎麼辦？比如math模塊有一個log函數，logging模塊也有一個log函數，如果同時使用，如何解決名字衝突？ 如果使用import導入模塊名，由於必須通過模塊名引用函數名，因此不存在衝突： 123import math, loggingprint math.log(10) # 調用的是math的log函數logging.log(10, 'something') # 調用的是logging的log函數 如果使用from...import導入log函數，勢必引起衝突。這時，可以給函數起個“別名”來避免衝突： 1234from math import logfrom logging import log as logger # logging的log現在變成了loggerprint log(10) # 調用的是math的loglogger(10, 'import from logging') # 調用的是logging的log python中動態導入模塊如果導入的模塊不存在，Python解釋器會報ImportError錯誤： 1234&gt;&gt;&gt; import somethingTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ImportError: No module named something 有的時候，兩個不同的模塊提供了相同的功能，比如 StringIO 和cStringIO都提供了StringIO這個功能。 這是因為Python是動態語言，解釋執行，因此Python代碼運行速度慢。 如果要提高Python代碼的運行速度，最簡單的方法是把某些關鍵函數用C語言重寫，這樣就能大大提高執行速度。 同樣的功能，StringIO是純Python代碼編寫的，而cStringIO部分函數是 C寫的，因此 cStringIO 運行速度更快。 利用ImportError錯誤，我們經常在Python中動態導入模塊： 1234try: from cStringIO import StringIOexcept ImportError: from StringIO import StringIO 上述代碼先嘗試從cStringIO導入，如果失敗了（比如cStringIO沒有被安裝），再嘗試從StringIO導入。這樣，如果cStringIO模塊存在，則我們將獲得更快的運行速度，如果cStringIO不存在，則頂多代碼運行速度會變慢，但不會影響代碼的正常執行。 try 的作用是捕獲錯誤，並在捕獲到指定錯誤時執行 except 語句。 python之使用futurePython的新版本會引入新的功能，但是，實際上這些功能在上一個老版本中就已經存在了。要“試用”某一新的特性，就可以通過導入__future__模塊的某些功能來實現。 例如，Python 2.7的整數除法運算結果仍是整數： 12&gt;&gt;&gt; 10 / 33 但是，Python 3.x已經改進了整數的除法運算，“/”除將得到浮點數，“//”除才仍是整數： 1234&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33 要在Python 2.7中引入3.x的除法規則，導入__future__的division： 123&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; print 10 / 33.3333333333333335 當新版本的一個特性與舊版本不兼容時，該特性將會在舊版本中添加到``future``中，以便舊的代碼能在舊版本中測試新特性。 python之安裝第三方模塊 pip安裝 參考 物件導向編程基礎python之定義類並創建實例在Python中，類通過class關鍵字定義。以Person為例，定義一個Person類如下： 12class Person(object): pass 按照 Python 的編程習慣，類名以大寫字母開頭，緊接著是(object)，表示該類是從哪個類繼承下來的。類的繼承將在後面的章節講解，現在我們只需要簡單地從object類繼承。 有了Person類的定義，就可以創建出具體的xiaoming、xiaohong等實例。創建實例使用 類名+()，類似函數調用的形式創建： 12xiaoming = Person()xiaohong = Person() python中創建實例屬性雖然可以通過Person類創建出xiaoming、xiaohong等實例，但是這些實例看上除了地址不同外，沒有什麼其他不同。在現實世界中，區分xiaoming、xiaohong要依靠他們各自的名字、性別、生日等屬性。 如何讓每個實例擁有各自不同的屬性？由於Python是動態語言，對每一個實例，都可以直接給他們的屬性賦值，例如，給xiaoming這個實例加上name、gender和birth屬性： 1234xiaoming = Person()xiaoming.name = 'Xiao Ming'xiaoming.gender = 'Male'xiaoming.birth = '1990-1-1' 給xiaohong加上的屬性不一定要和xiaoming相同： 1234xiaohong = Person()xiaohong.name = 'Xiao Hong'xiaohong.school = 'No. 1 High School'xiaohong.grade = 2 實例的屬性可以像普通變量一樣進行操作： 1xiaohong.grade = xiaohong.grade + 1 python中初始化實例屬性雖然我們可以自由地給一個實例綁定各種屬性，但是，現實世界中，一種類型的實例應該擁有相同名字的屬性。例如，Person類應該在創建的時候就擁有name、gender和 birth屬性，怎麼辦？ 在定義 Person 類時，可以為Person類添加一個特殊的__init__()方法，當創建實例時，__init__()方法被自動調用，我們就能在此為每個實例都統一加上以下屬性： 12345class Person(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birth __init__() 方法的第一個參數必須是self（也可以用別的名字，但建議使用習慣用法），後續參數則可以自由指定，和定義函數沒有任何區別。 相應地，創建實例時，就必須要提供除self以外的參數： 12xiaoming = Person('Xiao Ming', 'Male', '1991-1-1')xiaohong = Person('Xiao Hong', 'Female', '1992-2-2') 有了__init__()方法，每個Person實例在創建時，都會有 name、gender 和birth這3個屬性，並且，被賦予不同的屬性值，訪問屬性使用.操作符： 1234print xiaoming.name# 輸出 'Xiao Ming'print xiaohong.birth# 輸出 '1992-2-2' 要特別注意的是，初學者定義__init__()方法常常忘記了 self參數： 12345678&gt;&gt;&gt; class Person(object):... def __init__(name, gender, birth):... pass...&gt;&gt;&gt; xiaoming = Person('Xiao Ming', 'Male', '1990-1-1')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: __init__() takes exactly 3 arguments (4 given) 這會導致創建失敗或運行不正常，因為第一個參數name被Python解釋器傳入了實例的引用，從而導致整個方法的調用參數位置全部沒有對上。 python中訪問限制我們可以給一個實例綁定很多屬性，如果有些屬性不希望被外部訪問到怎麼辦？ Python對屬性權限的控制是通過屬性名來實現的，如果一個屬性由雙下底線開頭(__)，該屬性就無法被外部訪問。看例子： 123456789101112131415class Person(object): def __init__(self, name): self.name = name self._title = 'Mr' self.__job = 'Student'p = Person('Bob')print p.name# =&gt; Bobprint p._title# =&gt; Mrprint p.__job# =&gt; ErrorTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Person' object has no attribute '__job' 可見，只有以雙下底線開頭的”__job“不能直接被外部訪問。 但是，如果一個屬性以”__xxx__“的形式定義，那它又可以被外部訪問了，以”__xxx__“定義的屬性在Python的類中被稱為特殊屬性，有很多預定義的特殊屬性可以使用，通常我們不要把普通屬性用”__xxx__“定義。 以單下底線開頭的屬性”_xxx“雖然也可以被外部訪問，但是，按照習慣，他們不應該被外部訪問。 python中創建類屬性類是模板，而實例則是根據類創建的對象。 綁定在一個實例上的屬性不會影響其他實例，但是，類本身也是一個對象，如果在類上綁定一個屬性，則所有實例都可以訪問類的屬性，並且，所有實例訪問的類屬性都是同一個！也就是說，實例屬性每個實例各自擁有，互相獨立，而類屬性有且只有一份。 定義類屬性可以直接在class中定義： 1234class Person(object): address = 'Earth' def __init__(self, name): self.name = name 因為類屬性是直接綁定在類上的，所以，訪問類屬性不需要創建實例，就可以直接訪問： 12print Person.address# =&gt; Earth 對一個實例調用類的屬性也是可以訪問的，所有實例都可以訪問到它所屬的類的屬性： 123456p1 = Person('Bob')p2 = Person('Alice')print p1.address# =&gt; Earthprint p2.address# =&gt; Earth 由於Python是動態語言，類屬性也是可以動態添加和修改的： 12345Person.address = 'China'print p1.address# =&gt; 'China'print p2.address# =&gt; 'China' 因為類屬性只有一份，所以，當Person類的address改變時，所有實例訪問到的類屬性都改變了。 python中類屬性和實例屬性名字衝突怎麼辦修改類屬性會導致所有實例訪問到的類屬性全部都受影響，但是，如果在實例變量上修改類屬性會發生什麼問題呢？ 123456789101112131415class Person(object): address = 'Earth' def __init__(self, name): self.name = namep1 = Person('Bob')p2 = Person('Alice')print 'Person.address = ' + Person.addressp1.address = 'China'print 'p1.address = ' + p1.addressprint 'Person.address = ' + Person.addressprint 'p2.address = ' + p2.address 結果如下： 1234Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth 我們發現，在設置了p1.address = &#39;China&#39;後，p1訪問 address 確實變成了 ‘China’，但是，Person.address和p2.address仍然是’Earch’，怎麼回事？ 原因是p1.address = &#39;China&#39;並沒有改變Person 的address，而是給p1這個實例綁定了實例屬性address ，對p1來說，它有一個實例屬性address（值是’China’），而它所屬的類Person也有一個類屬性address，所以: 訪問 p1.address 時，優先查找實例屬性，返回’China’。 訪問 p2.address 時，p2沒有實例屬性address，但是有類屬性address，因此返回’Earth’。 可見，當實例屬性和類屬性重名時，實例屬性優先級高，它將屏蔽掉對類屬性的訪問。 當我們把 p1 的 address 實例屬性刪除後，訪問 p1.address 就又返回類屬性的值 ‘Earth’了： 123del p1.addressprint p1.address# =&gt; Earth 可見，千萬不要在實例上修改類屬性，它實際上並沒有修改類屬性，而是給實例綁定了一個實例屬性。 python中定義實例方法一個實例的私有屬性就是以__開頭的屬性，無法被外部訪問，那這些屬性定義有什麼用？ 雖然私有屬性無法從外部訪問，但是，從類的內部是可以訪問的。除了可以定義實例的屬性外，還可以定義實例的方法。 實例的方法就是在類中定義的函數，它的第一個參數永遠是self，指向調用該方法的實例本身，其他參數和一個普通函數是完全一樣的： 1234567class Person(object): def __init__(self, name): self.__name = name def get_name(self): return self.__name get_name(self)就是一個實例方法，它的第一個參數是self。__init__(self, name)其實也可看做是一個特殊的實例方法。 調用實例方法必須在實例上調用： 123p1 = Person('Bob')print p1.get_name() # self不需要顯式傳入# =&gt; Bob 在實例方法內部，可以訪問所有實例屬性，這樣，如果外部需要訪問私有屬性，可以通過方法調用獲得，這種數據封裝的形式除了能保護內部數據一致性外，還可以簡化外部調用的難度。 python中方法也是屬性我們在class中定義的實例方法其實也是屬性，它實際上是一個函數對象： 123456789101112class Person(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): return 'A'p1 = Person('Bob', 90)print p1.get_grade# =&gt; &lt;bound method Person.get_grade of &lt;__main__.Person object at 0x109e58510&gt;&gt;print p1.get_grade()# =&gt; A 也就是說，p1.get_grade返回的是一個函數對象，但這個函數是一個綁定到實例的函數，p1.get_grade() 才是方法調用。 因為方法也是一個屬性，所以，它也可以動態地添加到實例上，只是需要用 types.MethodType()把一個函數變為一個方法： 123456789101112131415161718192021import typesdef fn_get_grade(self): if self.score &gt;= 80: return 'A' if self.score &gt;= 60: return 'B' return 'C'class Person(object): def __init__(self, name, score): self.name = name self.score = scorep1 = Person('Bob', 90)p1.get_grade = types.MethodType(fn_get_grade, p1, Person)print p1.get_grade()# =&gt; Ap2 = Person('Alice', 65)print p2.get_grade()# ERROR: AttributeError: 'Person' object has no attribute 'get_grade'# 因為p2實例並沒有綁定get_grade 給一個實例動態添加方法並不常見，直接在class中定義要更直觀。 python中定義類方法和屬性類似，方法也分實例方法和類方法。 在class中定義的全部是實例方法，實例方法第一個參數self是實例本身。 要在class中定義類方法，需要這麼寫： 123456789101112class Person(object): count = 0 @classmethod def how_many(cls): return cls.count def __init__(self, name): self.name = name Person.count = Person.count + 1print Person.how_many()p1 = Person('Bob')print Person.how_many() 通過標記一個 @classmethod，該方法將綁定到Person類上，而非類的實例。類方法的第一個參數將傳入類本身，通常將參數名命名為cls，上面的 cls.count實際上相當於Person.count。 因為是在類上調用，而非實例上調用，因此類方法無法獲得任何實例變量，只能獲得類的引用。 類的繼承python中繼承一個類如果已經定義了Person類，需要定義新的Student和Teacher類時，可以直接從Person類繼承： 1234class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender 定義Student類時，只需要把額外的屬性加上，例如score： 1234class Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score 一定要用super(Student, self).__init__(name, gender)去初始化父類，否則，繼承自Person 的 Student將沒有name和gender。 函數super(Student, self)將返回當前類繼承的父類，即Person ，然後調用__init__()方法，注意self參數已在super()中傳入，在__init__()中將隱式傳遞，不需要寫出（也不能寫）。 python中判斷類型函數isinstance()可以判斷一個變量的類型，既可以用在Python內置的數據類型如str、list、dict，也可以用在我們自定義的類，它們本質上都是數據類型。 假設有如下的Person、Student和Teacher 的定義及繼承關係如下： 123456789101112131415161718class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = scoreclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = coursep = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English') 當我們拿到變量 p、s、t 時，可以使用 isinstance判斷類型： 123456&gt;&gt;&gt; isinstance(p, Person)True # p是Person類型&gt;&gt;&gt; isinstance(p, Student)False # p不是Student類型&gt;&gt;&gt; isinstance(p, Teacher)False # p不是Teacher類型 這說明在繼承鏈上，一個父類的實例不能是子類類型，因為子類比父類多了一些屬性和方法。 我們再考察s ： 123456&gt;&gt;&gt; isinstance(s, Person)True # s是Person類型&gt;&gt;&gt; isinstance(s, Student)True # s是Student類型&gt;&gt;&gt; isinstance(s, Teacher)False # s不是Teacher類型 s 是Student類型，不是Teacher類型，這很容易理解。但是，s 也是Person類型，因為Student繼承自Person，雖然它比Person多了一些屬性和方法，但是，把s看成Person的實例也是可以的。 這說明在一條繼承鏈上，一個實例可以看成它本身的類型，也可以看成它父類的類型。 python中多態類具有繼承關係，並且子類類型可以向上轉型看做父類類型，如果我們從 Person派生出 Student和Teacher，並都寫了一個 whoAmI() 方法： 1234567891011121314151617181920class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def whoAmI(self): return 'I am a Person, my name is %s' % self.nameclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return 'I am a Student, my name is %s' % self.nameclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = course def whoAmI(self): return 'I am a Teacher, my name is %s' % self.name 在一個函數中，如果我們接收一個變量x，則無論該x是Person、Student還是Teacher，都可以正確打印出結果： 12345678910def who_am_i(x): print x.whoAmI()p = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English')who_am_i(p)who_am_i(s)who_am_i(t) 運行結果：123I am a Person, my name is TimI am a Student, my name is BobI am a Teacher, my name is Alice 這種行為稱為多態。也就是說，方法調用將作用在x 的實際類型上。s 是Student類型，它實際上擁有自己的whoAmI()方法以及從Person繼承的whoAmI方法，但調用s.whoAmI()總是先查找它自身的定義，如果沒有定義，則順著繼承鏈向上查找，直到在某個父類中找到為止。 由於Python是動態語言，所以，傳遞給函數who_am_i(x)的參數 x 不一定是 Person 或 Person 的子類型。任何數據類型的實例都可以，只要它有一個whoAmI()的方法即可： 123class Book(object): def whoAmI(self): return 'I am a book' 這是動態語言和靜態語言（例如Java）最大的差別之一。動態語言調用實例方法，不檢查類型，只要方法存在，參數正確，就可以調用。 python中多重繼承除了從一個父類繼承外，Python允許從多個父類繼承，稱為多重繼承。 多重繼承的繼承鏈就不是一棵樹了，它像這樣： 12345678910111213141516171819class A(object): def __init__(self, a): print 'init A..​​.' self.a = aclass B(A): def __init__(self, a): super(B, self).__init__(a) print 'init B...'class C(A): def __init__(self, a): super(C, self).__init__(a) print 'init C...'class D(B, C): def __init__(self, a): super(D, self).__init__(a) print 'init D...' 看下圖: 像這樣，D同時繼承自 B和C，也就是D擁有了A、B、C的全部功能。多重繼承通過super()調用__init__()方法時，A雖然被繼承了兩次，但__init__()只調用一次： 12345&gt;&gt;&gt; d = D('d')init A..​​.init C...init B...init D... 多重繼承的目的是從兩種繼承樹中分別選擇並繼承出子類，以便組合功能使用。 舉個例子，Python的網絡服務器有TCPServer、UDPServer、UnixStreamServer、UnixDatagramServer，而服務器運行模式有 多進程ForkingMixin和多線程ThreadingMixin兩種。 要創建多進程模式的TCPServer： 12class MyTCPServer(TCPServer, ForkingMixin) pass 要創建多線程模式的 UDPServer： 12class MyUDPServer(UDPServer, ThreadingMixin): pass 如果沒有多重繼承，要實現上述所有可能的組合需要 4x2=8 個子類。 python中獲取對象信息拿到一個變量，除了用 isinstance()判斷它是否是某種類型的實例外，還有沒有別的方法獲取到更多的信息呢？ 例如，已有定義： 1234567891011class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return 'I am a Student, my name is %s' % self.name 首先可以用type()函數獲取變量的類型，它返回一個Type對象： 12345&gt;&gt;&gt; type(123)&lt;type 'int'&gt;&gt;&gt;&gt; s = Student('Bob', 'Male', 88)&gt;&gt;&gt; type(s)&lt;class '__main__.Student'&gt; 其次，可以用dir()函數獲取變量的所有屬性： 12345&gt;&gt;&gt; dir(123) # 整數也有很多屬性...['__abs__', '__add__', '__and__', '__class__', '__cmp__', ...]&gt;&gt;&gt; dir(s)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', ' __repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'gender', 'name', 'score', 'whoAmI'] 對於實例變量，dir()返回所有實例屬性，包括__class__這類有特殊意義的屬性。注意到方法whoAmI也是s的一個屬性。 如何去掉__xxx__這類的特殊屬性，只保留我們自己定義的屬性？回顧一下filter()函數的用法。 dir()返回的屬性是字符串列表，如果已知一個屬性名稱，要獲取或者設置對象的屬性，就需要用getattr()和setattr( )函數了： 123456789101112131415&gt;&gt;&gt; getattr(s, 'name') # 獲取name屬性'Bob'&gt;&gt;&gt; setattr(s, 'name', 'Adam') # 設置新的name屬性&gt;&gt;&gt; s.name'Adam'&gt;&gt;&gt; getattr(s, 'age') # 獲取age屬性，但是屬性不存在，報錯：Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age'&gt;&gt;&gt; getattr(s, 'age', 20) # 獲取age屬性，如果屬性不存在，就返回默認值20：20 定製類一部分特殊方法 python中str和repr如果要把一個類的實例變成str，就需要實現特殊方法__str__()： 123456class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __str__(self): return '(Person: %s, %s)' % (self.name, self.gender) 現在，在交互式命令行下用print試試： 123&gt;&gt;&gt; p = Person('Bob', 'male')&gt;&gt;&gt; print p(Person: Bob, male) 但是，如果直接敲變量p： 12&gt;&gt;&gt; p&lt;main.Person object at 0x10c941890&gt; 似乎__str__() 不會被調用。 因為 Python 定義了__str__()和__repr__()兩種方法，__str__()用於顯示給用戶，而__repr__()用於顯示給開發人員。 有一個偷懶的定義__repr__的方法： 1234567class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __str__(self): return '(Person: %s, %s)' % (self.name, self.gender) __repr__ = __str__ python中cmp對int、str 等內置數據類型排序時，Python的sorted() 按照默認的比較函數cmp排序，但是，如果對一組Student ` `類的實例排序時，就必須提供我們自己的特殊方法cmp()``： 123456789101112131415class Student(object): def __init__(self, name, score): self.name = name self.score = score def __str__(self): return '(%s: %s)' % (self.name, self.score) __repr__ = __str__ def __cmp__(self, s): if self.name &lt; s.name: return -1 elif self.name &gt; s.name: return 1 else: return 0 上述Student 類實現了cmp()方法，__cmp__用實例自身self和傳入的實例s進行比較，如果self 應該排在前面，就返回-1，如果s應該排在前面，就返回1，如果兩者相當，返回0。 Student類實現了按name進行排序： 123&gt;&gt;&gt; L = [Student('Tim', 99), Student('Bob', 88), Student('Alice', 77)]&gt;&gt;&gt; print sorted(L)[(Alice: 77), (Bob: 88), (Tim: 99)] 注意: 如果list不僅僅包含 Student 類，則cmp 可能會報錯： 12L = [Student('Tim', 99), Student('Bob', 88), 100, 'Hello']print sorted(L) 請思考如何解決。 python中len如果一個類表現得像一個list，要獲取有多少個元素，就得用 len() 函數。 要讓len() 函數工作正常，類必須提供一個特殊方法__len__()，它返回元素的個數。 例如，我們寫一個 Students 類，把名字傳進去： 12345class Students(object): def __init__(self, *args): self.names = args def __len__(self): return len(self.names) 只要正確實現了len()方法，就可以用len()函數返回Students實例的“長度”： 123&gt;&gt;&gt; ss = Students('Bob', 'Alice', 'Tim')&gt;&gt;&gt; print len(ss)3 python中數學運算Python 提供的基本數據類型 int、float 可以做整數和浮點的四則運算以及乘方等運算。 但是，四則運算不局限於int和float，還可以是有理數、矩陣等。 要表示有理數，可以用一個Rational類來表示： 1234class Rational(object): def __init__(self, p, q): self.p = p self.q = q p、q 都是整數，表示有理數 p/q。 如果要讓Rational進行+運算，需要正確實現add： 123456789class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __add__(self, r): return Rational(self.p * r.q + self.q * r.p, self.q * r.q) def __str__(self): return '%s/%s' % (self.p, self.q) __repr__ = __str__ 現在可以試試有理數加法： 1234&gt;&gt;&gt; r1 = Rational(1, 3)&gt;&gt;&gt; r2 = Rational(1, 2)&gt;&gt;&gt; print r1 + r25/6 python中類型轉換Rational類實現了有理數運算，但是，如果要把結果轉為int或float怎麼辦？ 考察整數和浮點數的轉換： 1234&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float(12)12.0 如果要把 Rational 轉為 int，應該使用： 12r = Rational(12, 5)n = int(r) 要讓int()函數正常工作，只需要實現特殊方法__int__(): 123456class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __int__(self): return self.p // self.q 結果如下： 1234&gt;&gt;&gt; print int(Rational(7, 2))3&gt;&gt;&gt; print int(Rational(1, 3))0 同理，要讓float()函數正常工作，只需要實現特殊方法float()。 python中@property考察Student類： 1234class Student(object): def __init__(self, name, score): self.name = name self.score = score 當我們想要修改一個 Student 的 scroe 屬性時，可以這麼寫： 12s = Student('Bob', 59)s.score = 60 但是也可以這麼寫： 1s.score = 1000 顯然，直接給屬性賦值無法檢查分數的有效性。 如果利用兩個方法： 12345678910class Student(object): def __init__(self, name, score): self.name = name self.__score = score def get_score(self): return self.__score def set_score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError('invalid score') self.__score = score 這樣一來，s.set_score(1000)就會報錯。 這種使用get/set 方法來封裝對一個屬性的訪問在許多面向對象編程的語言中都很常見。 但是寫s.get_score()和s.set_score()沒有直接寫s.score來得直接。 有沒有兩全其美的方法？ —-有。 因為Python支持高階函數，在函數式編程中我們介紹了裝飾器函數，可以用裝飾器函數把get/set方法“裝飾”成屬性調用： 123456789101112class Student(object): def __init__(self, name, score): self.name = name self.__score = score @property def score(self): return self.__score @score.setter def score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError('invalid score') self.__score = score 注意: 第一個score(self)是get方法，用@property裝飾，第二個score(self, score)是set方法，用@score.setter裝飾，@score.setter是前一個@property裝飾後的副產品。 現在，就可以像使用屬性一樣設置score了： 12345678&gt;&gt;&gt; s = Student('Bob', 59)&gt;&gt;&gt; s.score = 60&gt;&gt;&gt; print s.score60&gt;&gt;&gt; s.score = 1000Traceback (most recent call last): ...ValueError: invalid score 說明對 score 賦值實際調用的是 set方法。 python中slots由於Python是動態語言，任何實例在運行期都可以動態地添加屬性。 如果要限制添加的屬性，例如，Student類只允許添加name、gender和score這3個屬性，就可以利用Python的一個特殊的__slots__來實現。 顧名思義，__slots__是指一個類允許的屬性列表： 123456class Student(object): __slots__ = ('name', 'gender', 'score') def __init__(self, name, gender, score): self.name = name self.gender = gender self.score = score 現在，對實例進行操作： 1234567&gt;&gt;&gt; s = Student('Bob', 'male', 59)&gt;&gt;&gt; s.name = 'Tim' # OK&gt;&gt;&gt; s.score = 99 # OK&gt;&gt;&gt; s.grade = 'A'Traceback (most recent call last): ...AttributeError: 'Student' object has no attribute 'grade' __slots__的目的是限制當前類所能擁有的屬性，如果不需要添加任意動態的屬性，使用__slots__也能節省內存。 python中call在Python中，函數其實是一個對象： 12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__'abs'&gt;&gt;&gt; f(-123)123 由於 f 可以被調用，所以，f 被稱為可調用對象。 所有的函數都是可調用對象。 一個類實例也可以變成一個可調用對象，只需要實現一個特殊方法__call__()。 我們把Person類變成一個可調用對象： 12345678class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __call__(self, friend): print 'My name is %s...' % self.name print 'My friend is %s...' % friend 現在可以對 Person 實例直接調用： 1234&gt;&gt;&gt; p = Person('Bob', 'male')&gt;&gt;&gt; p('Tim')My name is Bob...My friend is Tim... 單看 p(&#39;Tim&#39;) 你無法確定p是一個函數還是一個類實例，所以，在Python中，函數也是對象，對象和函數的區別並不顯著。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將excel-讀到JAVA上]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87excel-%E8%AE%80%E5%88%B0JAVA%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[使用 jxl 把Excel讀取到java 上一篇 把資料寫入到Excel 這篇就順便將讀取到java補上了說明都打在註解上了!!就不在多做說明了 java123456789101112131415161718192021222324252627282930313233343536373839404142package excel;import java.io.File;import java.io.IOException;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;import jxl.read.biff.BiffException;public class ReadExcel&#123; //JXL讀取EXCEL public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //建立 workbook Workbook workbook = Workbook.getWorkbook(new File("C:/jxl_test.xls")); //得到第一個工作表 Sheet sheet = workbook.getSheet(0); //取得資料 for (int i = 0; i &lt; sheet.getRows(); i++) //行 &#123; for (int j = 0; j &lt; sheet.getColumns(); j++)//列 &#123; Cell cell= sheet.getCell(j,i); System.out.print(cell.getContents()+" "); &#125; System.out.println(); //換行 &#125; workbook.close(); //將workbook關閉 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將java資料導入excel]]></title>
      <url>%2F2017%2F03%2F27%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87java%E8%B3%87%E6%96%99%E5%B0%8E%E5%85%A5excel%2F</url>
      <content type="text"><![CDATA[使用java_將資料導入excel 最近在把公司舊的ERP HR系統 移植出來必須要用最快的方式移植出來不然我本來的專案會趕不上進度順便找時間記錄一下最近開發紀錄 excel 幾種實現方式!POI poi 是 apache poi開放源碼函式庫提供java對 Microsoft office 格式檔案讀寫功能通過HSSF可以使用純JAVA代碼來讀取 寫入 修改EXCELHSSF -讀寫Microsoft Excel格式檔案功能(只支援97-2003)XSSF -讀寫Microsoft Excel OOXML格式檔案功能HWPF -讀寫讀寫Microsoft Word格式檔案功能HSLF -讀寫讀寫Microsoft PowerPoint格式檔案功能HDGF -讀寫讀寫Microsoft Visio格式檔案功能-iText 可以通過iText 來建立PDF 只需在classpath加入iText.jar JXL 有興趣的在去查一下 FASTEXCEL 是一個採用純java 開發的excel文件讀寫組件 支持Excel 97-2003fastExcel 只能讀取單元格的字串資料其他屬性 像是顏色 字體就不支持 但也因為這樣FastExcel 需要用到的記憶體很少 JXL java excel 可以讀取Excel文件內容 建立excel文件 更新已存在的excel POI JXK 比較 效率高 功能強大使用上比較複雜 支持公式 圖表 能夠修改單元屬性格 支持字體 數字 日期操作 JXL 效率低 操作簡單 部分支援 能夠修改單元格屬性 但不比POI強大 支援字體 數字 日期 使用JXL程式碼實例 程式都註解上去了!由於時間的關係需要快速的去開發就嘗試幾個方法開發 需要更快速的來去完成工作才是目標所以選擇使用 JXL 有空再把POI程式碼貼上來 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package excel;import java.awt.Label;import java.io.File;import java.io.IOException;import jxl.Workbook;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class excel&#123; //jxl 建立 excel public static void main(String[] args) &#123; String[] title = &#123;"id","name","sex"&#125;; //建立文件 File file = new File("C:/jxl_test.xls"); try &#123; file.createNewFile(); //建立 工作簿 WritableWorkbook workbook = Workbook.createWorkbook(file); //建立 Sheet WritableSheet sheet = workbook.createSheet("sheet1", 0); jxl.write.Label label=null; for (int i = 0; i &lt; title.length; i++) &#123; //第一行 設定列名 label = new jxl.write.Label(i, 0, title[i]); sheet.addCell(label); &#125; //增加資料 for (int i = 1; i &lt; 10; i++) &#123; label = new jxl.write.Label(0, i, "a"+1); sheet.addCell(label); label = new jxl.write.Label(1, i, "user"+1); sheet.addCell(label); label = new jxl.write.Label(2, i, "男"+1); sheet.addCell(label); &#125; //寫入 workbook.write(); //關閉 workbook.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果圖 ``` JXL.jar 下載點分享 JXL.jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[work]]></title>
      <url>%2F2017%2F03%2F25%2Fwork%2F</url>
      <content type="text"><![CDATA[about Language java(Spring Boot) python(Flask) flutter (Bloc) labview APP flutter WEB java flutter WEB 後端 flask restAPI (JWT) sqlalchemy SQL MSSQL MYSQL PostgreSQL 雲端 firebase AWS 推播 FCM flutter web體溫量測 開發環境 flutter 後端python tableau wdc 可視化 MQTT自動化搬運車 開發環境 flutter 後端python esp32 arduino 生產過帳 開發環境 flutter 後端python tableau可視化 appFlutter 跨平台 IOS/Android 1日文學習APP 開發環境 flutter 後端python 畫面 Android-OEE 工廠24H生產,每個生產設備要確實的自己的產能預估產能,與每日實際產能的落差紀錄產品良率/不良率,流水號追朔不良率產品,了解當下生產相關資訊業務去接單的時候,有著生產資料準確的產能來與客戶溝通,也可以改善工廠的生產效率。 前言 前端java 後端python flask-restAPI 介面 流程 工廠辦公室的人會將要生產的料號與生產的模具等等的資料輸入電腦端的程式 每個模具每日的產能都不一樣，這會在下班的時候來去計算預估生產值，與實際生產值 電腦端程式可以看到每日報表，當前生產狀況。 手機點擊，電腦標籤列印等比較有空的時候在整理新增上來 工廠端在電腦端的程式輸入&gt;OP每天上班點擊平板上要生產的料號&gt;每一樣產品正常或不良都需點擊平版記錄&gt;QC檢驗也會在電腦端輸入檢驗成果與流水號 android使用懸浮窗體製作腳本前言 開發環境 java 有時候玩遊戲 或是需要一直持續重複動作的事情太浪費時間了所以做了一個腳本使用ADB來讓他自動完成一些事情 畫面 實際RUN的過程就不演示了 也可將UI顯示成多個格子來顯示距離 來計算每個距離需要點擊多久前陣子微信的小遊戲跳一跳 也可以用這方法來實現 來得到滿分 中國手機有些廠家也有使用懸浮窗體的方式結合OCR 來將圖像辨識 選擇區域後會將文字大爆炸顯示出來讓你複製等等之類的功能 WEB(Vaadin/GWT)vaadin 響應式即時看板(1) 撈取公司MES的生產資料 自動化設備 將資料圖表化 顯示即時看板 網頁端 手機端 vaadin 響應式即時看板(2) 有些可視化使用tabelau 有一些使用自行開發的看板接收設備的即時狀況 與設備生產狀態 與生產資料可視化可視化部份給使用者自行設定 警戒線 網頁端 javaFX JNI包裝MES 協助列印後段包裝標籤連結ERP 提供人員內部出現問題 反查生產時間與相關批號的產品流向標籤只用JNI 調用dll列印 Swingjava swing -教育訓練程式(第二版)前言&gt;本來仿製公司舊ERP做的教育訓練程式發現實在很不好用 決定重新開發一個使用流程建立課程&gt;講師課程邀請&gt;發送mail課程邀請信&gt;講師評分 課程建立 課程邀請 Mail回覆是否要上課 這邊有一個server 來判斷 使用這點入 確定後 所回傳url值 來去判斷使用者 將資料寫入資料庫講師評分 課程講義上傳 由於會不知道有幾個人上課 這邊的Button 是使用checkBox來去監聽按鈕狀況 java swing tiptop 財務報表(一)前言&gt;在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面 java swing tiptop 財務資料與別廠區資料比對前言&gt;由於財務每次都需要去tiptop很多個地方抓資料然後記錄在EXCEL與客戶提供的收發或明細核對也需要與客戶的財務 金額比對 花了非常多時間在做件事情時常人工比對 容易出錯誤就來幫忙財務 減輕一下工作量資料是這樣的內銷 訂單&gt;出通單&gt;出貨單 &gt;發票號碼&gt;金額外銷 訂單&gt;出通單&gt;invoice&gt;金額 程式主畫面 java swing BOM查詢系統前言 版權聲明：轉載請保留原文連結及作者這個小程式主要用途在於讓資材key上料號把bom展出來 有替代料的點下右鍵會在下方出現替代料比較麻煩的部分是 一階BOM展開二階時候二階*上1階的數量這樣才對 程式主畫面 java-swing-tiptop 採購單價查詢前言&gt;有時候不得不說Tiptop有些地方真的很爛走分量計價的單價查詢要一筆一筆查..如果有舊單價要看或是要看本來單價多少 現在單價多少 真的很不好查所以就幫公司開發一個方便的查詢工具 程式主畫面 java-swing-tiptop 調撥清單前言&gt;這個程式主要是讓庫房查詢調撥多少庫存去外面例如!pchome倉 可以方便查詢調撥多少庫存出去 程式主畫面 java-Swing-tiptop 財務報表(三)前言 版權聲明：轉載請保留原文連結及作者在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面 java-Swing-tiptop 財務報表(二)前言 版權聲明：轉載請保留原文連結及作者在一陣子應該就可以把公司將各部門常常浪費時間做的事情 用程式來簡化Toptop財務每次要看報表 都要去兩個地方看所以就幫助 財務 撈取他想要看的欄位的報表如果有想要知道oracle 語法的話 可在寫信或留言通知我 程式主畫面 java swing tiptop內銷應收小程式程式主畫面 查詢未開立出通單的訂單 table 欄位名稱 table 欄位名稱如下結案碼訂單日期業務代號地區代碼客戶名稱客戶代碼產品規格系列機種訂單料號訂單數量幣別單價銷售額(未稅)銷售額(含稅)已出貨數量已出貨金額鼎新訂單號碼鼎新出貨通知單客戶訂單號碼週別預計出貨日發票號碼發票日期預計付款日實際收款日財務備註出貨備註總出貨數量總出貨金額 程式介紹結案碼代表這張單有沒有收到錢了資料上方式可以類似Excel的篩選功能詳細之後在演示一下效果可以依照日期或是季度來篩選資料這些資料不是一次串出來的很多部分是使用程式來去搭配達成效果的由於對sql不是非常厲害 這要從訂單串到財務的單據驗證資料是否有重複正確性這部分花比較多時間在這上面 java-swing tiptop出貨排程小程式前言&gt;幫公司開發一個內銷應收程式後就順便開發一個出貨排程給倉庫使用主要是給倉庫看出貨排程也降低他們工作的負擔 程式主畫面 java swing 教育訓練小程式前言&gt;由於公司常常會有內部訓練與安排人員外部訓練課程寫這個的用意是要讓人員訓練可以做個紀錄 以便反查與訓練完畢是否可以當內部課程講師 程式主畫面 java swing tiptop異動數量查詢前言&gt;由於Tiptop裡面查看異動 沒有數量公司人員要反查單據與數量的時候要很多時間去查看來去找尋錯誤很浪費時間由於用4gl開發好花時間加上自己不是很熟還有其他專案時間的壓力就選擇都用java開發比較快 程式主畫面 Labview / NXGNXG 3.0 WEBVI IPQC巡檢 工廠許多自動化設備都使用LABVIEW開發練習使用NI 新的元件WEB VI 來替代現場人員手輸入excel表單拿著平板就可輸入 順便將資料寫入資料庫後端使用python Labview將自動化機台連網數據收集 使用Socket 為了建立可視化看板將公司一些labview自動化機台開發的軟體資料上拋到資料庫讓網頁的看板 與tableau使用 很多時候需要將設備的數據儲存起來 或是需要設備的資料可視化使用NI的IOBOX將設備的資料 傳入到自己寫的java Socket Labview labView 使用DAQ 將資料使用Tcpip 的方式 傳到對應的位置上皆可 實際運行效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-txt資料讀取存入SQL]]></title>
      <url>%2F2017%2F03%2F24%2Fjava-txt%E8%B3%87%E6%96%99%E8%AE%80%E5%8F%96%E5%AD%98%E5%85%A5SQL%2F</url>
      <content type="text"><![CDATA[java-txt資料讀取存入SQL前言 最近實在太忙了.沒什麼時間更新blog.本來打算寫專案過程可以抓時間學習python主管最近突然跟我說10天要把舊ERP的一個員工教育訓練的程式移植出來.由於舊ERP太爛了沒有用SQL..資料是儲存在txt..!!!就只好寫個程式來匯入 由於時間太趕了..就不太注重細節趕快把這寫出來如果是csv檔案的話稍微修改就可以用了! txt資料 “345”|”456”|”xxxx”|4|12/05/11|12/05/11|0|””|0|””|”name”|12/06/01先寫程式把資料的 “ | 這兩個符號先更改改完如下 #345#@#456#@#xxxx#@4@12/05/11@12/05/11@0@##@0@##@#name#@12/06/01 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import utils.sqlconnection;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Array;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class SQL extends sqlconnection&#123; public static void main(String[] args) &#123; try &#123; java.sql.Connection conn; try &#123; conn = DriverManager.getConnection(CONNURL, SQL_NAME,SQL_PASSWORD); PreparedStatement pstmt = conn.prepareStatement(SQL_INSERT); FileReader fr = new FileReader(FILE_PATH); BufferedReader brdFile = new BufferedReader(fr); String strLine = null; while ((strLine = brdFile.readLine()) != null) &#123; strLine = strLine.replace("#", "");//先將資料夾裡面的#改成"" String[] array = strLine.split("@");// 因為是用"@"分開所以用split切開存入字串陣列 System.out.println(strLine); for (int i = 0; i &lt; array.length; i++) &#123;// System.out.println(array[i]); 可以用來檢視分割的檔案是否正確 pstmt.setString(i+1,array[i]); &#125; pstmt.execute(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL語法紀錄]]></title>
      <url>%2F2017%2F03%2F05%2FSQL%E8%AA%9E%E6%B3%95%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[SQL語法紀錄前言一直以來只記得 select insert drop…每次要用都忘記..還是來記錄一下! 基礎語法 操作功能 SQL 語法 說明 建立資料庫 create database 資料庫名稱; 列出所有資料庫 show databases; 刪除資料庫 drop database 資料庫名稱; 使用資料庫 use 資料庫名稱; 建立資料表 create table 資料表名稱(&lt;br&gt;sn integer auto_increment primary key,&lt;br&gt;name char(20),&lt;br&gt;mail char(50),&lt;br&gt;home char(50),&lt;br&gt;messages char(50)); 常用資料庫資料型態 1. INT (整數) 2. CHAR (1~255字元字串) 3. VARCHAR (不超過255字元不定長度字串) 4. TEXT (不定長度字串最多65535字元) 列出資料表欄位資訊 describe 資料表名稱; 修改資料表欄位 alter table 資料表名稱&lt;br&gt;change column 原來欄位名稱&lt;br&gt;新欄位名稱資料型態; 新增資料表欄位 alter table 資料表名稱 add &lt;br&gt;column 欄位名稱 資料型態; 刪除資料表欄位 alter table 資料表名稱 drop column 欄位名稱; 刪除資料表 drop table 資料表名稱; 清空資料表 truncate table 資料表名稱; 只清除資料並保留結構、欄位、索引 … 插入欄位資料 insert into 資料表名稱(欄位1,欄位2,欄位3,欄位4, ...... 欄位N)&lt;br&gt;values(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;,&#39;值4&#39;, ...... &#39;值N&#39;); 更新修改欄位資料 update 資料表名稱 set 欄位1=&#39;值1&#39;,欄位2=&#39;值2&#39;,欄位3=&#39;值3&#39;,... &lt;br&gt;欄位N=&#39;值N&#39;where 條件式 (例如 sn=&#39;5&#39; 或 name=&#39;塔司尼&#39; ); 查詢單一欄位資料 select 欄位名 from 資料表名稱; 查詢多個欄位資料 select 欄位名, 欄位名, 欄位名 from 資料表名稱; 查詢欄位資料的唯一值 select distinct 欄位名 from 資料表名稱; 重複值只列一次 查詢所有欄位資料 select * from 資料表名稱; 條件式查詢 select * from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39;); （=, &lt;, &gt;, !=） 條件式查詢 and select * from 資料表名稱 where 條件式1 and 條件式2; 條件式查詢 or select * from 資料表名稱 where 條件式1 or 條件式2; 查詢某一範圍 between select * from 資料表名稱 where 欄位名 between 值1 and 值2; 值為數字 查詢空值欄位的資料 select * from 資料表名稱 where 欄位名 is null not null; 查詢特定筆數資料 select * from 資料表名稱 limit 8, 10; 第9筆開始選取10筆 查詢結果遞增排序 select * from 資料表名稱 order by 欄位名; 查詢結果遞減排序 select * from 資料表名稱 order by 欄位名 desc ; 查詢比對字串列出單一欄位 select 欄位名 from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 查詢比對字串列出所有欄位 select * from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 刪除條件值資料 delete from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39; 或 id=&#39;91001&#39; ); 刪除條件值資料 delete from 資料表名稱 where 條件式1 and 條件式2; 刪除條件值資料 delete from 資料表名稱 where 條件式1 or 條件式2; 比對刪除條件值資料 delete from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 一筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;; 兩筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;and xxxx=&#39;xxxx&#39;; 一筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39;; 兩筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39; and xxxx=&#39;xxxx&#39;; 進階語法 操作功能 SQL 語法 說明 查看正在執行的行程 show processlist; 查看 Master 狀態 show master status; 查看 Slave 狀態 show slave status\G; 查看 binlog 狀態 show binary logs; 清除過時的 binlog purge binary logs to &#39;mysql-bin.000006&#39;; 將刪除 mysql-bin.000001 ~ 5 的 binlog 參考資料 SQL常用參考資料1 SQL常用參考資料2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[詳細解讀DialogFragment]]></title>
      <url>%2F2017%2F01%2F20%2F%E8%A9%B3%E7%B4%B0%E8%A7%A3%E8%AE%80DialogFragment%2F</url>
      <content type="text"><![CDATA[DialogFragment 版權聲明：轉載請保留原文連結及作者http://www.cnblogs.com/tianzhijiexian/p/4161811.html 相信看這篇文章的人都應該知道android中的Dialog了吧Dialog詳解：http://www.cnblogs.com/tianzhijiexian/p/3867731.html隨著Fragment這個類的引入，Google官方推薦大家使用DialogFragment來代替傳統的Dialog，那麼是不是說我們之前學習的Dialog知識都沒有用處了呢？非也，新的fragment是來方便大家更好的管理和重用Dialog，之前的知識其實都是可以拿來就用的，僅僅需要少許的改變。 Dialog和DialogFragment的區別和優劣 新來的DialogFragment讓dialog也變成了碎片，相比之前來說應該做了很多優化和處理，對於程序員來看對話框現在更加具體了，就是一個activity上的一個fragment，我們也可以用fragment的知識來管理對話框了。我們看看之前是怎麼運用對話框對象的 1234AlertDialog dialog = new AlertDialog.Builder( this ) .setTitle( "Dialog" ) .setMessage( "thisis a dialog" ) .show(); 如果這個時候屏幕方向發生變化，就會導致Activity重建，然後之前顯示的對話框就不見了。查看log可以發現這個錯誤： 04-1917:30:06.999: E/WindowManager(14495): Activitycom.example.androidtest.MainActivity has leaked windowcom.android.internal.policy.impl.PhoneWindow$DecorView{42ca3c18 V.E…..R……. 0,0-1026,414} that was originally added here 當然我們也可以無視這個錯誤，因為程序不會因此崩潰（看來android本身就已經預料到這種情況了）。 如果我們想要在旋轉屏幕的時候也能保證這個對話框顯示就需要做一定的處理了，在activity要銷毀前設立一個標誌，看這時對話框是否是顯示狀態，如果是那麼activity在下次建立時直接顯示對話框。 在onSaveInstanceState中1234567@Override protected void onSaveInstanceState(Bundle outState) &#123; super .onSaveInstanceState(outState); if (dialog != null &amp;&amp; dialog.isShowing()) &#123; outState.putBoolean( "DIALOG_SHOWN", true ); &#125; &#125; 在onCreat中123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null ) &#123; boolean isShown = savedInstanceState.getBoolean("DIALOG_SHOWN" ); if (isShown) &#123; AlertDialog dialog = new AlertDialog.Builder( this ).setTitle("Dialog" ) .setMessage( "thisis a dialog" ).show(); &#125; &#125; ……&#125; 使用DialogFragment來管理對話框就不會有這種問題了，代碼也少了很多的邏輯處理。當你旋轉屏幕的時候，fragmentManager會自定管理DialogFragment的生命週期，如果當前已經顯示在屏幕上了，那麼旋轉屏幕後夜會自動顯示，下面就是在屏幕旋轉時的log輸出。12345678910111213141516171819202122234-1917:45:41.289: D/==========(16156): MyDialogFragment : onAttach04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreate04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:41.309: D/==========(16156): MyDialogFragment : onStart04-1917:45:50.619: D/==========(16156): MyDialogFragment : onStop04-1917:45:50.619: D/==========(16156): third activity on destroy04-1917:45:50.619:D/==========(16156): MyDialogFragment : onDestroyView04-1917:45:50.619: D/==========(16156): MyDialogFragment : onDetach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onAttach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onCreate04-1917:45:50.659: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:50.659: D/==========(16156): MyDialogFragment : onStart Ok，當然你可以不以為然，你說我的應用就是豎著用的，旋轉屏幕畢竟是小概率事件，誰會開著對話框旋轉來旋轉去啊。那麼相信下面的好處你一定不能否定吧。 我們之前用Dialog的時候，在activity中必須要建立這個對象，而且一般我們都是需要給它放監聽器的，比如下面的代碼： 12345678910111213141516171819202122@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.guid_main); new AlertDialog.Builder(GuideActivity. this ).setTitle("用戶申明" ) .setMessage(getResources().getString(R.string.statement)) .setPositiveButton( "我同意", new positiveListener()) .setNegativeButton( "不同意", new negativeListener()) .setCancelable( false ) .show(); &#125; private class positiveListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; prefs.setIsFirstTime( false ); &#125; &#125; private class negativeListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Util.virtualHome(GuideActivity. this ); &#125; &#125; 你會發現這麼長的代碼很破壞activity中的邏輯性，有木有！！！在activity中我們處理的各種控件的顯示和邏輯，但對於dialog這種不屬於activity並且建立和處理邏輯都自成一體的東西，我們為什麼要在activity中建立呢？而且為了方便重用，我們在實際過程中基本都會建立一個dialog的工具類來做處理，所以為什麼不用DialogFragment來實現呢？如果通過它來實現，我們就能很方便的進行管理對話框。 此外，當旋轉屏幕和按下後退鍵時可以更好的管理其聲明周期，它和Fragment有著基本一致的聲明周期。且DialogFragment也允許開發者把Dialog作為內嵌的組件進行重用，類似Fragment（可以在大屏幕和小屏幕顯示出不同的效果）。有可能我們在大屏幕上就不需要彈出一個對話框了，直接內嵌在activity界面中顯示即可。這點也很贊！ DialogFragment的最簡單用法使用DialogFragment很簡單，甚至比用Fragment還簡單，因為在api中已經實現了fragment切換對象了。 建立一個fragment對象123456789101112131415161718package com.kale.dialogfragmenttest;import android.app.DialogFragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup;public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); // tag which is from acitivity which started this fragment return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 我們建立了一個fragment，讓他繼承了DialogFragment，在onCreatView中通過佈局文件建立了一個view，這和fragment完全一致。 佈局文件如下： 1234567891011121314151617181920212223242526272829303132&lt;? xml version="1.0" encoding="utf-8" ?&gt;&lt; LinearLayout xmlns:android ="http://schemas.android.com/apk/res/android" android:layout_width ="match_parent" android:layout_height ="match_parent" android:orientation ="vertical" android:padding ="16dp" &gt; &lt; TextView android:id ="@+id/textView1" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Large Text" android:textAppearance ="?android:attr/textAppearanceLarge" /&gt; &lt; EditText android:layout_marginTop ="10dp" android:id ="@+id/editText1" android:layout_width ="match_parent" android:layout_height ="wrap_content" android:ems ="10" &gt; &lt; requestFocus /&gt; &lt;/ EditText &gt; &lt; Button android:id ="@+id/button1" android:layout_marginTop ="10dp" android:layout_gravity ="center_horizo​​ntal" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Button" /&gt;&lt;/ LinearLayout &gt; 在activity中啟用這個dialog12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new DialogFragmentTest() .show(getFragmentManager(), "dialog_fragment" ); &#125; 很像Dialog吧，也是支持鍊式編程的。這裡面的參數： ① 一個fragmentManager，在低版本中用getSupport來獲取；② 一個tag（String）通過這個tag可以告訴fragment是誰啟動了它，當然這僅僅是這個tag的一種使用方式啦。在fragment中可以通過getTag()方法來獲取這個tag 這裡多說一句，在一年前我還一直說要兼容要兼容，不兼容的demo是很不負責任的，但是現在來看，低版本的用戶真的很少很少了，而且這些低版本的用戶已經不能是我們的主流用戶了，所以在2014年末，我可以負責任的說，可以不用兼容2.x的系統了。我之前寫過很多兼容的文章，actionbar啊，對話框的兼容啊，但現在都變得無所謂了，其實任何事物的發展都是如此。很多之前很重要的技術，在新的發展中已經慢慢變得無足輕重了，但我們之前為之付出的東西卻不是無價值的。一個原因是為自己之前的工作找到價值，一種是在那段時光中我們慢慢體會到了很多東西，這些東西就是我們的閱歷也是一種談資。 好，閒話少敘，下面是運行效果： 有人會說，上面的那個空白的title好醜，我想去掉。當然可以，這就是fragment的好處，用這個方法： getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); 12345678910public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 現在它變成了這個樣子： 所以你可以看到，任何改變都是要付出代價的，如果你還是像之前一樣用match_parent來製定控件的寬度，那麼就是這種結果。可以說那個title欄就是一個房梁，支撐著對話框的寬度，沒了它就只能自適應了。解決辦法就是自定義控件的寬度，寫個幾百dp啥的，沒任何技術難度。 注意： 如果你的DialogFragment是Activity的內部類，必須將DialogFragment定義為靜態的。否則會報錯！！！ 123456789public static class DialogFragmentTest extends DialogFragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // TODO自動生成的方法存根 return inflater.inflate(R.layout.dialog, null ); &#125; &#125; DialogFragment啟動、終止過程分析之前說了，我們沒有像fragment那樣建立一個fragment加載對象進行fragment的加載，也沒有commit，但卻能使用dialogFragment對象，這是為什麼呢？ 我們先來回顧下fragment是怎麼使用的。 ① 建立FragmentManager對象，用來管理fragment ② 建立fragmentTransaction對象，用來添加和fragment ③ 提交fragment切換（commit） 123456FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction ft = fragmentManager.beginTransaction(); ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE); ft.add(R.id.container_fragment, new MyFragment()) .commit(); 替換fragment的方法 1234getSupportFragmentManager().beginTransaction(). replace(R.id.container_fragment02, fragment) .addToBackStack( null ) .commit(); 現在，我們通過源碼來分析下DialogFragment的啟動方式 我們在使用它的時候沒有去用fragmentTransaction對象，也沒有執行add，也沒有執行commit，僅僅提供了一個fragmentManager，那麼它是怎麼被添加的呢？我們知道這個對話框是用show方法顯示的，那麼就來看看這個方法吧。 DialogFragment源碼：1.show()1234567public void show(FragmentManager manager, String tag)&#123; mDismissed = false ; mShownByMe = true ; FragmentTransaction ft = manager.beginTransaction(); // creat a fragmentTransaction ft.add( this , tag); // add fragment with tag ft.commit(); &#125; 真相大白，api自動給你實現了一個fragment切換的對象，而且在show的時候就已經add了fragment，所以沒有任何問題~ 在add方法中沒有提供容器的id，所以表示是加載到當前activity中的，在添加後也的確調用了commit方法3 show()的另一種形式12345678public int show(FragmentTransaction transaction, String tag) &#123; mDismissed = false ; mShownByMe = true ; transaction.add( this , tag); mViewDestroyed = false ; mBackStackId = transaction.commit(); return mBackStackId; &#125; 上面的show方法傳入的是一個fragmentTransaction對象，這個也很容易理解。我們之前傳入fragmentManager對象的目的就是生成這個fragmentTransaction對象，這回我們可以在傳入一個已經配置好的fragmentTransaction對象，大大增加了可定制性。所以api的製訂也是大神們心血的結晶啊。 dimiss()1234567891011121314151617181920212223242526272829303132333435** * Dismiss the fragment and its dialog. If the fragment was added to the * back stack, all back stack state up to and including this entry will * be popped. Otherwise, a new transaction will be committed to remove * the fragment. */ public void dismiss() &#123; dismissInternal( false ); &#125; void dismissInternal( boolean allowStateLoss) &#123; if (mDismissed) &#123; return ; &#125; mDismissed = true ; mShownByMe = false ; if (mDialog != null ) &#123; mDialog.dismiss(); mDialog = null ; &#125; mViewDestroyed = true ; if (mBackStackId &gt;= 0 ) &#123; getFragmentManager().popBackStack(mBackStackId, FragmentManager.POP_BACK_STACK_INCLUSIVE); mBackStackId = -1 ; &#125; else &#123; FragmentTransaction ft = getFragmentManager().beginTransaction(); ft.remove( this ); if (allowStateLoss) &#123; ft.commitAllowingStateLoss(); &#125; else &#123; ft.commit(); &#125; &#125; &#125; 我們知道瞭如果一個DialogFragment關閉的時候會檢查堆棧裡面有沒有其他的對象，如果有就pop出來，如果沒有就直接remove和commit。也就是說：如果back stack堆棧有該Dialog，將其pop出來，否則ft.remove(this); ft.commit();。估計pop的操作也包含ft.remove()和ft.commit()。調用dismiss()會觸發onDismiss()回調函數。 跟踪狀態，如下： 通過onCreateView()來建立對話框佈局 上面的例子中我們已經在onCreateView()建立的對話框佈局，這時fragment中建立佈局的傳統寫法， 很適合用於自定義的對話框，我們可以修改任何的東西，包括對話框的style。 上面的例子中我們已經乾掉了對話框上面title的區域，而我們也沒發現可以設置標題的方法， 感覺上面那個標題欄就是個標題黨，毫無意義（之後會說到這塊區域的用處） 。 我們在onCreat中可以設置對話框的風格和各種屬性，但是千萬別設置關於view的東西，因為這時候對話框還沒建立呢，有關於view的東西在onCreatView中去設置吧，這裡我簡單設置了一個button的點擊事件——關閉對話框 123456789101112131415161718192021222324252627282930public class MyDialogFragment extends DialogFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); // 如果setCancelable()中參數為true，若點擊dialog覆蓋不到的activity的空白或者按返回鍵， // 則進行cancel，狀態檢測依次onCancel()和onDismiss()。如參數為false，則按空白處或返回鍵無反應。缺省為true setCancelable( true ); // 可以設置dialog的顯示風格 // setStyle(style,theme); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View rootView = inflater.inflate(R.layout.dialog, null ); Button btn = (Button)rootView.findViewById(R.id.button); btn.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO自動生成的方法存根 dismiss(); &#125; &#125;); return rootView; &#125;&#125; 補充：實現信息保存在activity橫豎屏切換的時候，dialog現在可以自動重建了，如果你在editText中輸入了信息，在重建的時候會不會保留之前的呢？在4.2和4.4中對話框人性化的自定保存了之前輸入的內容，我們無須手動處理。但如果你測試的手機被奇葩的定制了，那就乖乖的保存數據吧。 123456789101112131415161718192021222324public class MyDialogFragment extends DialogFragment &#123; EditText editText; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.dialog, null ); editText = (EditText) rootView.findViewById(R.id.editText); if (savedInstanceState != null ) &#123; CharSequence text = savedInstanceState.getCharSequence( "input data" ); editText.setText(text == null ? "" : text); &#125; return rootView; &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; outState.putCharSequence( "input data" , editText.getText()); super .onSaveInstanceState(outState); &#125;&#125; 通過onCreateDialog()來快捷的建立對話框我們上面建立的對話框都是用自定義佈局的，難道我們之前學過的dialog知識都沒用了麼？我們如果沒自定義對話框的需求，怎麼辦？就沒有一種快一點的方式來建立對話框麼？快用onCreatDialog吧！！！這個回調方法是DialogFragment獨有的，通過它返回的是一個Dialog對象，這個對象就會被顯示到屏幕上。千萬別同時使用onCreatView和onCreatDialog方法，他們僅僅是為了完成同樣一個目的的兩條路而已。 PS：從生命週期的順序而言，先執行onCreateDialog()，後執行onCreateView() 我在onCreatDialog建立一個警告對話框的builder，通過這個builder的create()方法來生成一個AlertDialog對象，因為AlertDialog是Dialog的子類，所以可以直接返回給Dialog。這裡可以用其他不同對話框的builder，代碼類似，只不過就是通過builder的creat()方法返回的是不同的對象而已。builder模式也是蠻巧妙的~ 1234567891011121314151617181920public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener&#123; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ) .setNegativeButton( "不同意", this ) .setCancelable( false ); //.show(); // show cann't be use here return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 &#125;&#125; 顯示效果： 看到了麼，這裡的標題欄終於有用了，原來那個標題欄是為了給我們在這裡用的啊~ 注意： ① 因為這裡創建的是一個dialog，所以用的onclickListener自然是對話框中的listener了。 ② 千萬別在構建對話框對象的時候順手寫了show()方法，我們現在是在fragment中初始化一個對話框，真正讓他顯示的時候是在activity中用這個dialogFragment對象顯示的。如果這裡寫了show方法不會報錯，但是會出現兩個對話框！ 那麼，我們能不能在這裡自定義對話框呢？當然可以啦，本身Dialog.builder就提供了自定義view的方法，和之前用Dialog一樣自定義下viwe就搞定了。 123456789101112131415161718192021@Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.fragment_login_dialog, null ); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout builder.setView(view) // set your own view // Add action buttons .setPositiveButton("Sign in" , new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int id) &#123; &#125; &#125;).setNegativeButton( "Cancel", null ); return builder.create(); &#125; 這裡貼下我在另一篇文章的自定義對話框view的代碼片段： 詳細看這裡：http://www.cnblogs.com/tianzhijiexian/p/3867731.html 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定義視圖對話框 * * @param title */ public void viewDialog(String title) &#123; // LayoutInflater是用來找layout文件夾下的xml佈局文件，並且實例化 LayoutInflater factory = LayoutInflater.from(mContext); // 把activity_login中的控件定義在View中 View view = factory.inflate(R.layout.dialog_layout, null ); // 將LoginActivity中的控件顯示在對話框中 // 獲取用戶輸入的“用戶名”，“密碼” // 注意：view.findViewById很重要，因為上面factory.inflate(R.layout.activity_login, // null)將頁面佈局賦值給了view了 TextView titleTv = (TextView) view .findViewById(R.id.dialog_textView_id); titleTv.setText(title); Button btn = (Button) view.findViewById(R.id.dialog_logout_button_id); btn.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; showToast( "按下自定義視圖的按鈕了~" ); &#125; &#125;); builder // 設定顯示的View .setView(view); // 設置dialog是否為模態，false表示模態，true表示非模態 // ab.setCancelable(false); // 對話框的創建、顯示,這裡顯示的位置是在屏幕的最下面，但是很不推薦這個種做法，因為距底部有一段空隙 AlertDialog dialog = builder.create(); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); // 此處可以設置dialog顯示的位置 window.setWindowAnimations(R.style.myAnimationstyle); // 添加動畫 dialog.show(); &#125; DialogFragment與Activity之前進行通信思路很簡單，就是定義一個傳輸數據的接口，強制activity實現這個接口，在fragment需要傳遞數據的時候去調用這個接口的方法，activity就能在這個方法中得到相應的數據了。這點在之前的fragment傳遞數據中已經介紹過了， 可以參考這篇文章：http://www.cnblogs.com/tianzhijiexian/p/3888330.html 在真正項目中，fragment的編寫並不需要了解activity的各類方法，好的編程風格是將fragment所涉及的方法以接口的方式封裝起來，我在此寫一個例子來說明一下。 寫一個接口——DataCallback123456package com.kale.dialogfragmenttest;public interface DataCallback &#123; public void getData(String data);&#125; activity實現這個接口123456789101112131415161718public class MainActivity extends Activity implements DataCallback&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new MyDialogFragment() .show(getFragmentManager(), "dialog_fragment" ); &#125; @Override public void getData(String data) &#123; // TODO自動生成的方法存根 System.out.println("data = "+ data); &#125;&#125; 在DialogFragment中使用這個接口在DialogFragment中使用這個接口，並且用instanceof來看啟動它的activity是否實現了這個接口，如果沒實現就拋出異常。這樣我們就能保證在大型項目中不會出現忘記實現這個接口的問題了。 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Activity; import android.app.AlertDialog; import android.app.AlertDialog.Builder; import android.app.Dialog; import android.app.DialogFragment; import android.content.DialogInterface; import android.os.Bundle ;public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener &#123; @Override public void onAttach(Activity activity) &#123; // onAttach()是合適的早期階段進行檢查MyActivity是否真的實現了接口。 // 採用接口的方式，dialog無需詳細了解MyActivity，只需了解其所需的接口函數，這是真正項目中應採用的方式。 if (!(activity instanceof DataCallback)) &#123; throw new IllegalStateException("fragment所在的Activity必須實現Callbacks接口" ); &#125; super .onAttach(activity); &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ).setNegativeButton("不同意", this ) .setCancelable( false ); // show(); return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 DataCallback callback = (DataCallback) getActivity(); callback.getData( "test" ); &#125;&#125; 此外fragment也可以通過fragment管理器，通過tag，獲取其他fragment實例，從而進行fragment之間的通信。當然從編程思想的角度看，fragment之間的過多進行交叉調用，不利於程序的管控。 用DialogFragment實現再次彈窗有時候我們可能有這樣的需求，點擊對話框中的一個按鈕後又彈出一個對話框，這個該怎麼做呢？首先在點擊事件中將這個對話框在屏幕上移除，然後把這個fragment壓棧，最後建立一個新的dialogFragment對象，show出來。我們雖然讓這個fragment在屏幕上消失，但還是可以通過fragment管理器到回退棧中找到它。 二次彈窗的代碼：123456789101112131415161718FragmentTransaction ft = getFragmentManager().beginTransaction(); /* * 如果不執行remove()，對話框即不會進入onDismiss()狀態。會被顯示在新的對話框下方，是可見的。 * 主要考慮美觀的問題，如果下面的對話框大於上面的對話框就很難看了。對於Dialog，container為0或者null。 */ ft.remove( this ); /* * 將當前的PromptDialogFragment加入到回退堆棧，當用戶按返回鍵，或者通過按幫助框的Close按鈕dismiss幫助框是， * 重新顯示提示框。對於back stack的處理，系統具有一定的智能。例如：執行兩次addToStackStack()，實際不會重複壓棧。 * 有例如：註釋掉remove()語句，即提示框不消失，而是在幫助框的下面。 * 但是在實驗中發現是否有addToBackStack()都不會結果有影響，系統能夠分析到對象存在，不需要壓棧。沒有去查源代碼， * 猜測通過mBackStackId比對來進行智能處理。 */ ft.addToBackStack( null ); new OhterDialogFragment() .show(getFragmentManager(), "dialog_fragment"); 利用Fragment的特性，為不同屏幕做適配如果我們想在大屏幕上顯示對話框，而小屏幕中直接把對話框的內容放在activity中顯示呢？ 其實也很簡單，本身這個dialogFragment就是一個fragment，所以完全有fragment的特性，你可以用fragmentTranscation將其放到任何佈局中，你也可以用show()方法把它當作dialog顯示出來。接下來就剩下一個問題了，判斷屏幕大小。 在默認的values下新建一個bools.xml 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; false &lt;/ bool &gt; &lt;/ resources &gt; 然後，在res下新建一個values-large，在values-large下再新建一個bools.xml，通過加載不同的value就能知道是大屏還是小屏幕啦 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; true &lt;/ bool &gt; &lt;/ resources &gt; 在代碼中進行判斷 123456789101112131415161718192021public void showDialogInDifferentScreen(View view) &#123; FragmentManager fragmentManager = getFragmentManager(); EditNameDialogFragment newFragment = new EditNameDialogFragment(); boolean mIsLargeLayout = getResources().getBoolean(R.bool.large_layout) ; Log.e( "TAG", mIsLargeLayout+"" ); if (mIsLargeLayout ) &#123; // The device is using a large layout, so show the fragment as a // dialog newFragment.show(fragmentManager, "dialog" ); &#125; else &#123; // The device is smaller, so show the fragment fullscreen FragmentTransaction transaction = fragmentManager.beginTransaction(); // For a little polish, specify a transition animation transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN); // To make it fullscreen , use the 'content' root view as the // container for the fragment, which is always the root view for the activity transaction.replace(R.id.id_ly, newFragment).commit(); &#125; &#125; 參考http://blog.csdn.net/huangyabin001/article/details/30053835 http://blog.csdn.net/lmj623565791/article/details/37815413 http://www.cnblogs.com/tianzhijiexian/p/4161811.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升倉管備料效率-小程式]]></title>
      <url>%2F2017%2F01%2F19%2F%E5%82%99%E6%96%99%E5%B0%8F%E7%A8%8B%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[計算bom表 小程式前言 版權聲明：轉載請保留原文連結及作者由於公司產品種類太多,User RMA回來數量都一樣兩樣很散一個User要去ERP開一張單,但ERP沒辦法把多張單合併包材集中在一張單,導致倉管必須一張單一張單備料由於這樣實在沒效率,所以寫個小程式把User購買的外部料號KEY在程式裡自動會算出需要的包材數量 效果 把外部料號,內部料號打進去會自動算出,倉管需要備東西把客戶名稱日期打上,可以記錄倉管幾月幾號幫RMA備料倉管可以自行反查紀錄,也會紀錄備料人員是誰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Textinputlayout使用及自訂義顏色]]></title>
      <url>%2F2017%2F01%2F16%2FTextinputlayout%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%87%AA%E8%A8%82%E7%BE%A9%E9%A1%8F%E8%89%B2%2F</url>
      <content type="text"><![CDATA[版權聲明：轉載請保留原文連結及作者http://blog.csdn.net/android_freshman/article/details/51136657 Textinputlayout gradle 配置12compile ‘com.Android.support:design:22.2.0’compile ‘com.android.support:appcompat-v7:22.2.0’ xml1234private android.widget.LinearLayout.LayoutParams setEditText(EditText editText, LayoutParams lp) &#123; if(this.mEditText != null) &#123; throw new IllegalArgumentException("We already have an EditText, can only have one"); &#125; else &#123; 注意點：部分源代碼中的內容，TextInputLayout 繼承LinearLayout 且裡面只能有一個editEditText，和scrollView 很像。下面是佈局文件： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.design.widget.TextInputLayout android:id="@+id/titleTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:layout_marginLeft="40dp" android:layout_marginRight="15dp" app:errorTextAppearance="@style/TextInput_Error_style"&gt; &lt;EditText android:id="@+id/title" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/white" android:singleLine="true" android:hint="Title"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/descriptionsTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="40dp" android:layout_marginRight="15dp"&gt; &lt;EditText android:id="@+id/descriptions" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp" android:textColor="@color/white" android:hint="Descriptions"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; java 注意：不能重寫TextInputLayout的OnFocusChangeListener的監聽事件，因為在源代碼中定義了動畫效果和editText注入，重寫了會導致動畫失效。設置浮動標籤動畫效果titleTextInput.setHint(“Title”); 123456if(titleEditText.getText().toString().length()&lt;6)&#123; titleTextInput.setErrorEnabled(true); titleTextInput.setError("title length must &gt;= 6");&#125;else &#123; titleTextInput.setErrorEnabled(false);&#125; 這一部分是動態錯誤提示的相關代碼 完成上面的，基本就可以出現TextInputLayout 的動畫效果了，但是默認的顏色不是很好看，所以我們需要自定義相關的顏色，比如hint 字的顏色，下劃線的顏色，錯誤字體的顏色大小等，下面就是自定義顏色的部分： google把Design Support Library寫的很好。每一個控件的顏色都是直接通過主題顏色繪製的，在style.xml 中指定。打開它添加colorAccent 到主題以改變表單的顏色。在style.xml 中修改相關的屬性 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/primary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt; &lt;!--&lt;item name="colorAccent"&gt;#3498db&lt;/item&gt;--&gt; &lt;item name="android:textColorHint"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlNormal"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlActivated"&gt;@color/white&lt;/item&gt; &lt;item name="colorControlHighlight"&gt;@color/white&lt;/item&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; colorAccent 是什麼意思，哪裡的顏色 這張圖片基本說明了colorAccent代表的顏色，而在google的官網上：https://www.google.com/design/spec/style/color.html#color-color-schemes 也有相關的說明 其他相關顏色的說明 android:textColorHint代表hint的顏色colorControlNormal代表下劃線沒有獲取焦點的顏色colorControlActivated，colorControlHighlight代表了獲取焦點或者點擊的時候下劃線的顏色 錯誤提示的顏色說明：默認的錯誤提示的顏色是紅色：在這種背景色下面，紅色不是很好看，所以需要自定義顏色 在設置佈局的時候errorTextAppearance這個屬性，自定義style 寫顏色和大小就可以了，至於另一個屬性hintTextAppearance 這個屬性修改顏色，好像沒有什麼效果，不起作用。 修改之後的效果，如下圖：有的機器上面可能沒有效果，下面提供一種解決方案： 123456789101112public static void setErrorTextColor(TextInputLayout textInputLayout, int color) &#123; try &#123; Field fErrorView = TextInputLayout.class.getDeclaredField("mErrorView"); fErrorView.setAccessible(true); TextView mErrorView = (TextView) fErrorView.get(textInputLayout); Field fCurTextColor = TextView.class.getDeclaredField("mCurTextColor"); fCurTextColor.setAccessible(true); fCurTextColor.set(mErrorView, color); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 這個是material design 的說明文檔：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText 的拍擋 - TextInputLayout]]></title>
      <url>%2F2017%2F01%2F14%2FTextInputLayout%2F</url>
      <content type="text"><![CDATA[toggleButtong 版權聲明：轉載請保留原文連結及作者http://blog.30sparks.com/material-design-6-textinputlayout/ Android Design Support Library 提供一個TextInputLayout 元件，可用來包著 EditText，令 EditText 得到 focus 時，自動將 hints 變成標題： 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" &gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Your name" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 效果 一個 TextInputLayout 只能容納一個 EditText，所以每個 EditText都需要自訂各自的 TextInputLayout。 關於 HintTextInputLayout 可直接使用 EditText 上的 hint，用來當成 header 。不過，你也可直接設定 hint 到 TextInputLayout 上，它們的效果也是相同的，值得留意的是，你可同時設定 hint 到 TextInputLayout 和 EditText 上。這樣的話，它們一開始會重叠，而當拿到 focus 時，在 TextInputLayout 上的 hint 會被拿來當 header ，而在 EditText 上的會跟以往一樣，有文字輸入後 hint 會消失。不過我想，在正常情況下應該不會這樣做吧？ 字數統計可使用 app:counterEnabled=&quot;true&quot; 和 app:counterMaxLength 可設定顯示輸入文字的長度。 錯誤訊息 TextInputLayout 還有另一好處，是可以顯示錯誤訊息。透過 textInputLayout.setError(&quot;Erorr in name input&quot;)便在底部可顯示錯誤訊息。 例如為我們之前加的 EditText 加進驗証的的話，可以這樣做 123456789101112131415 final TextInputLayout nameLayout = (TextInputLayout)findViewById(R.id.til_et_name);final EditText nameEditText = (EditText)findViewById(R.id.et_name);final Button button = (Button) findViewById(R.id.btn_submit);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(nameEditText.length() == 0)&#123; nameLayout.setError("Error in name input"); &#125; else&#123; nameLayout.setError(null); &#125; &#125;&#125;); 這樣當按 button 時，若 nameEditText 沒有文字的話，便會顯示 “Error in name input”。 不過有留意到顯示錯誤訊息時，整個 messageEditText 會被推下，因為當初 TextInputLayout 沒有預留空間去顯示錯誤訊息！想避免此情況，可以先設定1nameLayout.setErrorEnabled(true); 或者在 layout xml 上加入app:errorEnabled=&quot;true&quot; 123456&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" app:errorEnabled="true" &gt; 這樣，TextInputLayout 便會預留空間去顯示錯誤訊息了。留意的是，你可用 nameLayout. setErrorEnabled(false) 的話，去消除錯誤訊息，但整個layout 會被拉上去 (因錯誤訊息的位置也會被消除)。若不想 layout 移動的話，便應用nameLayout.setError(null) 去消除。 Style顏色想簡單更改底線顏色的話，可到 style.xml 修改 colorAccent 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- ...other style settings --&gt; &lt;item name="colorAccent"&gt;#0000FF&lt;/item&gt;&lt;/style&gt; header若只想改變 header 顏色 ，可使用 app:hintTextAppearance=&quot;style&quot;。先到 style.xml 中加入 TextInputHint 1234&lt;style name="TextInputHint" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#AA2288&lt;/item&gt;&lt;/style&gt; 然後加到 TextInputLayout 加入 app:hintTextAppearance=&quot;@style/TextInputHint &quot; 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:hintTextAppearance ="@style/TextInputHint "&gt; 佷簡單便可修改 header 的風格了。 錯誤訊息要更改錯誤訊息的顏色的話，跟改 header顏色的方法差不多，這次使用的是app:errorTextAppearance。 style.xml: 1234&lt;style name="TextInputError" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#FF00FF&lt;/item&gt;&lt;/style&gt; layout: 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:errorTextAppearance="@style/TextInputError"&gt; 這樣便可以自訂錯誤訊息的風格了。 結語要令文字輸入的 UI 更具動感，TextInputLayout 是一個很方便簡單的工具。快加到你的 UI 中吧。 相關連結 Material Design Patterns 官方文件 - TextInputLayout Working with the EditText]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-line聊天分割]]></title>
      <url>%2F2017%2F01%2F13%2Fjava-line%2F</url>
      <content type="text"><![CDATA[line 聊天記錄 分割 版權聲明：轉載請保留原文連結及作者以前想看line紀錄但太長了寫了一個以日期來分聊天記錄的小程式但效率不是很好也沒有太多時間回去在優化他了如果剛學java的可以自己寫一個看看 效果 主要思路 把txt讀近來後每一行判斷字串 是否有日期例如2016/01/31（日） 先把日期改成你想要的方式 先儲存一份在讀取新的txt 讀到你更改後的日期格式,把日期存成檔案名稱裡面的內容存到txt裡,讀到下一個日期停止先存一份更改日期的用意是.聊天內容或許會有日期或是/ 會抓錯其他應該很簡單就不再詳細敘述了分割好的內容會自動存在C:\LINE 資料夾內 下載點 下載點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toggleButton]]></title>
      <url>%2F2017%2F01%2F05%2FtoggleButton%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下 效果 程式碼 程式碼分成兩類 圖片繪製 點擊事件 布局XML 直接打上自定義原件類別名就可 12345678&lt;com.togg.toggiebutton.CustomToggleButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tb_backround" android:id="@+id/view"&gt;&lt;/com.togg.toggiebutton.CustomToggleButton&gt; onMeasure12345678910protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //底層圖片 backBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tb_backround); //上層圖片 overBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.slide_backround); //寬高和底層圖片一樣 setMeasuredDimension(backBitmap.getWidth(), backBitmap.getHeight()); &#125; onDraw1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; //2.繪制上層圖片 if (isTounching) &#123;//上層圖片跟随滑動 /** * * 防止上層圖片滑動出下層圖片的范围 */ //算出當前觸碰點為上層圖片的中心點時，上層圖片的左侧座標距離 int left = currentX - overBitmap.getWidth() / 2; System.out.println(left + "left 數值" + currentX + "currentx"); if (left &lt; 0) &#123;//防止左侧出界 left = 0; &#125; else if (left &gt; backBitmap.getWidth() - overBitmap.getWidth()) &#123;//防止右侧出界 left = backBitmap.getWidth() - overBitmap.getWidth(); &#125; canvas.drawBitmap(overBitmap, left, 0, null); &#125; else &#123;//上層圖片直接跳到開或關的位置 if (state) &#123; //開 canvas.drawBitmap(overBitmap, backBitmap.getWidth() - overBitmap.getWidth(), 0, null); listener.rightClick(); &#125; else &#123; //關 canvas.drawBitmap(overBitmap, 0, 0, null); listener.leftClick(); &#125; &#125; &#125; onTouchEvent123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //按下為true isTounching = true; //當前觸碰點的x座標 currentX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: isTounching = true; currentX = (int) event.getX(); break; case MotionEvent.ACTION_UP: //抬起時觸碰狀態為false isTounching = false; currentX = (int) event.getX(); break; &#125; //觸碰點超過底層圖片的一半，則state為true,開的狀態 state = currentX &gt; backBitmap.getWidth() / 2; //重新繪制 invalidate(); return true; &#125; 點擊1234567891011private topbarClickListener listener; public interface topbarClickListener &#123; public void leftClick(); public void rightClick(); &#125; public void setOntopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; MainActivity12345678910111213CustomToggleButton cust = (CustomToggleButton) findViewById(R.id.view); cust.setOntopbarClickListener(new CustomToggleButton.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left click", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,"right click",Toast.LENGTH_SHORT).show(); &#125; &#125;); 結尾 這個樣子可直接在你要使用的類 直接new就可以直接使用了 如果要使用各式各樣的開關 只需更改圖片 就可直接使用了 如果一個程式要使用多種開關 把onMeasure 裡面的底層 上層圖寫成外部輸入圖就可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 end]]></title>
      <url>%2F2016%2F12%2F31%2F2016-end%2F</url>
      <content type="text"><![CDATA[離起點又遠了一些,離終點又進了一點無論今天在困難,明天終究會到來無論今年發生多少事,到了明年還是會變成回憶中的故事這一切終究會拼湊成一個一個完整的人生新的一年,不要忘了完成那些該完成的事情謝謝周遭的許多人幫助了我非常非常多的事情有了你們這一切才會變成可行的事情 2016年度總結 今年接了幾個開發的案子,經歷了一大段很挫折壓力大到爆表的日子也接了幾個私人伺服器的協助開發,這段日子應該算是最快樂的,有錢賺還可以玩遊戲XDD也謝謝幾位高材生協助指導讓我完成這一串事情..整年度大部分時間都在學著嵌入式開發,當要開發的時候C已經忘得差不多了,花了很多的時間在學這一部分,在硬體開發部分由於對於電路不是很懂,有時候並不是代碼有寫錯而是電路的問題,常常在浪費時間在原地打轉.每當回去寫APP的時候都會忘記那時候到底在寫什麼,寫到了哪裡,那時候在想什麼年初給自己的目標,完成了六成,希望明年可以在努力一點今年應該算是最枯燥的一年,但今年的知識吸收量應該是以前的好幾倍,已結果來說還蠻滿意的年底架設了這個部落格,慢慢的會把自己所開發的過程放上來,如果有時間會把一些開源也慢慢的會把evernote上記錄的資料也移過來 2016書單 學失敗：創業熱時代看不見的退場故事 創業投資聖經：Startup募資、天使投資人、投資契約、談判策略全方位教戰法則 免費！揭開零定價的獲利祕密 自己的品牌自己做：企業自媒化，營造忠實顧客群的品牌經營方針 競爭論 創業的藝術 工作大解放：這樣做事反而更成功 從0到1：打開世界運作的未知祕密，在意想不到之處發現價值 全方位把玩Android 400個API：精挑細選365個實例說明 ARM Cortex-M4+Wi-Fi MCU應用指南：CC3200 CCS基礎篇 ARM Cortex-M3與Cortex-M4權威指南 拖延心理學：為什麼我老是愛拖延？是與生俱來的壞習慣，還是身不由己？ 創新者的窘境 30年心血，品牌之父艾克終於說出的品牌王道：微軟、可口可樂、麥當勞、三星、P&amp;G，全球行銷長都在讀的20終極法則 今年淺讀了這些書,雖然還有幾本還沒讀完..!!!!!2016也訂了一年份的空中英語教室月刊希望明年的今天語言部分可以進步很多 20172017 年度計畫 今年預計後半年要花點時間學python 今年也會開始學Machine Learning很大部分會完成2016該完成還沒完成的事情,加上一點突發狀況明年應該就這樣結束了慢慢的習慣把學習紀錄,資料記錄寫到部落格上 2017 書單 引爆社群：移動互聯網時代的新4C法則 稀缺：我們是如何陷入貧窮與忙碌的 TED TALKS 說話的力量：你可以用言語來改變自己，也改變世界 TED唯一官方版演講指南 不懂帶團隊，那就大家一起死！：行為科學教你把豬一般的隊友變菁英 沒經驗，是你最大優勢 賽局理論，解決問題最簡單的方法 文案力：如果沒有文案，這世界會有多無聊？ 釣愚：操縱與欺騙的經濟學 Python 自動化的樂趣｜搞定重複瑣碎 &amp;單調無聊的工作 解事者：複雜的事物我簡單說明白 如果這樣，會怎樣？：胡思亂想的搞怪趣問 正經認真的科學妙答 商業冒險：華爾街的12個經典故事 債的歷史：從文明的初始到全球負債時代 我的思考，我的光：諾貝爾獎得主中村修二創新突破的7個思考原點 如果中途有看到喜歡的書在新增上來 END 想起前陣子跟朋友討論一本俄羅斯的小說裡面有段話挺有趣的真正的窮人,是那種群聚在一起的人,而孑然一身的窮人,不過是沒賺到錢的有錢人罷了 任何值得去的地方 都沒有捷徑努力配得上你的夢想那麼你的夢想也不會辜負你的努力送給自己一句話自律能讓你更優秀 加油！！！！2016再見 2017加油!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout]]></title>
      <url>%2F2016%2F12%2F15%2FMy-New-post%2F</url>
      <content type="text"><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下在安卓5.0有新增了TabLauout但他並不能滿足很多時候想顯示的樣子所以使用V4下的FragmentPagerAdapter來實現.請記得都要import v4 否則會報錯呈現的效果如下 效果 程式碼 程式碼分成四類 FragmentPagerAdapter ArrayList&lt;Fragment&gt;() 初始化三個布局 更改點擊的布局屬性 布局XML 從上面的效果可以看的出來 沒選重的狀況下其他兩個字體大小要一置 選重的要變大 下底線要與字體長度一樣 程式碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:orientation="horizontal"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/id_tab_trend" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_trend" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_trend_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_surrounding" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_sourrounding" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_surrounding_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_appliances" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_appliances" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_appliances_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在一個LinearLayout裡面 再放三個`LinearLayout`` 按照比例分配`android:layout_weight=”1”`` 點擊後在程式碼將點擊的layout_weight 改成你要的比例在把字體放大 Fragment1234567mFragment = new ArrayList&lt;Fragment&gt;(); Fragment mTab01 = new TrendFragment(); Fragment mTab02 = new SurroundingFragment(); Fragment mTab03 = new AppliancesFragment(); mFragment.add(mTab01); mFragment.add(mTab02); mFragment.add(mTab03); FragmentPagerAdapter1234567891011121314151617181920212223242526272829303132333435mAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragment.get(position); &#125; @Override public int getCount() &#123; return mFragment.size(); &#125; &#125;; mViewPager.setAdapter(mAdapter); // Touch Replace the content area mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; 重置 這邊來判斷字的寬度 來依照讀取的寬度來設定線的長度 這邊只貼其中一組 textview ImageView 請在自行補上其他的1234567891011private void resetColor() &#123; mTvTrend.setTextColor(getResources().getColor(R.color.tab_not_selectedl_Color)); mTvTrend.setTextSize(NOT_SELECTED); mTvTrend.setText(one); mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayoutCompat.LayoutParams.WRAP_CONTENT, 1.0f)); mTabtrendImg.setBackgroundResource(R.drawable.tabline); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); 點擊 在點擊的時候先呼叫一次resetColor(); 在設定布局比例 文字大小 123456public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.id_tab_trend: setSelect(0); break; 12345678910111213141516public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 滑動 別忘了上面寫的ViewPage事件 12345public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; 123456789101112131415public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 結尾 程式碼可以在寫一個class來去放 這樣會比較好維護一點 下底線圖片要改成.9會比較好一點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[taiwan]]></title>
      <url>%2F2016%2F09%2F03%2Ftaiwan%2F</url>
      <content type="text"><![CDATA[10/18 Day 11hot spot台灣師範大學 台灣師大 google map 師大夜市 師範大學&gt; 0.2KM 師大夜市 google map 永康商圈 師範大學 &gt; 0.8 KM 永康商圈 google mpa 中正紀念堂 師範大學&gt; 1.2KM 中正紀念堂 google map 10/19 Day 2hot spot臺灣大學 臺灣大學 google map 行天宮 行天宮 google map 台北犁記餅店 犁記餅店 google map 四平陽光商圈 四平陽光商圈 google map 遼寧夜市 遼寧夜市 google map 10/20 Day 3hot spot故宮博物院-故宮博物院 google map 西門町 西門町 google map 10/21 Day 4hot spot淡水老街 淡水老街 very big 淡水老街 google map 士林夜市 士林夜市 google map 10/22 Day 5hot spot龍山寺 龍山寺google map 中正紀念堂 中正紀念堂 google map 九份 !! Great Distances. 九份 google map 10/23 Day 6hot spot雙連朝市 雙連朝市 google map 總統府 總統府 google map 迪化街 迪化街google map 霞海城隍廟 !!迪化街 nearby 海峽城隍廟 google map 鶯歌老街 鶯歌老街 google map]]></content>
    </entry>

    
  
  
</search>
