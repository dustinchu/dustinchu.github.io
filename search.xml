<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[EditText 的拍擋 - TextInputLayout]]></title>
      <url>%2F2017%2F01%2F14%2FTextInputLayout%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者http://blog.30sparks.com/material-design-6-textinputlayout/ Android Design Support Library 提供一個TextInputLayout 元件，可用來包著 EditText，令 EditText 得到 focus 時，自動將 hints 變成標題： 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" &gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Your name" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 效果 一個 TextInputLayout 只能容納一個 EditText，所以每個 EditText都需要自訂各自的 TextInputLayout。 關於 HintTextInputLayout 可直接使用 EditText 上的 hint，用來當成 header 。不過，你也可直接設定 hint 到 TextInputLayout 上，它們的效果也是相同的，值得留意的是，你可同時設定 hint 到 TextInputLayout 和 EditText 上。這樣的話，它們一開始會重叠，而當拿到 focus 時，在 TextInputLayout 上的 hint 會被拿來當 header ，而在 EditText 上的會跟以往一樣，有文字輸入後 hint 會消失。不過我想，在正常情況下應該不會這樣做吧？ 字數統計可使用 app:counterEnabled=&quot;true&quot; 和 app:counterMaxLength 可設定顯示輸入文字的長度。 錯誤訊息 TextInputLayout 還有另一好處，是可以顯示錯誤訊息。透過 textInputLayout.setError(&quot;Erorr in name input&quot;)便在底部可顯示錯誤訊息。 例如為我們之前加的 EditText 加進驗証的的話，可以這樣做 123456789101112131415 final TextInputLayout nameLayout = (TextInputLayout)findViewById(R.id.til_et_name);final EditText nameEditText = (EditText)findViewById(R.id.et_name);final Button button = (Button) findViewById(R.id.btn_submit);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(nameEditText.length() == 0)&#123; nameLayout.setError("Error in name input"); &#125; else&#123; nameLayout.setError(null); &#125; &#125;&#125;); 這樣當按 button 時，若 nameEditText 沒有文字的話，便會顯示 “Error in name input”。 不過有留意到顯示錯誤訊息時，整個 messageEditText 會被推下，因為當初 TextInputLayout 沒有預留空間去顯示錯誤訊息！想避免此情況，可以先設定1nameLayout.setErrorEnabled(true); 或者在 layout xml 上加入app:errorEnabled=&quot;true&quot; 123456&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" app:errorEnabled="true" &gt; 這樣，TextInputLayout 便會預留空間去顯示錯誤訊息了。留意的是，你可用 nameLayout. setErrorEnabled(false) 的話，去消除錯誤訊息，但整個layout 會被拉上去 (因錯誤訊息的位置也會被消除)。若不想 layout 移動的話，便應用nameLayout.setError(null) 去消除。 Style顏色想簡單更改底線顏色的話，可到 style.xml 修改 colorAccent 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- ...other style settings --&gt; &lt;item name="colorAccent"&gt;#0000FF&lt;/item&gt;&lt;/style&gt; header若只想改變 header 顏色 ，可使用 app:hintTextAppearance=&quot;style&quot;。先到 style.xml 中加入 TextInputHint 1234&lt;style name="TextInputHint" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#AA2288&lt;/item&gt;&lt;/style&gt; 然後加到 TextInputLayout 加入 app:hintTextAppearance=&quot;@style/TextInputHint &quot; 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:hintTextAppearance ="@style/TextInputHint "&gt; 佷簡單便可修改 header 的風格了。 錯誤訊息要更改錯誤訊息的顏色的話，跟改 header顏色的方法差不多，這次使用的是app:errorTextAppearance。 style.xml: 1234&lt;style name="TextInputError" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#FF00FF&lt;/item&gt;&lt;/style&gt; layout: 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:errorTextAppearance="@style/TextInputError"&gt; 這樣便可以自訂錯誤訊息的風格了。 結語要令文字輸入的 UI 更具動感，TextInputLayout 是一個很方便簡單的工具。快加到你的 UI 中吧。 相關連結 Material Design Patterns 教學首頁 官方文件 - TextInputLayout Working with the EditText]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-line聊天分割]]></title>
      <url>%2F2017%2F01%2F13%2Fjava-line%2F</url>
      <content type="text"><![CDATA[line 聊天記錄 分割 版權聲明：轉載請保留原文連結及作者以前想看line紀錄但太長了寫了一個以日期來分聊天記錄的小程式但效率不是很好也沒有太多時間回去在優化他了如果剛學java的可以自己寫一個看看 效果 主要思路 把txt讀近來後每一行判斷字串 是否有日期例如2016/01/31（日） 先把日期改成你想要的方式 先儲存一份在讀取新的txt 讀到你更改後的日期格式,把日期存成檔案名稱裡面的內容存到txt裡,讀到下一個日期停止先存一份更改日期的用意是.聊天內容或許會有日期或是/ 會抓錯其他應該很簡單就不再詳細敘述了分割好的內容會自動存在C:\LINE 資料夾內 下載點 下載點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toggleButton]]></title>
      <url>%2F2017%2F01%2F05%2FtoggleButton%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下 效果 程式碼 程式碼分成兩類 圖片繪製 點擊事件 布局XML 直接打上自定義原件類別名就可 12345678&lt;com.togg.toggiebutton.CustomToggleButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tb_backround" android:id="@+id/view"&gt;&lt;/com.togg.toggiebutton.CustomToggleButton&gt; onMeasure12345678910protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //底層圖片 backBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tb_backround); //上層圖片 overBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.slide_backround); //寬高和底層圖片一樣 setMeasuredDimension(backBitmap.getWidth(), backBitmap.getHeight()); &#125; onDraw1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; //2.繪制上層圖片 if (isTounching) &#123;//上層圖片跟随滑動 /** * * 防止上層圖片滑動出下層圖片的范围 */ //算出當前觸碰點為上層圖片的中心點時，上層圖片的左侧座標距離 int left = currentX - overBitmap.getWidth() / 2; System.out.println(left + "left 數值" + currentX + "currentx"); if (left &lt; 0) &#123;//防止左侧出界 left = 0; &#125; else if (left &gt; backBitmap.getWidth() - overBitmap.getWidth()) &#123;//防止右侧出界 left = backBitmap.getWidth() - overBitmap.getWidth(); &#125; canvas.drawBitmap(overBitmap, left, 0, null); &#125; else &#123;//上層圖片直接跳到開或關的位置 if (state) &#123; //開 canvas.drawBitmap(overBitmap, backBitmap.getWidth() - overBitmap.getWidth(), 0, null); listener.rightClick(); &#125; else &#123; //關 canvas.drawBitmap(overBitmap, 0, 0, null); listener.leftClick(); &#125; &#125; &#125; onTouchEvent123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //按下為true isTounching = true; //當前觸碰點的x座標 currentX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: isTounching = true; currentX = (int) event.getX(); break; case MotionEvent.ACTION_UP: //抬起時觸碰狀態為false isTounching = false; currentX = (int) event.getX(); break; &#125; //觸碰點超過底層圖片的一半，則state為true,開的狀態 state = currentX &gt; backBitmap.getWidth() / 2; //重新繪制 invalidate(); return true; &#125; 點擊1234567891011private topbarClickListener listener; public interface topbarClickListener &#123; public void leftClick(); public void rightClick(); &#125; public void setOntopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; MainActivity12345678910111213CustomToggleButton cust = (CustomToggleButton) findViewById(R.id.view); cust.setOntopbarClickListener(new CustomToggleButton.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left click", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,"right click",Toast.LENGTH_SHORT).show(); &#125; &#125;); 結尾 這個樣子可直接在你要使用的類 直接new就可以直接使用了 如果要使用各式各樣的開關 只需更改圖片 就可直接使用了 如果一個程式要使用多種開關 把onMeasure 裡面的底層 上層圖寫成外部輸入圖就可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 end]]></title>
      <url>%2F2016%2F12%2F31%2F2016-end%2F</url>
      <content type="text"><![CDATA[離起點又遠了一些,離終點又進了一點無論今天在困難,明天終究會到來無論今年發生多少事,到了明年還是會變成回憶中的故事這一切終究會拼湊成一個一個完整的人生新的一年,不要忘了完成那些該完成的事情謝謝周遭的許多人幫助了我非常非常多的事情有了你們這一切才會變成可行的事情 2016年度總結 今年接了幾個開發的案子,經歷了一大段很挫折壓力大到爆表的日子也接了幾個私人伺服器的協助開發,這段日子應該算是最快樂的,有錢賺還可以玩遊戲XDD也謝謝幾位高材生協助指導讓我完成這一串事情..整年度大部分時間都在學著嵌入式開發,當要開發的時候C已經忘得差不多了,花了很多的時間在學這一部分,在硬體開發部分由於對於電路不是很懂,有時候並不是代碼有寫錯而是電路的問題,常常在浪費時間在原地打轉.每當回去寫APP的時候都會忘記那時候到底在寫什麼,寫到了哪裡,那時候在想什麼年初給自己的目標,完成了六成,希望明年可以在努力一點今年應該算是最枯燥的一年,但今年的知識吸收量應該是以前的好幾倍,已結果來說還蠻滿意的年底架設了這個部落格,慢慢的會把自己所開發的過程放上來,如果有時間會把一些開源也慢慢的會把evernote上記錄的資料也移過來 2016書單 學失敗：創業熱時代看不見的退場故事 創業投資聖經：Startup募資、天使投資人、投資契約、談判策略全方位教戰法則 免費！揭開零定價的獲利祕密 自己的品牌自己做：企業自媒化，營造忠實顧客群的品牌經營方針 競爭論 創業的藝術 工作大解放：這樣做事反而更成功 從0到1：打開世界運作的未知祕密，在意想不到之處發現價值 全方位把玩Android 400個API：精挑細選365個實例說明 ARM Cortex-M4+Wi-Fi MCU應用指南：CC3200 CCS基礎篇 ARM Cortex-M3與Cortex-M4權威指南 拖延心理學：為什麼我老是愛拖延？是與生俱來的壞習慣，還是身不由己？ 創新者的窘境 30年心血，品牌之父艾克終於說出的品牌王道：微軟、可口可樂、麥當勞、三星、P&amp;G，全球行銷長都在讀的20終極法則 今年淺讀了這些書,雖然還有幾本還沒讀完..!!!!!2016也訂了一年份的空中英語教室月刊希望明年的今天語言部分可以進步很多 20172017 年度計畫 今年預計後半年要花點時間學python 今年也會開始學Machine Learning很大部分會完成2016該完成還沒完成的事情,加上一點突發狀況明年應該就這樣結束了慢慢的習慣把學習紀錄,資料記錄寫到部落格上 2017 書單 引爆社群：移動互聯網時代的新4C法則 稀缺：我們是如何陷入貧窮與忙碌的 TED TALKS 說話的力量：你可以用言語來改變自己，也改變世界 TED唯一官方版演講指南 不懂帶團隊，那就大家一起死！：行為科學教你把豬一般的隊友變菁英 沒經驗，是你最大優勢 賽局理論，解決問題最簡單的方法 文案力：如果沒有文案，這世界會有多無聊？ 釣愚：操縱與欺騙的經濟學 Python 自動化的樂趣｜搞定重複瑣碎 &amp;單調無聊的工作 解事者：複雜的事物我簡單說明白 如果這樣，會怎樣？：胡思亂想的搞怪趣問 正經認真的科學妙答 商業冒險：華爾街的12個經典故事 如果中途有看到喜歡的書在新增上來 END 想起曾經前陣子跟朋友討論一本俄羅斯的小說裡面有段話挺有趣的真正的窮人,是那種群聚在一起的人,而孑然一身的窮人,不過是沒賺到錢的有錢人罷了 任何值得去的地方 都沒有捷徑努力配得上你的夢想那麼你的夢想也不會辜負你的努力送給自己一句話自律能讓你更優秀 加油！！！！2016再見 2017加油!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout]]></title>
      <url>%2F2016%2F12%2F15%2FMy-New-post%2F</url>
      <content type="text"><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下在安卓5.0有新增了TabLauout但他並不能滿足很多時候想顯示的樣子所以使用V4下的FragmentPagerAdapter來實現.請記得都要import v4 否則會報錯呈現的效果如下 效果 程式碼 程式碼分成四類 FragmentPagerAdapter ArrayList&lt;Fragment&gt;() 初始化三個布局 更改點擊的布局屬性 布局XML 從上面的效果可以看的出來 沒選重的狀況下其他兩個字體大小要一置 選重的要變大 下底線要與字體長度一樣 程式碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:orientation="horizontal"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/id_tab_trend" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_trend" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_trend_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_surrounding" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_sourrounding" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_surrounding_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_appliances" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_appliances" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_appliances_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在一個LinearLayout裡面 再放三個`LinearLayout`` 按照比例分配`android:layout_weight=”1”`` 點擊後在程式碼將點擊的layout_weight 改成你要的比例在把字體放大 Fragment1234567mFragment = new ArrayList&lt;Fragment&gt;(); Fragment mTab01 = new TrendFragment(); Fragment mTab02 = new SurroundingFragment(); Fragment mTab03 = new AppliancesFragment(); mFragment.add(mTab01); mFragment.add(mTab02); mFragment.add(mTab03); FragmentPagerAdapter1234567891011121314151617181920212223242526272829303132333435mAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragment.get(position); &#125; @Override public int getCount() &#123; return mFragment.size(); &#125; &#125;; mViewPager.setAdapter(mAdapter); // Touch Replace the content area mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; 重置 這邊來判斷字的寬度 來依照讀取的寬度來設定線的長度 這邊只貼其中一組 textview ImageView 請在自行補上其他的1234567891011private void resetColor() &#123; mTvTrend.setTextColor(getResources().getColor(R.color.tab_not_selectedl_Color)); mTvTrend.setTextSize(NOT_SELECTED); mTvTrend.setText(one); mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayoutCompat.LayoutParams.WRAP_CONTENT, 1.0f)); mTabtrendImg.setBackgroundResource(R.drawable.tabline); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); 點擊 在點擊的時候先呼叫一次resetColor(); 在設定布局比例 文字大小 123456public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.id_tab_trend: setSelect(0); break; 12345678910111213141516public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 滑動 別忘了上面寫的ViewPage事件 12345public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; 123456789101112131415public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 結尾 程式碼可以在寫一個class來去放 這樣會比較好維護一點 下底線圖片要改成.9會比較好一點]]></content>
    </entry>

    
  
  
</search>
