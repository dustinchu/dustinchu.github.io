<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[python學習紀錄]]></title>
      <url>%2F2017%2F04%2F01%2Fpython%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[python 前陣子買了幾本python的書連續假期終於有空看了這些書發現要打個for 都還要看書看一下怎們打也常常打到最後都加上;紀錄一下一些用法與說明讓自己方便查詢 python 變數 資料類型Python中資料類型1.整數 Python可以處理任意大小的整數，當然包括負整數，在Python程序中，整數的表示方法和數學上的寫法一模一樣，例如：1，100，-8080，0，等。計算機由於使用二進制，所以，有時候用十六進製表示整數比較方便，十六進制用0x前綴和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 12print(0xff00)print(0xa5b4c3d2) 結果652802780087250 2.浮點數 浮點數也就是小數，之所以稱為浮點數，是因為按照科學記數法表示時，一個浮點數的小數點位置是可變的，比如，1.23x10^9和12.3x10^8是相等的。浮點數可以用數學寫法，如1.23，3.14，-9.01，等等。但是對於很大或很小的浮點數，就必須用科學計數法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以寫成1.2e-5，等等。整數和浮點數在計算機內部存儲的方式是不同的，整數運算永遠是精確的（除法難道也是精確的？是的！），而浮點數運算則可能會有四捨五入的誤差。 3.字串 字串是以&#39;&#39;或&quot;&quot;括起來的任意，比如&#39;abc&#39;，&quot;xyz&quot;等等。請注意，’’或””本身只是一種表示方式，不是字符串的一部分，因此，字串’abc’只有a，b，c這3個字符。 4.布林值 布林值和布爾代數的表示完全一致，一個布林值只有True、False兩種值，True，False，在Python中，可以直接用True、False表示布林值（請注意大小寫），也可以通過布爾運算計算出來。布林值可以用and、or和not運算。and運算是與運算，只有所有都為 True，and運算結果才是 True。or運算是或運算，只要其中有一個為 True，or 運算結果就是 True。not運算是非運算，它是一個單目運算符，把 True 變成 False，False 變成 True。 5.空值 空值是Python裡一個特殊的值，用None表示。 None不能理解為0，因為0是有意義的，而None是一個特殊的空值。此外，Python還提供了列表、字典等多種數據類型，還允許創建自定義數據類型， python printprint print語句也可以跟上多個字串，用逗號“,”隔開，就可以連成一串輸出：1print ('The quick brown fox', 'jumps over', 'the lazy dog' ,'The quick brown fox jumps over the lazy dog') 結果 The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog print會依次打印每個字符串，遇到逗號“,”會輸出一個空格，因此，輸出的字符串是這樣拼起來的： python中定義字串如果字符串既包含&#39;又包含&quot;怎麼辦？這個時候，就需要對字符串的某些特殊字符進行“轉義”，Python字符串用\進行轉義。要表示字符串 Bob said “I’m OK”.由於 ‘ 和 “ 會引起歧義，因此，我們在它前面插入一個\表示這是一個普通字符，不代表字符串的起始，因此，這個字符串又可以表示為 ‘Bob said \”I\’m OK\”.’ 注意：轉義字符 \ 不計入字符串的內容中。 常用的轉義字符還有： \n 表示換行\t 表示一個製表符\ 表示 \ 字串本身 Python中raw字符串與多行字串如果一個字符串包含很多需要轉義的字符，對每一個字符都進行轉義會很麻煩。為了避免這種情況，我們可以在字符串前面加個前綴 r ，表示這是一個 raw 字符串，裡面的字符就不需要轉義了。例如： r’(~~)/ (~~)/‘ 但是r&#39;...&#39;表示法不能表示多行字串，也不能表示包含&#39;和&quot;的字串（為什麼？） 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： ‘’’Line 1Line 2Line 3’’’ 上面這個字符串的表示方法和下面的是完全一樣的： ‘Line 1\nLine 2\nLine 3’ 還可以在多行字符串前面添加 r ，把這個多行字符串也變成一個raw字符串： r’’’Python is created by “Guido”.It is free and easy to learn.Let’s start learn Python in imooc!’’’ Python中Unicode字符串字串還有一個編碼問題。 因為計算機只能處理數字，如果要處理文本，就必須先把文本轉換為數字才能處理。最早的計算機在設計時採用8個比特（bit）作為一個字節（byte），所以，一個字節能表示的最大的整數就是255（二進制11111111=十進制255），0 - 255被用來表示大小寫英文字母、數字和一些符號，這個編碼表被稱為ASCII編碼，比如大寫字母A 的編碼是65，小寫字母z 的編碼是122。 如果要表示中文，顯然一個字節是不夠的，至少需要兩個字節，而且還不能和ASCII編碼衝突，所以，中國製定了GB2312編碼，用來把中文編進去。 類似的，日文和韓文等其他語言也有這個問題。為了統一所有文字的編碼，Unicode應運而生。 Unicode把所有語言都統一到一套編碼裡，這樣就不會再有亂碼問題了。 Unicode通常用兩個字節表示一個字符，原有的英文編碼從單字節變成雙字節，只需要把高字節全部填為0就可以。 因為Python的誕生比Unicode標準發布的時間還要早，所以最早的Python只支持ASCII編碼，普通的字符串&#39;ABC&#39;在Python內部都是ASCII編碼的。 Python在後來添加了對Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： print u’中文’中文 注意: 不加 u ，中文就不能正常顯示。 Unicode字符串除了多了一個 u 之外，與普通字符串沒啥區別，轉義字符和多行表示法仍然有效： 轉義： u’中文\n日文\n韓文’ 多行： u’’’第一行第二行’’’ raw+多行： ur’’’Python的Unicode字符串支持”中文”,“日文”,“韓文”等多種語言’’’ 如果中文字符串在Python環境下遇到 UnicodeDecodeError，這是因為.py文件保存的格式有問題。可以在第一行增加註釋 –coding: utf-8– 目的是告訴Python解釋器，用UTF-8編碼讀取源代碼。然後用Notepad++ 另存為… 並選擇UTF-8格式保存。 Python中整數和浮點數Python支持對整數和浮點數直接進行四則混合運算，運算規則和數學上的四則運算規則完全一致。 基本的運算： 1 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括號可以提升優先級，這和數學運算完全一致，注意只能使用小括號，但是括號可以嵌套很多層： (1 + 2) 3 # ==&gt; 9(2.2 + 3.3) / (1.5 (9 - 0.3)) # ==&gt; 0.42145593869731807 和數學運算不同的地方是，Python的整數運算結果仍然是整數，浮點數運算結果仍然是浮點數： 1 + 2 # ==&gt; 整數 31.0 + 2.0 # ==&gt; 浮點數 3.0 但是整數和浮點數混合運算的結果就變成浮點數了： 1 + 2.0 # ==&gt; 浮點數 3.0 為什麼要區分整數運算和浮點數運算呢？這是因為整數運算的結果永遠是精確的，而浮點數運算的結果不一定精確，因為計算機內存再大，也無法精確表示出無限循環小數，比如 0.1 換成二進製表示就是無限循環小數。 那整數的除法運算遇到除不盡的時候，結果難道不是浮點數嗎？我們來試一下： 11 / 4 # ==&gt; 2 令很多初學者驚訝的是，Python的整數除法，即使除不盡，結果仍然是整數，餘數直接被扔掉。不過，Python提供了一個求餘的運算 % 可以計算餘數： 11 % 4 # ==&gt; 3 如果我們要計算 11 / 4 的精確結果，按照“整數和浮點數混合運算的結果是浮點數”的法則，把兩個數中的一個變成浮點數再運算就沒問題了： 11.0 / 4 # ==&gt; 2.75 Python中布爾類型我們已經了解了Python支持布爾類型的數據，布爾類型只有True和False兩種值，但是布爾類型有以下幾種運算： and 運算：只有兩個布爾值都為 True 時，計算結果才為 True。 True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False or運算：只要有一個布爾值為 True，計算結果就是 True。 True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False not運算：把True變為False，或者把False變為True： not True # ==&gt; Falsenot False # ==&gt; True 布爾運算在計算機中用來做條件判斷，根據計算結果為True或者False，計算機可以自動執行不同的後續代碼。 在Python中，布爾類型還可以與其他數據類型做 and、or和not運算，請看下面的代碼： a = Trueprint a and ‘a=T’ or ‘a=F’ 計算結果不是布爾類型，而是字符串 ‘a=T’，這是為什麼呢？ 因為Python把0、空字串&#39;&#39;和None看成 False，其他數值和非空字符串都看成 True，所以：&gt;True and ‘a=T’ 計算結果是 ‘a=T’繼續計算 ‘a=T’ or ‘a=F’ 計算結果還是 ‘a=T’要解釋上述結果，又涉及到 and 和 or 運算的一條重要法則：短路計算。 在計算 a and b 時，如果 a 是 False，則根據與運算法則，整個結果必定為 False，因此返回 a；如果 a 是 True，則整個計算結果必定取決與 b，因此返回 b。 在計算 a or b 時，如果 a 是 True，則根據或運算法則，整個計算結果必定為 True，因此返回 a；如果 a 是 False，則整個計算結果必定取決於 b，因此返回 b。 所以Python解釋器在做布爾運算時，只要能提前確定計算結果，它就不會往後算了，直接返回結果。 List和Tuple類型Pytho建立listPython內置的一種數據類型是列表：list。 list是一種有序的集合，可以隨時添加和刪除其中的元素。 比如，列出班裡所有同學的名字，就可以用一個list表示： [‘Michael’, ‘Bob’, ‘Tracy’][‘Michael’, ‘Bob’, ‘Tracy’] list是數學意義上的有序集合，也就是說，list中的元素是按照順序排列的。 構造list非常簡單，按照上面的代碼，直接用[ ]把list的所有元素都括起來，就是一個list對象。通常，我們會把list賦值給一個變量，這樣，就可以通過變量來引用list： classmates = [‘Michael’, ‘Bob’, ‘Tracy’]classmates # 打印classmates變量的內容[‘Michael’, ‘Bob’, ‘Tracy’] 由於Python是動態語言，所以list中包含的元素並不要求都必須是同一種數據類型，我們完全可以在list中包含各種數據： L = [‘Michael’, 100, True] 一個元素也沒有的list，就是空list： empty_list = [] Python按照索引訪問list由於list是一個有序集合，所以，我們可以用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 那我們如何從list中獲取指定第 N 名的同學呢？方法是通過索引來獲取list中的指定元素。 需要特別注意的是，索引從 0 開始，也就是說，第一個元素的索引是0，第二個元素的索引是1，以此類推。因此，要列印第一名同學的名字，用 L[0]: print L[0]Adam 要打印第二名同學的名字，用 L[1]: print L[1]Lisa 要打印第三名同學的名字，用 L[2]: print L[2]Bart 要打印第四名同學的名字，用 L[3]: print L[3]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range 報錯了！ IndexError意思就是索引超出了範圍，因為上面的list只有3個元素，有效的索引是 0，1，2。 所以，使用索引時，千萬注意不要越界。 Python之倒序訪問list我們還是用一個list按分數從高到低表示出班裡的3個同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 這時，老師說，請分數最低的同學站出來。 要寫代碼完成這個任務，我們可以先數一數這個 list，發現它包含3個元素，因此，最後一個元素的索引是2： print L[2]Bart 有沒有更簡單的方法？ 有！ Bart同學是最後一名，俗稱倒數第一，所以，我們可以用 -1 這個索引來表示最後一個元素： print L[-1]Bart Bart同學表示躺槍。 類似的，倒數第二用 -2 表示，倒數第三用 -3 表示，倒數第四用 -4 表示： print L[-2]Lisaprint L[-3]Adamprint L[-4]Traceback (most recent call last): File ““, line 1, in IndexError: list index out of range L[-4] 報錯了，因為倒數第四不存在，一共只有3個元素。 使用倒序索引時，也要注意不要越界。 Python之添加新元素現在，班裡有3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 今天，班裡轉來一名新同學 Paul，如何把新同學添加到現有的 list 中呢？ 第一個辦法是用 list 的 append() 方法，把新同學追加到 list 的末尾： L = [‘Adam’, ‘Lisa’, ‘Bart’]L.append(‘Paul’) print L[‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] append()總是把新的元素添加到 list 的尾部。 如果 Paul 同學表示自己總是考滿分，要求添加到第一的位置，怎麼辦？ 方法是用list的 insert()方法，它接受兩個參數，第一個參數是索引號，第二個參數是待添加的新元素： L = [‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, ‘Paul’) print L[‘Paul’, ‘Adam’, ‘Lisa’, ‘Bart’] L.insert(0, &#39;Paul&#39;) 的意思是，’Paul’將被添加到索引為0 的位置上（也就是第一個），而原來索引為0 的Adam同學，以及後面的所有同學，都自動向後移動一位。 Python從list刪除元素Paul同學剛來幾天又要轉走了，那麼我們怎麼把Paul 從現有的list中刪除呢？ 如果Paul同學排在最後一個，我們可以用list的pop()方法刪除： L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] L.pop()‘Paul’ print L[‘Adam’, ‘Lisa’, ‘Bart’] pop()方法總是刪掉list的最後一個元素，並且它還返回這個元素，所以我們執行 L.pop() 後，會打印出 ‘Paul’。 如果Paul同學不是排在最後​​一個怎麼辦？比如Paul同學排在第三： L = [‘Adam’, ‘Lisa’, ‘Paul’, ‘Bart’] 要把Paul踢出list，我們就必須先定位Paul的位置。由於Paul的索引是2，因此，用 pop(2)把Paul刪掉： L.pop(2)‘Paul’print L[‘Adam’, ‘Lisa’, ‘Bart’] Python中替换元素假設現在班裡仍然是3名同學： L = [‘Adam’, ‘Lisa’, ‘Bart’] 現在，Bart同學要轉學走了，碰巧來了一個Paul同學，要更新班級成員名單，我們可以先把Bart刪掉，再把Paul添加進來。另一個辦法是直接用Paul把Bart給替換掉： L[2] = ‘Paul’ print LL = [‘Adam’, ‘Lisa’, ‘Paul’] 對list中的某一個索引賦值，就可以直接用新的元素替換掉原來的元素，list包含的元素個數保持不變。 由於Bart還可以用 -1 做索引，因此，下面的代碼也可以完成同樣的替換工作： L[-1] = ‘Paul’ Python之創建tupletuple是另一種有序的列表，中文翻譯為“ 元組 ”。 tuple 和 list 非常類似，但是，tuple一旦創建完畢，就不能修改了。 同樣是表示班裡同學的名稱，用tuple表示如下： t = (‘Adam’, ‘Lisa’, ‘Bart’) 創建tuple和創建list唯一不同之處是用( )替代了[ ]。 現在，這個t 就不能改變了，tuple沒有 append()方法，也沒有insert()和pop()方法。所以，新同學沒法直接往 tuple 中添加，老同學想退出 tuple 也不行。 獲取 tuple 元素的方式和 list 是一模一樣的，我們可以正常使用 t[0]，t[-1]等索引方式訪問元素，但是不能賦值成別的元素，不信可以試試： t[0] = ‘Paul’Traceback (most recent call last): File ““, line 1, in TypeError: ‘tuple’ object does not support item assignment Python之創建單元素tupletuple和list一樣，可以包含 0 個、1個和任意多個元素。 包含多個元素的 tuple，前面我們已經創建過了。 包含 0 個元素的 tuple，也就是空tuple，直接用 ()表示： t = () print t()創建包含1個元素的 tuple 呢？來試試： t = (1) print t1 好像哪裡不對！ t 不是 tuple ，而是整數1。為什麼呢？ 因為()既可以表示tuple，又可以作為括號表示運算時的優先級，結果 (1) 被Python解釋器計算出結果 1，導致我們得到的不是tuple，而是整數 1。 正是因為用()定義單元素的tuple有歧義，所以 Python 規定，單元素 tuple 要多加一個逗號“,”，這樣就避免了歧義： t = (1,) print t(1,) Python在打印單元素tuple時，也自動添加了一個“,”，為了更明確地告訴你這是一個tuple。多元素 tuple 加不加這個額外的“,”效果是一樣的： t = (1, 2, 3,) print t(1, 2, 3) Python之”可變”的tuple前面我們看到了tuple一旦創建就不能修改。現在，我們來看一個“可變”的tuple： t = (‘a’, ‘b’, [‘A’, ‘B’]) 注意到 t 有 3 個元素：&#39;a&#39;，&#39;b&#39;和一個list：[&#39;A&#39;, &#39;B&#39;]。 list作為一個整體是tuple的第3個元素。 list對象可以通過 t[2] 拿到： L = t[2] 然後，我們把list的兩個元素改一改： L[0] = ‘X’ L[1] = ‘Y’ 再看看tuple的內容： print t(‘a’, ‘b’, [‘X’, ‘Y’]) 不是說tuple一旦定義後就不可變了嗎？怎麼現在又變了？ 別急，我們先看看定義的時候tuple包含的3個元素​​： 當我們把list的元素&#39;A&#39;和&#39;B&#39;修改為&#39;X&#39;和&#39;Y&#39;後，tuple變為： 表面上看，tuple的元素確實變了，但其實變的不是 tuple 的元素，而是list的元素。 tuple一開始指向的list並沒有改成別的list，所以，tuple所謂的“不變”是說，tuple的每個元素，指向永遠不變。即指向’a’，就不能改成指向’b’，指向一個list，就不能改成指向其他對象，但指向的這個list本身是可變的！ 理解了“指向不變”後，要創建一個內容也不變的tuple怎麼做？那就必須保證tuple的每一個元素本身也不能變。 條件判斷和循環Python之if語句計算機之所以能做很多自動化的任務，因為它可以自己做條件判斷。 比如，輸入用戶年齡，根據年齡打印不同的內容，在Python程序中，可以用if語句實現： age = 20if age &gt;= 18: print ‘your age is’, age print ‘adult’print ‘END’ 注意: Python代碼的縮進規則。具有相同縮進的代碼被視為代碼塊，上面的3，4行 print 語句就構成一個代碼塊（但不包括第5行的print）。如果 if 語句判斷為 True，就會執行這個代碼塊。 縮進請嚴格按照Python的習慣寫法：4個空格，不要使用Tab，更不要混合Tab和空格，否則很容易造成因為縮進引起的語法錯誤。 注意: if 語句後接表達式，然後用:表示代碼塊開始。 age = 20 if age &gt;= 18:… print ‘your age is’, age… print ‘adult’…your age is 20adult Python之 if-else當if語句判斷表達式的結果為True時，就會執行 if 包含的代碼塊： if age &gt;= 18: print ‘adult’ 如果我們想判斷年齡在18歲以下時，印出 ‘teenager’，怎麼辦？ 方法是再寫一個 if: if age &lt; 18: print ‘teenager’ 或者用 not 運算： if not age &gt;= 18: print ‘teenager’ 細心的同學可以發現，這兩種條件判斷是“非此即彼”的，要么符合條件1，要么符合條件2，因此，完全可以用一個if ... else ... 語句把它們統一起來： if age &gt;= 18: print ‘adult’else: print ‘teenager’ 利用 if … else … 語句，我們可以根據條件表達式的值為 True或者 False，分別執行if代碼塊或者else 代碼塊。 注意: else 後面有個“:”。 Python之 if-elif-else有的時候，一個 if … else … 還不夠用。比如，根據年齡的劃分： 條件1：18歲或以上：adult條件2：6歲或以上：teenager條件3：6歲以下：kid 我們可以用一個 if age &gt;= 18 判斷是否符合條件1，如果不符合，再通過一個 if 判斷 age &gt;= 6 來判斷是否符合條件2，否則，執行條件3： 1234567if age &gt;= 18: print 'adult'else: if age &gt;= 6: print 'teenager' else: print 'kid' 這樣寫出來，我們就得到了一個兩層嵌套的 if … else … 語句。這個邏輯沒有問題，但是，如果繼續增加條件，比如3歲以下是 baby： 12345678910if age &gt;= 18: print 'adult'else: if age &gt;= 6: print 'teenager' else: if age &gt;= 3: print 'kid' else: print 'baby' 這種縮進只會越來越多，代碼也會越來越難看。 要避免嵌套結構的 if … else …，我們可以用 if ... 多個elif ... else ...的結構，一次寫完所有的規則： 12345678 if age &gt;= 18: print 'adult'elif age &gt;= 6: print 'teenager'elif age &gt;= 3: print 'kid'else: print 'baby' elif 意思就是 else if。這樣一來，我們就寫出了結構非常清晰的一系列條件判斷。 特別注意: 這一系列條件判斷會從上到下依次判斷，如果某個判斷為 True，執行完對應的代碼塊，後面的條件判斷就直接忽略，不再執行了。 請思考下面的代碼： 1234567age = 8if age &gt;= 6: print 'teenager'elif age &gt;= 18: print 'adult'else: print 'kid' 當 age = 8 時，結果正確，但 age = 20 時，為什麼沒有打印出 adult？ 如果要修復，應該如何修復？ Python之 for循環list或tuple可以表示一個有序集合。如果我們想依次訪問一個list中的每一個元素呢？比如 list： 1234L = ['Adam', 'Lisa', 'Bart']print L[0]print L[1]print L[2] 如果list只包含幾個元素，這樣寫還行，如果list包含1萬個元素，我們就不可能寫1萬行print。 這時，循環就派上用場了。 Python的 for 循環就可以依次把list或tuple的每個元素迭代出來： 123L = ['Adam', 'Lisa', 'Bart']for name in L: print name 注意: name 這個變量是在 for 循環中定義的，意思是，依次取出list中的每一個元素，並把元素賦值給 name，然後執行for循環體（就是縮進的代碼塊）。 這樣一來，遍歷一個list或tuple就非常容易了 Python之 while循環和 for 循環不同的另一種循環是 while 循環，while 循環不會迭代 list 或 tuple 的元素，而是根據表達式判斷循環是否結束。 比如要從 0 開始打印不大於 N 的整數： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循環每次先判斷 x &lt; N，如果為True，則執行循環體的代碼塊，否則，退出循環。 在循環體內，x = x + 1 會讓x不斷增加，最終因為x &lt; N不成立而退出循環。 如果沒有這一個語句，while循環在判斷 x &lt; N 時總是為True，就會無限循環下去，變成死循環，所以要特別留意while循環的退出條 Python之 break退出循環用 for 循環或者 while 循環時，如果要在循環體內直接退出循環，可以使用 break 語句。 比如計算1至100的整數和，我們用while來實現： 12345678 sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 咋一看， while True 就是一個死循環，但是在循環體內，我們還判斷了x &gt; 100 條件成立時，用break語句退出循環，這樣也可以實現循環的結束。 Python之 continue繼續循環在循環過程中，可以用break退出當前循環，還可以用continue跳過後續循環代碼，繼續下一次循環。 假設我們已經寫好了利用for循環計算平均分的代碼： 1234567 L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 現在老師只想統計及格分數的平均分，就要把x &lt; 60 的分數剔除掉，這時，利用continue，可以做到當x &lt; 60的時候，不繼續執行循環體的後續代碼，直接進入下一次循環： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 Python之 多重循環在循環內部，還可以嵌套循環，我們來看一個例子： 123for x in ['A', 'B', 'C']: for y in ['1', '2', '3']: print x + y x 每循環一次，y 就會循環 3 次，這樣，我們可以打印出一個全排列： A1A2A3B1B2B3C1C2C3 Dict和Set類型Python之什麼是dict我們已經知道，list 和 tuple 可以用來表示順序集合，例如，班裡同學的名字： [‘Adam’, ‘Lisa’, ‘Bart’] 或者考試的成績列表： [95, 85, 59] 但是，要根據名字找到對應的成績，用兩個 list 表示就不方便。 如果把名字和分數關聯起來，組成類似的查找表： 123'Adam' ==&gt; 95'Lisa' ==&gt; 85'Bart' ==&gt; 59 給定一個名字，就可以直接查到分數。 Python的 dict 就是專門幹這件事的。用dict表示“名字”-“成績”的查找表如下： 12345d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 我們把名字稱為key，對應的成績稱為value，dict就是通過key來查找value。 花括號{}表示這是一個dict，然後按照 key: value, 寫出來即可。最後一個 key: value 的逗號可以省略。 由於dict也是集合，len() 函數可以計算任意集合的大小： 12len(d)3 注意: 一個 key-value 算一個，因此，dict大小為3。 Python之訪問dict我們已經能創建一個dict，用於表示名字和成績的對應關係： 12345d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 那麼，如何根據名字來查找對應的成績呢？ 可以簡單地使用 d[key] 的形式來查找對應的 value，這和 list 很像，不同之處是，list 必須使用索引返回對應的元素，而dict使用key： 1234567print d['Adam']95 print d['Paul']Traceback (most recent call last): File "index.py", line 11, in &lt;module&gt; print d['Paul']KeyError: 'Paul' 注意: 通過 key 訪問 dict 的value，只要 key 存在，dict就返回對應的value。如果key不存在，會直接報錯：KeyError。 要避免 KeyError 發生，有兩個辦法： 一是先判斷一下 key 是否存在，用 in 操作符： 12if 'Paul' in d: print d['Paul'] 如果 ‘Paul’ 不存在，if語句判斷為False，自然不會執行 print d[‘Paul’] ，從而避免了錯誤。 二是使用dict本身提供的一個 get 方法，在Key不存在的時候，返回None： 1234&gt;&gt;&gt; print d.get('Bart')59&gt;&gt;&gt; print d.get('Paul')None Python中dict的特點dict的第一個特點是查找速度快，無論dict有10個元素還是10萬個元素，查找速度都一樣。而list的查找速度隨著元素增加而逐漸下降。 不過dict的查找速度快不是沒有代價的，dict的缺點是佔用內存大，還會浪費很多內容，list正好相反，佔用內存小，但是查找速度慢。 由於dict是按 key 查找，所以，在一個dict中，key不能重複。 dict的第二個特點就是存儲的key-value序對是沒有順序的！這和list不一樣： 12345 d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 當我們試圖打印這個dict時： 12 &gt;&gt;&gt; print d&#123;'Lisa': 85, 'Adam': 95, 'Bart': 59&#125; 打印的順序不一定是我們創建時的順序，而且，不同的機器打印的順序都可能不同，這說明dict內部是無序的，不能用dict存儲有序的集合。 dict的第三個特點是作為 key 的元素必須不可變，Python的基本類型如字符串、整數、浮點數都是不可變的，都可以作為 key。但是list是可變的，就不能作為 key。 可以試試用list作為key時會報什麼樣的錯誤。 不可變這個限制僅作用於key，value是否可變無所謂： 12345&#123; '123': [1, 2, 3], # key 是 str，value是list 123: '123', # key 是 int，value 是 str ('a', 'b'): True # key 是 tuple，並且tuple的每個元素都是不可變對象，value是 boolean&#125; 最常用的key還是字符串，因為用起來最方便。 Python更新dictdict是可變的，也就是說，我們可以隨時往dict中添加新的 key-value。比如已有dict： 12345 d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 要把新同學’Paul’的成績 72 加進去，用賦值語句： 1&gt;&gt;&gt; d['Paul'] = 72 再看看dict的內容： 12&gt;&gt;&gt; print d&#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59&#125; 如果 key 已經存在，則賦值會用新的 value 替換掉原來的 value： 123&gt;&gt;&gt; d['Bart'] = 60&gt;&gt;&gt; print d&#123;'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60&#125; Python之 遍歷dict由於dict也是一個集合，所以，遍歷dict和遍歷list類似，都可以通過 for 循環實現。 直接使用for循環可以遍歷 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; for key in d:... print key...LisaAdamBart 由於通過 key 可以獲取對應的 value，因此，在循環體內，可以獲取到value的值。 Python中什麼是setdict的作用是建立一組 key 和一組 value 的映射關係，dict的key是不能重複的。 有的時候，我們只想要 dict 的 key，不關心 key 對應的 value，目的就是保證這個集合的元素不會重複，這時，set就派上用場了。 set 持有一系列元素，這一點和 list 很像，但是set的元素沒有重複，而且是無序的，這點和 dict 的 key很像。 創建 set 的方式是調用 set() 並傳入一個 list，list的元素將作為set的元素： 1&gt;&gt;&gt; s = set(['A', 'B', 'C']) 可以查看 set 的內容： 12&gt;&gt;&gt; print sset(['A', 'C', 'B']) 請注意，上述打印的形式類似 list， 但它不是 list，仔細看還可以發現，打印的順序和原始 list 的順序有可能是不同的，因為set內部存儲的元素是無序的。 因為set不能包含重複的元素，所以，當我們傳入包含重複元素的 list 會怎麼樣呢？12345&gt;&gt;&gt; s = set(['A', 'B', 'C', 'C'])&gt;&gt;&gt; print sset(['A', 'C', 'B'])&gt;&gt;&gt; len(s)3 結果顯示，set會自動去掉重複的元素，原來的list有4個元素，但set只有3個元素。 Python之 訪問set由於set存儲的是無序集合，所以我們沒法通過索引來訪問。 訪問 set中的某個元素實際上就是判斷一個元素是否在set中。 例如，存儲了班裡同學名字的set：1&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart', 'Paul']) 我們可以用 in 操作符判斷： Bart是該班的同學嗎？12&gt;&gt;&gt; 'Bart' in sTrue Bill是該班的同學嗎？12&gt;&gt;&gt; 'Bill' in sFalse bart是該班的同學嗎？12&gt;&gt;&gt; 'bart' in sFalse 看來大小寫很重要，’Bart’ 和 ‘bart’被認為是兩個不同的元素。 Python之 set的特點set的內部結構和dict很像，唯一區別是不存儲value，因此，判斷一個元素是否在set中速度很快。 set存儲的元素和dict的key類似，必須是不變對象，因此，任何可變對像是不能放入set中的。 最後，set存儲的元素也是沒有順序的。 set的這些特點，可以應用在哪些地方呢？ 星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。 假設我們讓用戶輸入星期一至星期日的某天，如何判斷用戶的輸入是否是一個有效的星期呢？ 可以用if 語句判斷，但這樣做非常繁瑣：12345x = '???' # 用戶輸入的字串if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN': print 'input error'else: print 'input ok' 注意：if 語句中的…表示沒有列出的其它星期名稱，測試時，請輸入完整。 如果事先創建好一個set，包含’MON’ ~ ‘SUN’：1weekdays = set(['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']) 再判斷輸入是否有效，只需要判斷該字符串是否在set中：12345x = '???' # 用戶輸入的字串if x in weekdays: print 'input ok'else: print 'input error' 這樣一來，代碼就簡單多了。 Python之 遍歷set由於 set 也是一個集合，所以，遍歷 set 和遍歷 list 類似，都可以通過 for 循環實現。 直接使用 for 循環可以遍歷 set 的元素：1234567&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])&gt;&gt;&gt; for name in s:... print name...LisaAdamBart 注意: 觀察 for 循環在遍歷set時，元素的順序和list的順序很可能是不同的，而且不同的機器上運行的結果也可能不同。 Python之 更新set由於set存儲的是一組不重複的無序元素，因此，更新set主要做兩件事： 一是把新的元素添加到set中，二是把已有元素從set中刪除。 添加元素時，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已經存在於set中，add()不會報錯，但是不會加進去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 刪除set中的元素時，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果刪除的元素不存在set中，remove()會報錯： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判斷。 函數Python之什麼是函數我們知道圓的面積計算公式為： S = πr² 當我們知道半徑r的值時，就可以根據公式計算出面積。假設我們需要計算3個不同大小的圓的面積： r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 r1 r1s2 = 3.14 r2 r2s3 = 3.14 r3 r3 當代碼出現有規律的重複的時候，你就需要當心了，每次寫3.14 x x不僅很麻煩，而且，如果要把3.14改成3.14159265359的時候，得全部替換。 有了函數，我們就不再每次寫s = 3.14 x x，而是寫成更有意義的函數調用s = area_of_circle(x)，而函數 area_of_circle 本身只需要寫一次，就可以多次調用。 抽像是數學中非常常見的概念。舉個例子： 計算數列的和，比如：1 + 2 + 3 + ... + 100，寫起來十分不方便，於是數學家發明了求和符號∑，可以把1 + 2 + 3 + … + 100記作： 100∑nn=1 這種抽象記法非常強大，因為我們看到∑就可以理解成求和，而不是還原成低級的加法運算。 而且，這種抽象記法是可擴展的，比如： 100∑(n²+1)n=1 還原成加法運算就變成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1) 可見，借助抽象，我們才能不關心底層的具體計算過程，而直接在更高的層次上思考問題。 寫計算機程序也是一樣，函數就是最基本的一種代碼抽象的方式。 Python不但能非常靈活地定義函數，而且本身內置了很多有用的函數，可以直接調用。 Python之調用函數Python內置了很多有用的函數，我們可以直接調用。 要調用一個函數，需要知道函數的名稱和參數，比如求絕對值的函數 abs，它接收一個參數。 可以直接從Python的官方網站查看文檔：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通過help(abs)查看abs函數的幫助信息。 調用abs函數： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 調用函數的時候，如果傳入的參數數量不對，會報TypeError的錯誤，並且Python會明確地告訴你：abs()有且僅有1個參數，但給出了兩個： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果傳入的參數數量是對的，但參數類型不能被函數所接受，也會報TypeError的錯誤，並且給出錯誤信息：str是錯誤的參數類型： 1234&gt;&gt;&gt; abs('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' 而比較函數cmp(x, y) 就需要兩個參數，如果x&lt;y，返回-1，如果 x==y，返回 0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python內置的常用函數還包括數據類型轉換函數，比如int()函數可以把其他數據類型轉換為整數： 1234&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12 str()函數把其他類型轉換成 str： 1234&gt;&gt;&gt; str(123)'123'&gt;&gt;&gt; str(1.23)'1.23' Python之編寫函數在Python中，定義一個函數要使用def語句，依次寫出函數名、括號、括號中的參數和冒號:，然後，在縮進塊中編寫函數體，函數的返回值用 return 語句返回。 我們以自定義一個求絕對值的 my_abs 函數為例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 請注意，函數體內部的語句在執行時，一旦執行到return時，函數就執行完畢，並將結果返回。因此，函數內部通過條件判斷和循環可以實現非常複雜的邏輯。 如果沒有return語句，函數執行完畢後也會返回結果，只是結果為 None。 return None可以簡寫為return。 Python函數之返回多值函數可以返回多個值嗎？答案是肯定的。 比如在遊戲中經常需要從一個點移動到另一個點，給出坐標、位移和角度，就可以計算出新的坐標： # math包提供了sin()和 cos()函數，我們先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 這樣我們就可以同時獲得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其實這只是一種假象，Python函數返回的仍然是單一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 用print打印返回結果，原來返回值是一個tuple！ 但是，在語法上，返回一個tuple可以省略括號，而多個變量可以同時接收一個tuple，按位置賦給對應的值，所以，Python的函數返回多值其實就是返回一個tuple，但寫起來更方便。 Python之遞歸函數在函數內部，可以調用其他函數。如果一個函數在內部調用自身本身，這個函數就是遞歸函數。 舉個例子，我們來計算階乘n! = 1 * 2 * 3 * ... * n，用函數 fact(n)表示，可以看出： 1fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n 所以，fact(n)可以表示為n * fact(n-1)，只有n=1時需要特殊處理。 於是，fact(n)用遞歸的方式寫出來就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一個遞歸函數。可以試試： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L 如果我們計算fact(5)，可以根據函數定義看到計算過程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 遞歸函數的優點是定義簡單，邏輯清晰。理論上，所有的遞歸函數都可以寫成循環的方式，但循環的邏輯不如遞歸清晰。 使用遞歸函數需要注意防止棧溢出。在計算機中，函數調用是通過棧（stack）這種數據結構實現的，每當進入一個函數調用，棧就會加一層棧幀，每當函數返回，棧就會減一層棧幀。由於棧的大小不是無限的，所以，遞歸調用的次數過多，會導致棧溢出。可以試試計算 fact(10000)。 Python之定義默認參數定義函數的時候，還可以有默認參數。 例如Python自帶的int()函數，其實就有兩個參數，我們既可以傳一個參數，又可以傳兩個參數：1234&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int('123', 8)83 int()函數的第二個參數是轉換進制，如果不傳，默認是十進制 (base=10)，如果傳了，就用傳入的參數。 可見，函數的默認參數的作用是簡化調用，你只需要把必須的參數傳進去。但是在需要的時候，又可以傳入額外的參數來覆蓋默認參數值。 我們來定義一個計算 x 的N次方的函數:123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假設計算平方的次數最多，我們就可以把 n 的默認值設定為 2：123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 這樣一來，計算平方就不需要傳入兩個參數了：12&gt;&gt;&gt; power(5)25 由於函數的參數按從左到右的順序匹配，所以默認參數只能定義在必需參數的後面：123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass Python之定義可變參數如果想讓一個函數能接受任意個參數，我們就可以定義一個可變參數： 12def fn(*args): print args 可變參數的名字前面有個 *號，我們可以傳入0個、1個或多個參數給可變參數：12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b')&gt;&gt;&gt; fn('a', 'b', 'c')('a', 'b', 'c') 可變參數也不是很神秘，Python解釋器會把傳入的一組參數組裝成一個tuple傳遞給可變參數，因此，在函數內部，直接把變量 args 看成一個tuple就好了。 定義可變參數的目的也是為了簡化調用。假設我們要計算任意個數的平均值，就可以定義一個可變參數：12def average(*args): ... 這樣，在調用的時候，可以這樣寫：123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 切割對list進行切割取一個list的部分元素是非常常見的操作。比如，一個list如下： 1&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul'] 取前3個元素，應該怎麼做？ 笨辦法：12&gt;&gt;&gt; [L[0], L[1], L[2]]['Adam', 'Lisa', 'Bart'] 之所以是笨辦法是因為擴展一下，取前N個元素就沒轍了。 取前N個元素，也就是索引為0-(N-1)的元素，可以用循環：1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])...&gt;&gt;&gt; r['Adam', 'Lisa', 'Bart'] 對這種經常取指定索引範圍的操作，用循環十分繁瑣，因此，Python提供了切片（Slice）操作符，能大大簡化這種操作。 對應上面的問題，取前3個元素，用一行代碼就可以完成切片： 12&gt;&gt;&gt; L[0:3]['Adam', 'Lisa', 'Bart'] L[0:3]表示，從索引0開始取，直到索引3為止，但不包括索引3。即索引0，1，2，正好是3個元素。 如果第一個索引是0，還可以省略： 12&gt;&gt;&gt; L[:3]['Adam', 'Lisa', 'Bart'] 也可以從索引1開始，取出2個元素出來： 12&gt;&gt;&gt; L[1:3]['Lisa', 'Bart'] 只用一個 : ，表示從頭到尾： 12&gt;&gt;&gt; L[:]['Adam', 'Lisa', 'Bart', 'Paul'] 因此，L[:]實際上複製出了一個新list。 切片操作還可以指定第三個參數： 12&gt;&gt;&gt; L[::2]['Adam', 'Bart'] 第三個參數表示每N個取一個，上面的 L[::2] 會每兩個元素取出一個來，也就是隔一個取一個。 把list換成tuple，切片操作完全相同，只是切片的結果也變成了tuple。 倒序切割對於list，既然Python支持L[-1]取倒數第一個元素，那麼它同樣支持倒數切片，試試： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L[-2:]['Bart', 'Paul']&gt;&gt;&gt; L[:-2]['Adam', 'Lisa']&gt;&gt;&gt; L[-3:-1]['Lisa', 'Bart']&gt;&gt;&gt; L[-4:-1:2]['Adam', 'Bart'] 記住倒數第一個元素的索引是-1。倒序切片包含起始索引，不包含結束索引。 對字符串切割字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一種list，每個元素就是一個字符。因此，字符串也可以用切片操作，只是操作結果仍是字符串： 123456&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[-3:]'EFG'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 在很多編程語言中，針對字符串提供了很多各種截取函數，其實目的就是對字符串切片。 Python沒有針對字符串的截取函數，只需要切片一個操作就可以完成，非常簡單。 任務字符串有個方法 upper() 可以把字符變成大寫字母：12&gt;&gt;&gt; 'abc'.upper()'ABC' 但它會把所有字母都變成大寫。請設計一個函數，它接受一個字符串，然後返回一個僅首字母變成大寫的字符串。 提示：利用切片操作簡化字符串操作。 迭代什麼是迭代在Python中，如果給定一個list或tuple，我們可以通過for循環來遍歷這個list或tuple，這種遍歷我們成為迭代（Iteration）。 在Python中，迭代是通過 for ... in 來完成的，而很多語言比如C或者Java，迭代list是通過下標完成的，比如Java代碼： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循環抽象程度要高於Java的for循環。 因為 Python 的 for循環不僅可以用在list或tuple上，還可以作用在其他任何可迭代對像上。 因此，迭代操作就是對於一個集合，無論該集合是有序還是無序，我們用 for 循環總是可以依次取出集合的每一個元素。&gt;注意: 集合是指包含一組元素的數據結構，我們已經介紹的包括： 有序集合：list，tuple，str和unicode； 無序集合：set 無序集合併且具有 key-value 對：dict而迭代是一個動詞，它指的是一種操作，在Python中，就是 for 循環。 迭代與按下標訪問數組最大的不同是，後者是一種具體的迭代實現方式，而前者只關心迭代結果，根本不關心迭代內部是如何實現的。 索引迭代Python中，迭代永遠是取出元素本身，而非元素的索引。 對於有序集合，元素確實是有索引的。有的時候，我們確實想在 for 循環中拿到索引，怎麼辦？ 方法是使用enumerate() 函數： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; for index, name in enumerate(L):... print index, '-', name...0 - Adam1 - Lisa2 - Bart3 - Paul``使用 enumerate() 函數，我們可以在for循環中同時綁定索引index和元素name。但是，這不是 enumerate() 的特殊語法。實際上，enumerate() 函數把：``` python['Adam', 'Lisa', 'Bart', 'Paul'] 變成了類似：1[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')] 因此，迭代的每一個元素實際上是一個tuple：1234for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 如果我們知道每個tuple元素都包含兩個元素，for循環又可以進一步簡寫為：12for index, name in enumerate(L): print index, '-', name 這樣不但代碼更簡單，而且還少了兩條賦值語句。 可見，索引迭代也不是真的按索引訪問，而是由 enumerate() 函數自動把每個元素變成 (index, element) 這樣的tuple，再迭代，就同時獲得了索引和元素本身。 迭代dict的value我們已經了解了dict對象本身就是可迭代對象，用 for 循環直接迭代 dict，可以每次拿到dict的一個key。 如果我們希望迭代 dict 對象的value，應該怎麼做？ dict 對像有一個 values() 方法，這個方法把dict轉換成一個包含所有value的list，這樣，我們迭代的就是 dict的每一個 value： 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔細閱讀Python的文檔，還可以發現，dict除了values()方法外，還有一個 itervalues() 方法，用 itervalues()方法替代 values() 方法，迭代效果完全一樣： 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那這兩個方法有何不同之處呢？ values() 方法實際上把一個 dict 轉換成了包含 value 的list。 但是 itervalues() 方法不會轉換，它會在迭代過程中依次從 dict 中取出 value，所以 itervalues() 方法比 values() 方法節省了生成 list 所需的內存。 打印itervalues() 發現它返回一個 對象，這說明在Python中，for 循環可作用的迭代對象遠不止list，tuple，str，unicode，dict等，任何可迭代對像都可以作用於for循環，而內部如何迭代我們通常並不用關心。 如果一個對像說自己可迭代，那我們就直接用 for 循環去迭代它，可見，迭代是一種抽象的數據操作，它不對迭代對象內部的數據有任何要求。 迭代dict的key和value我們了解瞭如何迭代 dict 的key和value，那麼，在一個 for 循環中，能否同時迭代 key和value？答案是肯定的。 首先，我們看看 dict 對象的 items() 方法返回的值： 123&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; print d.items()[('Lisa', 85), ('Adam', 95), ('Bart', 59)] 可以看到，items() 方法把dict對象轉換成了包含tuple的list，我們對這個list進行迭代，可以同時獲得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, ':', value...Lisa : 85Adam : 95Bart : 59 和values() 有一個itervalues() 類似，items() 也有一個對應的iteritems()，iteritems() 不把dict轉換成list，而是在迭代過程中不斷給出tuple，所以， iteritems() 不佔用額外的內存。 列表生成式生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我們可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎麼做？方法一是循環：123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循環太繁瑣，而列表生成式則可以用一行語句代替循環生成上面的list：12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 這種寫法就是Python特有的列表生成式。利用列表生成式，可以以非常簡潔的代碼生成 list。 寫列表生成式時，把要生成的元素 x * x 放到前面，後面跟 for 循環，就可以把list創建出來，十分有用，多寫幾次，很快就可以熟悉這種語法。 複雜表達式使用for循環的迭代不僅可以迭代普通的list，還可以迭代dict。 假設有如下的dict： 1d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125; 完全可以通過一個複雜的列表生成式把它變成一個 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;' 注：字串可以通過 % 進行格式化，用指定的參數替代 %s。字符串的join()方法可以把一個 list 拼接成一個字符串。 把列印出來的結果保存為一個html文件，就可以在瀏覽器中看到效果了： 123456&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 條件過濾列表生成式的 for 循環後面還可以加上 if 判斷。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我們只想要偶數的平方，不改動 range()的情況下，可以加上 if 來篩選：12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 條件，只有 if 判斷為 True 的時候，才把循環的當前元素添加到列表中。 多層表達式for循環可以嵌套，因此，在列表生成式中，也可以用多層for循環來生成列表。 對於字符串 ‘ABC’ 和 ‘123’，可以使用兩層循環，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻譯成循環代碼就像下面這樣：1234L = []for m in 'ABC': for n in '123': L.append(m + n) 結尾 python 官方文檔 花了好幾個小時終於把他打完了..程式語言邏輯上其實都是一樣的這篇對於沒學過程式語言的想學python 也是很棒的寫過程式語言的 剛踏入python 也是很有幫助的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將excel-讀到JAVA上]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87excel-%E8%AE%80%E5%88%B0JAVA%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[使用 jxl 把Excel讀取到java 上一篇 把資料寫入到Excel 這篇就順便將讀取到java補上了說明都打在註解上了!!就不在多做說明了 java123456789101112131415161718192021222324252627282930313233343536373839404142package excel;import java.io.File;import java.io.IOException;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;import jxl.read.biff.BiffException;public class ReadExcel&#123; //JXL讀取EXCEL public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //建立 workbook Workbook workbook = Workbook.getWorkbook(new File("C:/jxl_test.xls")); //得到第一個工作表 Sheet sheet = workbook.getSheet(0); //取得資料 for (int i = 0; i &lt; sheet.getRows(); i++) //行 &#123; for (int j = 0; j &lt; sheet.getColumns(); j++)//列 &#123; Cell cell= sheet.getCell(j,i); System.out.print(cell.getContents()+" "); &#125; System.out.println(); //換行 &#125; workbook.close(); //將workbook關閉 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用jxl將java資料導入excel]]></title>
      <url>%2F2017%2F03%2F27%2F%E4%BD%BF%E7%94%A8jxl%E5%B0%87java%E8%B3%87%E6%96%99%E5%B0%8E%E5%85%A5excel%2F</url>
      <content type="text"><![CDATA[使用java_將資料導入excel 最近在把公司舊的ERP HR系統 移植出來必須要用最快的方式移植出來不然我本來的專案會趕不上進度順便找時間記錄一下最近開發紀錄 excel 幾種實現方式!POI poi 是 apache poi開放源碼函式庫提供java對 Microsoft office 格式檔案讀寫功能通過HSSF可以使用純JAVA代碼來讀取 寫入 修改EXCELHSSF -讀寫Microsoft Excel格式檔案功能(只支援97-2003)XSSF -讀寫Microsoft Excel OOXML格式檔案功能HWPF -讀寫讀寫Microsoft Word格式檔案功能HSLF -讀寫讀寫Microsoft PowerPoint格式檔案功能HDGF -讀寫讀寫Microsoft Visio格式檔案功能-iText 可以通過iText 來建立PDF 只需在classpath加入iText.jar JXL 有興趣的在去查一下 FASTEXCEL 是一個採用純java 開發的excel文件讀寫組件 支持Excel 97-2003fastExcel 只能讀取單元格的字串資料其他屬性 像是顏色 字體就不支持 但也因為這樣FastExcel 需要用到的記憶體很少 JXL java excel 可以讀取Excel文件內容 建立excel文件 更新已存在的excel POI JXK 比較 效率高 功能強大使用上比較複雜 支持公式 圖表 能夠修改單元屬性格 支持字體 數字 日期操作 JXL 效率低 操作簡單 部分支援 能夠修改單元格屬性 但不比POI強大 支援字體 數字 日期 使用JXL程式碼實例 程式都註解上去了!由於時間的關係需要快速的去開發就嘗試幾個方法開發 需要更快速的來去完成工作才是目標所以選擇使用 JXL 有空再把POI程式碼貼上來 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package excel;import java.awt.Label;import java.io.File;import java.io.IOException;import jxl.Workbook;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class excel&#123; //jxl 建立 excel public static void main(String[] args) &#123; String[] title = &#123;"id","name","sex"&#125;; //建立文件 File file = new File("C:/jxl_test.xls"); try &#123; file.createNewFile(); //建立 工作簿 WritableWorkbook workbook = Workbook.createWorkbook(file); //建立 Sheet WritableSheet sheet = workbook.createSheet("sheet1", 0); jxl.write.Label label=null; for (int i = 0; i &lt; title.length; i++) &#123; //第一行 設定列名 label = new jxl.write.Label(i, 0, title[i]); sheet.addCell(label); &#125; //增加資料 for (int i = 1; i &lt; 10; i++) &#123; label = new jxl.write.Label(0, i, "a"+1); sheet.addCell(label); label = new jxl.write.Label(1, i, "user"+1); sheet.addCell(label); label = new jxl.write.Label(2, i, "男"+1); sheet.addCell(label); &#125; //寫入 workbook.write(); //關閉 workbook.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 效果圖 ``` JXL.jar 下載點分享 JXL.jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-txt資料讀取存入SQL]]></title>
      <url>%2F2017%2F03%2F24%2Fjava-txt%E8%B3%87%E6%96%99%E8%AE%80%E5%8F%96%E5%AD%98%E5%85%A5SQL%2F</url>
      <content type="text"><![CDATA[java-txt資料讀取存入SQL前言 最近實在太忙了.沒什麼時間更新blog.本來打算寫專案過程可以抓時間學習python主管最近突然跟我說10天要把舊ERP的一個員工教育訓練的程式移植出來.由於舊ERP太爛了沒有用SQL..資料是儲存在txt..!!!就只好寫個程式來匯入 由於時間太趕了..就不太注重細節趕快把這寫出來如果是csv檔案的話稍微修改就可以用了! txt資料 “345”|”456”|”xxxx”|4|12/05/11|12/05/11|0|””|0|””|”name”|12/06/01先寫程式把資料的 “ | 這兩個符號先更改改完如下 #345#@#456#@#xxxx#@4@12/05/11@12/05/11@0@##@0@##@#name#@12/06/01 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import utils.sqlconnection;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Array;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class SQL extends sqlconnection&#123; public static void main(String[] args) &#123; try &#123; java.sql.Connection conn; try &#123; conn = DriverManager.getConnection(CONNURL, SQL_NAME,SQL_PASSWORD); PreparedStatement pstmt = conn.prepareStatement(SQL_INSERT); FileReader fr = new FileReader(FILE_PATH); BufferedReader brdFile = new BufferedReader(fr); String strLine = null; while ((strLine = brdFile.readLine()) != null) &#123; strLine = strLine.replace("#", "");//先將資料夾裡面的#改成"" String[] array = strLine.split("@");// 因為是用"@"分開所以用split切開存入字串陣列 System.out.println(strLine); for (int i = 0; i &lt; array.length; i++) &#123;// System.out.println(array[i]); 可以用來檢視分割的檔案是否正確 pstmt.setString(i+1,array[i]); &#125; pstmt.execute(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL語法紀錄]]></title>
      <url>%2F2017%2F03%2F05%2FSQL%E8%AA%9E%E6%B3%95%E7%B4%80%E9%8C%84%2F</url>
      <content type="text"><![CDATA[SQL語法紀錄前言一直以來只記得 select insert drop…每次要用都忘記..還是來記錄一下! 基礎語法 操作功能 SQL 語法 說明 建立資料庫 create database 資料庫名稱; 列出所有資料庫 show databases; 刪除資料庫 drop database 資料庫名稱; 使用資料庫 use 資料庫名稱; 建立資料表 create table 資料表名稱(&lt;br&gt;sn integer auto_increment primary key,&lt;br&gt;name char(20),&lt;br&gt;mail char(50),&lt;br&gt;home char(50),&lt;br&gt;messages char(50)); 常用資料庫資料型態 1. INT (整數) 2. CHAR (1~255字元字串) 3. VARCHAR (不超過255字元不定長度字串) 4. TEXT (不定長度字串最多65535字元) 列出資料表欄位資訊 describe 資料表名稱; 修改資料表欄位 alter table 資料表名稱&lt;br&gt;change column 原來欄位名稱&lt;br&gt;新欄位名稱資料型態; 新增資料表欄位 alter table 資料表名稱 add &lt;br&gt;column 欄位名稱 資料型態; 刪除資料表欄位 alter table 資料表名稱 drop column 欄位名稱; 刪除資料表 drop table 資料表名稱; 清空資料表 truncate table 資料表名稱; 只清除資料並保留結構、欄位、索引 … 插入欄位資料 insert into 資料表名稱(欄位1,欄位2,欄位3,欄位4, ...... 欄位N)&lt;br&gt;values(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;,&#39;值4&#39;, ...... &#39;值N&#39;); 更新修改欄位資料 update 資料表名稱 set 欄位1=&#39;值1&#39;,欄位2=&#39;值2&#39;,欄位3=&#39;值3&#39;,... &lt;br&gt;欄位N=&#39;值N&#39;where 條件式 (例如 sn=&#39;5&#39; 或 name=&#39;塔司尼&#39; ); 查詢單一欄位資料 select 欄位名 from 資料表名稱; 查詢多個欄位資料 select 欄位名, 欄位名, 欄位名 from 資料表名稱; 查詢欄位資料的唯一值 select distinct 欄位名 from 資料表名稱; 重複值只列一次 查詢所有欄位資料 select * from 資料表名稱; 條件式查詢 select * from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39;); （=, &lt;, &gt;, !=） 條件式查詢 and select * from 資料表名稱 where 條件式1 and 條件式2; 條件式查詢 or select * from 資料表名稱 where 條件式1 or 條件式2; 查詢某一範圍 between select * from 資料表名稱 where 欄位名 between 值1 and 值2; 值為數字 查詢空值欄位的資料 select * from 資料表名稱 where 欄位名 is null not null; 查詢特定筆數資料 select * from 資料表名稱 limit 8, 10; 第9筆開始選取10筆 查詢結果遞增排序 select * from 資料表名稱 order by 欄位名; 查詢結果遞減排序 select * from 資料表名稱 order by 欄位名 desc ; 查詢比對字串列出單一欄位 select 欄位名 from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 查詢比對字串列出所有欄位 select * from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 刪除條件值資料 delete from 資料表名稱 where 條件式 (例如 sn=&#39;5&#39; 或 id=&#39;91001&#39; ); 刪除條件值資料 delete from 資料表名稱 where 條件式1 and 條件式2; 刪除條件值資料 delete from 資料表名稱 where 條件式1 or 條件式2; 比對刪除條件值資料 delete from 資料表名稱 where 欄位名 like &#39;%字串%&#39;; 一筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;; 兩筆數值找尋資料 Select * from XXXX where XXXX = &#39;XXX&#39;and xxxx=&#39;xxxx&#39;; 一筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39;; 兩筆資料找尋刪除資料 delete from XXXX where xxxx=&#39;xxxx&#39; and xxxx=&#39;xxxx&#39;; 進階語法 操作功能 SQL 語法 說明 查看正在執行的行程 show processlist; 查看 Master 狀態 show master status; 查看 Slave 狀態 show slave status\G; 查看 binlog 狀態 show binary logs; 清除過時的 binlog purge binary logs to &#39;mysql-bin.000006&#39;; 將刪除 mysql-bin.000001 ~ 5 的 binlog 參考資料 SQL常用參考資料1 SQL常用參考資料2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[詳細解讀DialogFragment]]></title>
      <url>%2F2017%2F01%2F20%2F%E8%A9%B3%E7%B4%B0%E8%A7%A3%E8%AE%80DialogFragment%2F</url>
      <content type="text"><![CDATA[DialogFragment 版權聲明：轉載請保留原文連結及作者http://www.cnblogs.com/tianzhijiexian/p/4161811.html 相信看這篇文章的人都應該知道android中的Dialog了吧，如果對於Dialog還不是很了解可以看我之前的一篇詳解文章：Dialog詳解：http://www.cnblogs.com/tianzhijiexian/p/3867731.html隨著Fragment這個類的引入，Google官方推薦大家使用DialogFragment來代替傳統的Dialog，那麼是不是說我們之前學習的Dialog知識都沒有用處了呢？非也，新的fragment是來方便大家更好的管理和重用Dialog，之前的知識其實都是可以拿來就用的，僅僅需要少許的改變。 Dialog和DialogFragment的區別和優劣 新來的DialogFragment讓dialog也變成了碎片，相比之前來說應該做了很多優化和處理，對於程序員來看對話框現在更加具體了，就是一個activity上的一個fragment，我們也可以用fragment的知識來管理對話框了。我們看看之前是怎麼運用對話框對象的 1234AlertDialog dialog = new AlertDialog.Builder( this ) .setTitle( "Dialog" ) .setMessage( "thisis a dialog" ) .show(); 如果這個時候屏幕方向發生變化，就會導致Activity重建，然後之前顯示的對話框就不見了。查看log可以發現這個錯誤： 04-1917:30:06.999: E/WindowManager(14495): Activitycom.example.androidtest.MainActivity has leaked windowcom.android.internal.policy.impl.PhoneWindow$DecorView{42ca3c18 V.E…..R……. 0,0-1026,414} that was originally added here 當然我們也可以無視這個錯誤，因為程序不會因此崩潰（看來android本身就已經預料到這種情況了）。 如果我們想要在旋轉屏幕的時候也能保證這個對話框顯示就需要做一定的處理了，在activity要銷毀前設立一個標誌，看這時對話框是否是顯示狀態，如果是那麼activity在下次建立時直接顯示對話框。 在onSaveInstanceState中1234567@Override protected void onSaveInstanceState(Bundle outState) &#123; super .onSaveInstanceState(outState); if (dialog != null &amp;&amp; dialog.isShowing()) &#123; outState.putBoolean( "DIALOG_SHOWN", true ); &#125; &#125; 在onCreat中123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null ) &#123; boolean isShown = savedInstanceState.getBoolean("DIALOG_SHOWN" ); if (isShown) &#123; AlertDialog dialog = new AlertDialog.Builder( this ).setTitle("Dialog" ) .setMessage( "thisis a dialog" ).show(); &#125; &#125; ……&#125; 使用DialogFragment來管理對話框就不會有這種問題了，代碼也少了很多的邏輯處理。當你旋轉屏幕的時候，fragmentManager會自定管理DialogFragment的生命週期，如果當前已經顯示在屏幕上了，那麼旋轉屏幕後夜會自動顯示，下面就是在屏幕旋轉時的log輸出。12345678910111213141516171819202122234-1917:45:41.289: D/==========(16156): MyDialogFragment : onAttach04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreate04-1917:45:41.299: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:41.309: D/==========(16156): MyDialogFragment : onStart04-1917:45:50.619: D/==========(16156): MyDialogFragment : onStop04-1917:45:50.619: D/==========(16156): third activity on destroy04-1917:45:50.619:D/==========(16156): MyDialogFragment : onDestroyView04-1917:45:50.619: D/==========(16156): MyDialogFragment : onDetach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onAttach04-1917:45:50.639: D/==========(16156): MyDialogFragment : onCreate04-1917:45:50.659: D/==========(16156): MyDialogFragment : onCreateView04-1917:45:50.659: D/==========(16156): MyDialogFragment : onStart Ok，當然你可以不以為然，你說我的應用就是豎著用的，旋轉屏幕畢竟是小概率事件，誰會開著對話框旋轉來旋轉去啊。那麼相信下面的好處你一定不能否定吧。 我們之前用Dialog的時候，在activity中必須要建立這個對象，而且一般我們都是需要給它放監聽器的，比如下面的代碼： 12345678910111213141516171819202122@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.guid_main); new AlertDialog.Builder(GuideActivity. this ).setTitle("用戶申明" ) .setMessage(getResources().getString(R.string.statement)) .setPositiveButton( "我同意", new positiveListener()) .setNegativeButton( "不同意", new negativeListener()) .setCancelable( false ) .show(); &#125; private class positiveListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; prefs.setIsFirstTime( false ); &#125; &#125; private class negativeListener implements DialogInterface.OnClickListener &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Util.virtualHome(GuideActivity. this ); &#125; &#125; 你會發現這麼長的代碼很破壞activity中的邏輯性，有木有！！！在activity中我們處理的各種控件的顯示和邏輯，但對於dialog這種不屬於activity並且建立和處理邏輯都自成一體的東西，我們為什麼要在activity中建立呢？而且為了方便重用，我們在實際過程中基本都會建立一個dialog的工具類來做處理，所以為什麼不用DialogFragment來實現呢？如果通過它來實現，我們就能很方便的進行管理對話框。 此外，當旋轉屏幕和按下後退鍵時可以更好的管理其聲明周期，它和Fragment有著基本一致的聲明周期。且DialogFragment也允許開發者把Dialog作為內嵌的組件進行重用，類似Fragment（可以在大屏幕和小屏幕顯示出不同的效果）。有可能我們在大屏幕上就不需要彈出一個對話框了，直接內嵌在activity界面中顯示即可。這點也很贊！ DialogFragment的最簡單用法使用DialogFragment很簡單，甚至比用Fragment還簡單，因為在api中已經實現了fragment切換對象了。 建立一個fragment對象123456789101112131415161718package com.kale.dialogfragmenttest;import android.app.DialogFragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup;public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); // tag which is from acitivity which started this fragment return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 我們建立了一個fragment，讓他繼承了DialogFragment，在onCreatView中通過佈局文件建立了一個view，這和fragment完全一致。 佈局文件如下： 1234567891011121314151617181920212223242526272829303132&lt;? xml version="1.0" encoding="utf-8" ?&gt;&lt; LinearLayout xmlns:android ="http://schemas.android.com/apk/res/android" android:layout_width ="match_parent" android:layout_height ="match_parent" android:orientation ="vertical" android:padding ="16dp" &gt; &lt; TextView android:id ="@+id/textView1" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Large Text" android:textAppearance ="?android:attr/textAppearanceLarge" /&gt; &lt; EditText android:layout_marginTop ="10dp" android:id ="@+id/editText1" android:layout_width ="match_parent" android:layout_height ="wrap_content" android:ems ="10" &gt; &lt; requestFocus /&gt; &lt;/ EditText &gt; &lt; Button android:id ="@+id/button1" android:layout_marginTop ="10dp" android:layout_gravity ="center_horizo​​ntal" android:layout_width ="wrap_content" android:layout_height ="wrap_content" android:text ="Button" /&gt;&lt;/ LinearLayout &gt; 在activity中啟用這個dialog12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new DialogFragmentTest() .show(getFragmentManager(), "dialog_fragment" ); &#125; 很像Dialog吧，也是支持鍊式編程的。這裡面的參數： ① 一個fragmentManager，在低版本中用getSupport來獲取；② 一個tag（String）通過這個tag可以告訴fragment是誰啟動了它，當然這僅僅是這個tag的一種使用方式啦。在fragment中可以通過getTag()方法來獲取這個tag 這裡多說一句，在一年前我還一直說要兼容要兼容，不兼容的demo是很不負責任的，但是現在來看，低版本的用戶真的很少很少了，而且這些低版本的用戶已經不能是我們的主流用戶了，所以在2014年末，我可以負責任的說，可以不用兼容2.x的系統了。我之前寫過很多兼容的文章，actionbar啊，對話框的兼容啊，但現在都變得無所謂了，其實任何事物的發展都是如此。很多之前很重要的技術，在新的發展中已經慢慢變得無足輕重了，但我們之前為之付出的東西卻不是無價值的。一個原因是為自己之前的工作找到價值，一種是在那段時光中我們慢慢體會到了很多東西，這些東西就是我們的閱歷也是一種談資。 好，閒話少敘，下面是運行效果： 有人會說，上面的那個空白的title好醜，我想去掉。當然可以，這就是fragment的好處，用這個方法： getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); 12345678910public class MyDialogFragment extends DialogFragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; System.out.println( "tag = "+ getTag()); getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); return inflater.inflate(R.layout.dialog, null ); &#125;&#125; 現在它變成了這個樣子： 所以你可以看到，任何改變都是要付出代價的，如果你還是像之前一樣用match_parent來製定控件的寬度，那麼就是這種結果。可以說那個title欄就是一個房梁，支撐著對話框的寬度，沒了它就只能自適應了。解決辦法就是自定義控件的寬度，寫個幾百dp啥的，沒任何技術難度。 注意： 如果你的DialogFragment是Activity的內部類，必須將DialogFragment定義為靜態的。否則會報錯！！！ 123456789public static class DialogFragmentTest extends DialogFragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // TODO自動生成的方法存根 return inflater.inflate(R.layout.dialog, null ); &#125; &#125; DialogFragment啟動、終止過程分析之前說了，我們沒有像fragment那樣建立一個fragment加載對象進行fragment的加載，也沒有commit，但卻能使用dialogFragment對象，這是為什麼呢？ 我們先來回顧下fragment是怎麼使用的。 ① 建立FragmentManager對象，用來管理fragment ② 建立fragmentTransaction對象，用來添加和fragment ③ 提交fragment切換（commit） 123456FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction ft = fragmentManager.beginTransaction(); ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE); ft.add(R.id.container_fragment, new MyFragment()) .commit(); 替換fragment的方法 1234getSupportFragmentManager().beginTransaction(). replace(R.id.container_fragment02, fragment) .addToBackStack( null ) .commit(); 現在，我們通過源碼來分析下DialogFragment的啟動方式 我們在使用它的時候沒有去用fragmentTransaction對象，也沒有執行add，也沒有執行commit，僅僅提供了一個fragmentManager，那麼它是怎麼被添加的呢？我們知道這個對話框是用show方法顯示的，那麼就來看看這個方法吧。 DialogFragment源碼：1.show()1234567public void show(FragmentManager manager, String tag)&#123; mDismissed = false ; mShownByMe = true ; FragmentTransaction ft = manager.beginTransaction(); // creat a fragmentTransaction ft.add( this , tag); // add fragment with tag ft.commit(); &#125; 真相大白，api自動給你實現了一個fragment切換的對象，而且在show的時候就已經add了fragment，所以沒有任何問題~ 在add方法中沒有提供容器的id，所以表示是加載到當前activity中的，在添加後也的確調用了commit方法3 show()的另一種形式12345678public int show(FragmentTransaction transaction, String tag) &#123; mDismissed = false ; mShownByMe = true ; transaction.add( this , tag); mViewDestroyed = false ; mBackStackId = transaction.commit(); return mBackStackId; &#125; 上面的show方法傳入的是一個fragmentTransaction對象，這個也很容易理解。我們之前傳入fragmentManager對象的目的就是生成這個fragmentTransaction對象，這回我們可以在傳入一個已經配置好的fragmentTransaction對象，大大增加了可定制性。所以api的製訂也是大神們心血的結晶啊。 dimiss()1234567891011121314151617181920212223242526272829303132333435** * Dismiss the fragment and its dialog. If the fragment was added to the * back stack, all back stack state up to and including this entry will * be popped. Otherwise, a new transaction will be committed to remove * the fragment. */ public void dismiss() &#123; dismissInternal( false ); &#125; void dismissInternal( boolean allowStateLoss) &#123; if (mDismissed) &#123; return ; &#125; mDismissed = true ; mShownByMe = false ; if (mDialog != null ) &#123; mDialog.dismiss(); mDialog = null ; &#125; mViewDestroyed = true ; if (mBackStackId &gt;= 0 ) &#123; getFragmentManager().popBackStack(mBackStackId, FragmentManager.POP_BACK_STACK_INCLUSIVE); mBackStackId = -1 ; &#125; else &#123; FragmentTransaction ft = getFragmentManager().beginTransaction(); ft.remove( this ); if (allowStateLoss) &#123; ft.commitAllowingStateLoss(); &#125; else &#123; ft.commit(); &#125; &#125; &#125; 我們知道瞭如果一個DialogFragment關閉的時候會檢查堆棧裡面有沒有其他的對象，如果有就pop出來，如果沒有就直接remove和commit。也就是說：如果back stack堆棧有該Dialog，將其pop出來，否則ft.remove(this); ft.commit();。估計pop的操作也包含ft.remove()和ft.commit()。調用dismiss()會觸發onDismiss()回調函數。 跟踪狀態，如下： 通過onCreateView()來建立對話框佈局 上面的例子中我們已經在onCreateView()建立的對話框佈局，這時fragment中建立佈局的傳統寫法， 很適合用於自定義的對話框，我們可以修改任何的東西，包括對話框的style。 上面的例子中我們已經乾掉了對話框上面title的區域，而我們也沒發現可以設置標題的方法， 感覺上面那個標題欄就是個標題黨，毫無意義（之後會說到這塊區域的用處） 。 我們在onCreat中可以設置對話框的風格和各種屬性，但是千萬別設置關於view的東西，因為這時候對話框還沒建立呢，有關於view的東西在onCreatView中去設置吧，這裡我簡單設置了一個button的點擊事件——關閉對話框 123456789101112131415161718192021222324252627282930public class MyDialogFragment extends DialogFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); // 如果setCancelable()中參數為true，若點擊dialog覆蓋不到的activity的空白或者按返回鍵， // 則進行cancel，狀態檢測依次onCancel()和onDismiss()。如參數為false，則按空白處或返回鍵無反應。缺省為true setCancelable( true ); // 可以設置dialog的顯示風格 // setStyle(style,theme); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View rootView = inflater.inflate(R.layout.dialog, null ); Button btn = (Button)rootView.findViewById(R.id.button); btn.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO自動生成的方法存根 dismiss(); &#125; &#125;); return rootView; &#125;&#125; 補充：實現信息保存在activity橫豎屏切換的時候，dialog現在可以自動重建了，如果你在editText中輸入了信息，在重建的時候會不會保留之前的呢？在4.2和4.4中對話框人性化的自定保存了之前輸入的內容，我們無須手動處理。但如果你測試的手機被奇葩的定制了，那就乖乖的保存數據吧。 123456789101112131415161718192021222324public class MyDialogFragment extends DialogFragment &#123; EditText editText; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.dialog, null ); editText = (EditText) rootView.findViewById(R.id.editText); if (savedInstanceState != null ) &#123; CharSequence text = savedInstanceState.getCharSequence( "input data" ); editText.setText(text == null ? "" : text); &#125; return rootView; &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; outState.putCharSequence( "input data" , editText.getText()); super .onSaveInstanceState(outState); &#125;&#125; 通過onCreateDialog()來快捷的建立對話框我們上面建立的對話框都是用自定義佈局的，難道我們之前學過的dialog知識都沒用了麼？我們如果沒自定義對話框的需求，怎麼辦？就沒有一種快一點的方式來建立對話框麼？快用onCreatDialog吧！！！這個回調方法是DialogFragment獨有的，通過它返回的是一個Dialog對象，這個對象就會被顯示到屏幕上。千萬別同時使用onCreatView和onCreatDialog方法，他們僅僅是為了完成同樣一個目的的兩條路而已。 PS：從生命週期的順序而言，先執行onCreateDialog()，後執行onCreateView() 我在onCreatDialog建立一個警告對話框的builder，通過這個builder的create()方法來生成一個AlertDialog對象，因為AlertDialog是Dialog的子類，所以可以直接返回給Dialog。這裡可以用其他不同對話框的builder，代碼類似，只不過就是通過builder的creat()方法返回的是不同的對象而已。builder模式也是蠻巧妙的~ 1234567891011121314151617181920public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener&#123; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ) .setNegativeButton( "不同意", this ) .setCancelable( false ); //.show(); // show cann't be use here return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 &#125;&#125; 顯示效果： 看到了麼，這裡的標題欄終於有用了，原來那個標題欄是為了給我們在這裡用的啊~ 注意： ① 因為這裡創建的是一個dialog，所以用的onclickListener自然是對話框中的listener了。 ② 千萬別在構建對話框對象的時候順手寫了show()方法，我們現在是在fragment中初始化一個對話框，真正讓他顯示的時候是在activity中用這個dialogFragment對象顯示的。如果這裡寫了show方法不會報錯，但是會出現兩個對話框！ 那麼，我們能不能在這裡自定義對話框呢？當然可以啦，本身Dialog.builder就提供了自定義view的方法，和之前用Dialog一樣自定義下viwe就搞定了。 123456789101112131415161718192021@Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.fragment_login_dialog, null ); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout builder.setView(view) // set your own view // Add action buttons .setPositiveButton("Sign in" , new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int id) &#123; &#125; &#125;).setNegativeButton( "Cancel", null ); return builder.create(); &#125; 這裡貼下我在另一篇文章的自定義對話框view的代碼片段： 詳細看這裡：http://www.cnblogs.com/tianzhijiexian/p/3867731.html 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定義視圖對話框 * * @param title */ public void viewDialog(String title) &#123; // LayoutInflater是用來找layout文件夾下的xml佈局文件，並且實例化 LayoutInflater factory = LayoutInflater.from(mContext); // 把activity_login中的控件定義在View中 View view = factory.inflate(R.layout.dialog_layout, null ); // 將LoginActivity中的控件顯示在對話框中 // 獲取用戶輸入的“用戶名”，“密碼” // 注意：view.findViewById很重要，因為上面factory.inflate(R.layout.activity_login, // null)將頁面佈局賦值給了view了 TextView titleTv = (TextView) view .findViewById(R.id.dialog_textView_id); titleTv.setText(title); Button btn = (Button) view.findViewById(R.id.dialog_logout_button_id); btn.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; showToast( "按下自定義視圖的按鈕了~" ); &#125; &#125;); builder // 設定顯示的View .setView(view); // 設置dialog是否為模態，false表示模態，true表示非模態 // ab.setCancelable(false); // 對話框的創建、顯示,這裡顯示的位置是在屏幕的最下面，但是很不推薦這個種做法，因為距底部有一段空隙 AlertDialog dialog = builder.create(); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); // 此處可以設置dialog顯示的位置 window.setWindowAnimations(R.style.myAnimationstyle); // 添加動畫 dialog.show(); &#125; DialogFragment與Activity之前進行通信思路很簡單，就是定義一個傳輸數據的接口，強制activity實現這個接口，在fragment需要傳遞數據的時候去調用這個接口的方法，activity就能在這個方法中得到相應的數據了。這點在之前的fragment傳遞數據中已經介紹過了， 可以參考這篇文章：http://www.cnblogs.com/tianzhijiexian/p/3888330.html 在真正項目中，fragment的編寫並不需要了解activity的各類方法，好的編程風格是將fragment所涉及的方法以接口的方式封裝起來，我在此寫一個例子來說明一下。 寫一個接口——DataCallback123456package com.kale.dialogfragmenttest;public interface DataCallback &#123; public void getData(String data);&#125; activity實現這個接口123456789101112131415161718public class MainActivity extends Activity implements DataCallback&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout.activity_main); new MyDialogFragment() .show(getFragmentManager(), "dialog_fragment" ); &#125; @Override public void getData(String data) &#123; // TODO自動生成的方法存根 System.out.println("data = "+ data); &#125;&#125; 在DialogFragment中使用這個接口在DialogFragment中使用這個接口，並且用instanceof來看啟動它的activity是否實現了這個接口，如果沒實現就拋出異常。這樣我們就能保證在大型項目中不會出現忘記實現這個接口的問題了。 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Activity; import android.app.AlertDialog; import android.app.AlertDialog.Builder; import android.app.Dialog; import android.app.DialogFragment; import android.content.DialogInterface; import android.os.Bundle ;public class MyDialogFragment extends DialogFragment implements android.content.DialogInterface.OnClickListener &#123; @Override public void onAttach(Activity activity) &#123; // onAttach()是合適的早期階段進行檢查MyActivity是否真的實現了接口。 // 採用接口的方式，dialog無需詳細了解MyActivity，只需了解其所需的接口函數，這是真正項目中應採用的方式。 if (!(activity instanceof DataCallback)) &#123; throw new IllegalStateException("fragment所在的Activity必須實現Callbacks接口" ); &#125; super .onAttach(activity); &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Builder builder = new AlertDialog.Builder(getActivity()); builder.setTitle( "用戶申明" ) .setMessage(getResources().getString(R.string.hello_world)) .setPositiveButton( "我同意", this ).setNegativeButton("不同意", this ) .setCancelable( false ); // show(); return builder.create(); &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; // TODO自動生成的方法存根 DataCallback callback = (DataCallback) getActivity(); callback.getData( "test" ); &#125;&#125; 此外fragment也可以通過fragment管理器，通過tag，獲取其他fragment實例，從而進行fragment之間的通信。當然從編程思想的角度看，fragment之間的過多進行交叉調用，不利於程序的管控。 用DialogFragment實現再次彈窗有時候我們可能有這樣的需求，點擊對話框中的一個按鈕後又彈出一個對話框，這個該怎麼做呢？首先在點擊事件中將這個對話框在屏幕上移除，然後把這個fragment壓棧，最後建立一個新的dialogFragment對象，show出來。我們雖然讓這個fragment在屏幕上消失，但還是可以通過fragment管理器到回退棧中找到它。 二次彈窗的代碼：123456789101112131415161718FragmentTransaction ft = getFragmentManager().beginTransaction(); /* * 如果不執行remove()，對話框即不會進入onDismiss()狀態。會被顯示在新的對話框下方，是可見的。 * 主要考慮美觀的問題，如果下面的對話框大於上面的對話框就很難看了。對於Dialog，container為0或者null。 */ ft.remove( this ); /* * 將當前的PromptDialogFragment加入到回退堆棧，當用戶按返回鍵，或者通過按幫助框的Close按鈕dismiss幫助框是， * 重新顯示提示框。對於back stack的處理，系統具有一定的智能。例如：執行兩次addToStackStack()，實際不會重複壓棧。 * 有例如：註釋掉remove()語句，即提示框不消失，而是在幫助框的下面。 * 但是在實驗中發現是否有addToBackStack()都不會結果有影響，系統能夠分析到對象存在，不需要壓棧。沒有去查源代碼， * 猜測通過mBackStackId比對來進行智能處理。 */ ft.addToBackStack( null ); new OhterDialogFragment() .show(getFragmentManager(), "dialog_fragment"); 利用Fragment的特性，為不同屏幕做適配如果我們想在大屏幕上顯示對話框，而小屏幕中直接把對話框的內容放在activity中顯示呢？ 其實也很簡單，本身這個dialogFragment就是一個fragment，所以完全有fragment的特性，你可以用fragmentTranscation將其放到任何佈局中，你也可以用show()方法把它當作dialog顯示出來。接下來就剩下一個問題了，判斷屏幕大小。 在默認的values下新建一個bools.xml 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; false &lt;/ bool &gt; &lt;/ resources &gt; 然後，在res下新建一個values-large，在values-large下再新建一個bools.xml，通過加載不同的value就能知道是大屏還是小屏幕啦 1234&lt;? xml version="1.0" encoding="utf-8" ?&gt; &lt; resources &gt; &lt; bool name ="large_layout" &gt; true &lt;/ bool &gt; &lt;/ resources &gt; 在代碼中進行判斷 123456789101112131415161718192021public void showDialogInDifferentScreen(View view) &#123; FragmentManager fragmentManager = getFragmentManager(); EditNameDialogFragment newFragment = new EditNameDialogFragment(); boolean mIsLargeLayout = getResources().getBoolean(R.bool.large_layout) ; Log.e( "TAG", mIsLargeLayout+"" ); if (mIsLargeLayout ) &#123; // The device is using a large layout, so show the fragment as a // dialog newFragment.show(fragmentManager, "dialog" ); &#125; else &#123; // The device is smaller, so show the fragment fullscreen FragmentTransaction transaction = fragmentManager.beginTransaction(); // For a little polish, specify a transition animation transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN); // To make it fullscreen , use the 'content' root view as the // container for the fragment, which is always the root view for the activity transaction.replace(R.id.id_ly, newFragment).commit(); &#125; &#125; 參考http://blog.csdn.net/huangyabin001/article/details/30053835 http://blog.csdn.net/lmj623565791/article/details/37815413 http://www.cnblogs.com/tianzhijiexian/p/4161811.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升倉管備料效率-小程式]]></title>
      <url>%2F2017%2F01%2F19%2Favexir%E5%82%99%E6%96%99%2F</url>
      <content type="text"><![CDATA[計算bom表 小程式前言 版權聲明：轉載請保留原文連結及作者由於公司產品種類太多,User RMA回來數量都一樣兩樣很散一個User要去ERP開一張單,但ERP沒辦法把多張單合併包材集中在一張單,導致倉管必須一張單一張單備料由於這樣實在沒效率,所以寫個小程式把User購買的外部料號KEY在程式裡自動會算出需要的包材數量 效果 把外部料號,內部料號打進去會自動算出,倉管需要備東西把客戶名稱日期打上,可以記錄倉管幾月幾號幫RMA備料倉管可以自行反查紀錄,也會紀錄備料人員是誰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Textinputlayout使用及自訂義顏色]]></title>
      <url>%2F2017%2F01%2F16%2FTextinputlayout%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%87%AA%E8%A8%82%E7%BE%A9%E9%A1%8F%E8%89%B2%2F</url>
      <content type="text"><![CDATA[版權聲明：轉載請保留原文連結及作者http://blog.csdn.net/android_freshman/article/details/51136657 Textinputlayout gradle 配置12compile ‘com.Android.support:design:22.2.0’compile ‘com.android.support:appcompat-v7:22.2.0’ xml1234private android.widget.LinearLayout.LayoutParams setEditText(EditText editText, LayoutParams lp) &#123; if(this.mEditText != null) &#123; throw new IllegalArgumentException("We already have an EditText, can only have one"); &#125; else &#123; 注意點：部分源代碼中的內容，TextInputLayout 繼承LinearLayout 且裡面只能有一個editEditText，和scrollView 很像。下面是佈局文件： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.design.widget.TextInputLayout android:id="@+id/titleTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:layout_marginLeft="40dp" android:layout_marginRight="15dp" app:errorTextAppearance="@style/TextInput_Error_style"&gt; &lt;EditText android:id="@+id/title" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/white" android:singleLine="true" android:hint="Title"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/descriptionsTextInput" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="40dp" android:layout_marginRight="15dp"&gt; &lt;EditText android:id="@+id/descriptions" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp" android:textColor="@color/white" android:hint="Descriptions"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; java 注意：不能重寫TextInputLayout的OnFocusChangeListener的監聽事件，因為在源代碼中定義了動畫效果和editText注入，重寫了會導致動畫失效。設置浮動標籤動畫效果titleTextInput.setHint(“Title”); 123456if(titleEditText.getText().toString().length()&lt;6)&#123; titleTextInput.setErrorEnabled(true); titleTextInput.setError("title length must &gt;= 6");&#125;else &#123; titleTextInput.setErrorEnabled(false);&#125; 這一部分是動態錯誤提示的相關代碼 完成上面的，基本就可以出現TextInputLayout 的動畫效果了，但是默認的顏色不是很好看，所以我們需要自定義相關的顏色，比如hint 字的顏色，下劃線的顏色，錯誤字體的顏色大小等，下面就是自定義顏色的部分： google把Design Support Library寫的很好。每一個控件的顏色都是直接通過主題顏色繪製的，在style.xml 中指定。打開它添加colorAccent 到主題以改變表單的顏色。在style.xml 中修改相關的屬性 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/primary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/primary_dark&lt;/item&gt; &lt;!--&lt;item name="colorAccent"&gt;#3498db&lt;/item&gt;--&gt; &lt;item name="android:textColorHint"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlNormal"&gt;@color/alpha_white&lt;/item&gt; &lt;item name="colorControlActivated"&gt;@color/white&lt;/item&gt; &lt;item name="colorControlHighlight"&gt;@color/white&lt;/item&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; colorAccent 是什麼意思，哪裡的顏色 這張圖片基本說明了colorAccent代表的顏色，而在google的官網上：https://www.google.com/design/spec/style/color.html#color-color-schemes 也有相關的說明 其他相關顏色的說明 android:textColorHint代表hint的顏色colorControlNormal代表下劃線沒有獲取焦點的顏色colorControlActivated，colorControlHighlight代表了獲取焦點或者點擊的時候下劃線的顏色 錯誤提示的顏色說明：默認的錯誤提示的顏色是紅色：在這種背景色下面，紅色不是很好看，所以需要自定義顏色 在設置佈局的時候errorTextAppearance這個屬性，自定義style 寫顏色和大小就可以了，至於另一個屬性hintTextAppearance 這個屬性修改顏色，好像沒有什麼效果，不起作用。 修改之後的效果，如下圖：有的機器上面可能沒有效果，下面提供一種解決方案： 123456789101112public static void setErrorTextColor(TextInputLayout textInputLayout, int color) &#123; try &#123; Field fErrorView = TextInputLayout.class.getDeclaredField("mErrorView"); fErrorView.setAccessible(true); TextView mErrorView = (TextView) fErrorView.get(textInputLayout); Field fCurTextColor = TextView.class.getDeclaredField("mCurTextColor"); fCurTextColor.setAccessible(true); fCurTextColor.set(mErrorView, color); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 這個是material design 的說明文檔：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText 的拍擋 - TextInputLayout]]></title>
      <url>%2F2017%2F01%2F14%2FTextInputLayout%2F</url>
      <content type="text"><![CDATA[toggleButtong 版權聲明：轉載請保留原文連結及作者http://blog.30sparks.com/material-design-6-textinputlayout/ Android Design Support Library 提供一個TextInputLayout 元件，可用來包著 EditText，令 EditText 得到 focus 時，自動將 hints 變成標題： 1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" &gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Your name" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 效果 一個 TextInputLayout 只能容納一個 EditText，所以每個 EditText都需要自訂各自的 TextInputLayout。 關於 HintTextInputLayout 可直接使用 EditText 上的 hint，用來當成 header 。不過，你也可直接設定 hint 到 TextInputLayout 上，它們的效果也是相同的，值得留意的是，你可同時設定 hint 到 TextInputLayout 和 EditText 上。這樣的話，它們一開始會重叠，而當拿到 focus 時，在 TextInputLayout 上的 hint 會被拿來當 header ，而在 EditText 上的會跟以往一樣，有文字輸入後 hint 會消失。不過我想，在正常情況下應該不會這樣做吧？ 字數統計可使用 app:counterEnabled=&quot;true&quot; 和 app:counterMaxLength 可設定顯示輸入文字的長度。 錯誤訊息 TextInputLayout 還有另一好處，是可以顯示錯誤訊息。透過 textInputLayout.setError(&quot;Erorr in name input&quot;)便在底部可顯示錯誤訊息。 例如為我們之前加的 EditText 加進驗証的的話，可以這樣做 123456789101112131415 final TextInputLayout nameLayout = (TextInputLayout)findViewById(R.id.til_et_name);final EditText nameEditText = (EditText)findViewById(R.id.et_name);final Button button = (Button) findViewById(R.id.btn_submit);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(nameEditText.length() == 0)&#123; nameLayout.setError("Error in name input"); &#125; else&#123; nameLayout.setError(null); &#125; &#125;&#125;); 這樣當按 button 時，若 nameEditText 沒有文字的話，便會顯示 “Error in name input”。 不過有留意到顯示錯誤訊息時，整個 messageEditText 會被推下，因為當初 TextInputLayout 沒有預留空間去顯示錯誤訊息！想避免此情況，可以先設定1nameLayout.setErrorEnabled(true); 或者在 layout xml 上加入app:errorEnabled=&quot;true&quot; 123456&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/content_view" app:errorEnabled="true" &gt; 這樣，TextInputLayout 便會預留空間去顯示錯誤訊息了。留意的是，你可用 nameLayout. setErrorEnabled(false) 的話，去消除錯誤訊息，但整個layout 會被拉上去 (因錯誤訊息的位置也會被消除)。若不想 layout 移動的話，便應用nameLayout.setError(null) 去消除。 Style顏色想簡單更改底線顏色的話，可到 style.xml 修改 colorAccent 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- ...other style settings --&gt; &lt;item name="colorAccent"&gt;#0000FF&lt;/item&gt;&lt;/style&gt; header若只想改變 header 顏色 ，可使用 app:hintTextAppearance=&quot;style&quot;。先到 style.xml 中加入 TextInputHint 1234&lt;style name="TextInputHint" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#AA2288&lt;/item&gt;&lt;/style&gt; 然後加到 TextInputLayout 加入 app:hintTextAppearance=&quot;@style/TextInputHint &quot; 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:hintTextAppearance ="@style/TextInputHint "&gt; 佷簡單便可修改 header 的風格了。 錯誤訊息要更改錯誤訊息的顏色的話，跟改 header顏色的方法差不多，這次使用的是app:errorTextAppearance。 style.xml: 1234&lt;style name="TextInputError" parent="TextAppearance.AppCompat.Small"&gt; &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt; &lt;item name="android:textColor"&gt;#FF00FF&lt;/item&gt;&lt;/style&gt; layout: 1234567&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_et_name" android:layout_width="match_parent" android:layout_height="wrap_content" app:errorEnabled="true" app:errorTextAppearance="@style/TextInputError"&gt; 這樣便可以自訂錯誤訊息的風格了。 結語要令文字輸入的 UI 更具動感，TextInputLayout 是一個很方便簡單的工具。快加到你的 UI 中吧。 相關連結 Material Design Patterns 官方文件 - TextInputLayout Working with the EditText]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-line聊天分割]]></title>
      <url>%2F2017%2F01%2F13%2Fjava-line%2F</url>
      <content type="text"><![CDATA[line 聊天記錄 分割 版權聲明：轉載請保留原文連結及作者以前想看line紀錄但太長了寫了一個以日期來分聊天記錄的小程式但效率不是很好也沒有太多時間回去在優化他了如果剛學java的可以自己寫一個看看 效果 主要思路 把txt讀近來後每一行判斷字串 是否有日期例如2016/01/31（日） 先把日期改成你想要的方式 先儲存一份在讀取新的txt 讀到你更改後的日期格式,把日期存成檔案名稱裡面的內容存到txt裡,讀到下一個日期停止先存一份更改日期的用意是.聊天內容或許會有日期或是/ 會抓錯其他應該很簡單就不再詳細敘述了分割好的內容會自動存在C:\LINE 資料夾內 下載點 下載點]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toggleButton]]></title>
      <url>%2F2017%2F01%2F05%2FtoggleButton%2F</url>
      <content type="text"><![CDATA[自定義toggleButtong 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下 效果 程式碼 程式碼分成兩類 圖片繪製 點擊事件 布局XML 直接打上自定義原件類別名就可 12345678&lt;com.togg.toggiebutton.CustomToggleButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tb_backround" android:id="@+id/view"&gt;&lt;/com.togg.toggiebutton.CustomToggleButton&gt; onMeasure12345678910protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //底層圖片 backBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tb_backround); //上層圖片 overBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.slide_backround); //寬高和底層圖片一樣 setMeasuredDimension(backBitmap.getWidth(), backBitmap.getHeight()); &#125; onDraw1234567891011121314151617181920212223242526272829303132protected void onDraw(Canvas canvas) &#123; //2.繪制上層圖片 if (isTounching) &#123;//上層圖片跟随滑動 /** * * 防止上層圖片滑動出下層圖片的范围 */ //算出當前觸碰點為上層圖片的中心點時，上層圖片的左侧座標距離 int left = currentX - overBitmap.getWidth() / 2; System.out.println(left + "left 數值" + currentX + "currentx"); if (left &lt; 0) &#123;//防止左侧出界 left = 0; &#125; else if (left &gt; backBitmap.getWidth() - overBitmap.getWidth()) &#123;//防止右侧出界 left = backBitmap.getWidth() - overBitmap.getWidth(); &#125; canvas.drawBitmap(overBitmap, left, 0, null); &#125; else &#123;//上層圖片直接跳到開或關的位置 if (state) &#123; //開 canvas.drawBitmap(overBitmap, backBitmap.getWidth() - overBitmap.getWidth(), 0, null); listener.rightClick(); &#125; else &#123; //關 canvas.drawBitmap(overBitmap, 0, 0, null); listener.leftClick(); &#125; &#125; &#125; onTouchEvent123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //按下為true isTounching = true; //當前觸碰點的x座標 currentX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: isTounching = true; currentX = (int) event.getX(); break; case MotionEvent.ACTION_UP: //抬起時觸碰狀態為false isTounching = false; currentX = (int) event.getX(); break; &#125; //觸碰點超過底層圖片的一半，則state為true,開的狀態 state = currentX &gt; backBitmap.getWidth() / 2; //重新繪制 invalidate(); return true; &#125; 點擊1234567891011private topbarClickListener listener; public interface topbarClickListener &#123; public void leftClick(); public void rightClick(); &#125; public void setOntopbarClickListener(topbarClickListener listener) &#123; this.listener = listener; &#125; MainActivity12345678910111213CustomToggleButton cust = (CustomToggleButton) findViewById(R.id.view); cust.setOntopbarClickListener(new CustomToggleButton.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left click", Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this,"right click",Toast.LENGTH_SHORT).show(); &#125; &#125;); 結尾 這個樣子可直接在你要使用的類 直接new就可以直接使用了 如果要使用各式各樣的開關 只需更改圖片 就可直接使用了 如果一個程式要使用多種開關 把onMeasure 裡面的底層 上層圖寫成外部輸入圖就可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 end]]></title>
      <url>%2F2016%2F12%2F31%2F2016-end%2F</url>
      <content type="text"><![CDATA[離起點又遠了一些,離終點又進了一點無論今天在困難,明天終究會到來無論今年發生多少事,到了明年還是會變成回憶中的故事這一切終究會拼湊成一個一個完整的人生新的一年,不要忘了完成那些該完成的事情謝謝周遭的許多人幫助了我非常非常多的事情有了你們這一切才會變成可行的事情 2016年度總結 今年接了幾個開發的案子,經歷了一大段很挫折壓力大到爆表的日子也接了幾個私人伺服器的協助開發,這段日子應該算是最快樂的,有錢賺還可以玩遊戲XDD也謝謝幾位高材生協助指導讓我完成這一串事情..整年度大部分時間都在學著嵌入式開發,當要開發的時候C已經忘得差不多了,花了很多的時間在學這一部分,在硬體開發部分由於對於電路不是很懂,有時候並不是代碼有寫錯而是電路的問題,常常在浪費時間在原地打轉.每當回去寫APP的時候都會忘記那時候到底在寫什麼,寫到了哪裡,那時候在想什麼年初給自己的目標,完成了六成,希望明年可以在努力一點今年應該算是最枯燥的一年,但今年的知識吸收量應該是以前的好幾倍,已結果來說還蠻滿意的年底架設了這個部落格,慢慢的會把自己所開發的過程放上來,如果有時間會把一些開源也慢慢的會把evernote上記錄的資料也移過來 2016書單 學失敗：創業熱時代看不見的退場故事 創業投資聖經：Startup募資、天使投資人、投資契約、談判策略全方位教戰法則 免費！揭開零定價的獲利祕密 自己的品牌自己做：企業自媒化，營造忠實顧客群的品牌經營方針 競爭論 創業的藝術 工作大解放：這樣做事反而更成功 從0到1：打開世界運作的未知祕密，在意想不到之處發現價值 全方位把玩Android 400個API：精挑細選365個實例說明 ARM Cortex-M4+Wi-Fi MCU應用指南：CC3200 CCS基礎篇 ARM Cortex-M3與Cortex-M4權威指南 拖延心理學：為什麼我老是愛拖延？是與生俱來的壞習慣，還是身不由己？ 創新者的窘境 30年心血，品牌之父艾克終於說出的品牌王道：微軟、可口可樂、麥當勞、三星、P&amp;G，全球行銷長都在讀的20終極法則 今年淺讀了這些書,雖然還有幾本還沒讀完..!!!!!2016也訂了一年份的空中英語教室月刊希望明年的今天語言部分可以進步很多 20172017 年度計畫 今年預計後半年要花點時間學python 今年也會開始學Machine Learning很大部分會完成2016該完成還沒完成的事情,加上一點突發狀況明年應該就這樣結束了慢慢的習慣把學習紀錄,資料記錄寫到部落格上 2017 書單 引爆社群：移動互聯網時代的新4C法則 稀缺：我們是如何陷入貧窮與忙碌的 TED TALKS 說話的力量：你可以用言語來改變自己，也改變世界 TED唯一官方版演講指南 不懂帶團隊，那就大家一起死！：行為科學教你把豬一般的隊友變菁英 沒經驗，是你最大優勢 賽局理論，解決問題最簡單的方法 文案力：如果沒有文案，這世界會有多無聊？ 釣愚：操縱與欺騙的經濟學 Python 自動化的樂趣｜搞定重複瑣碎 &amp;單調無聊的工作 解事者：複雜的事物我簡單說明白 如果這樣，會怎樣？：胡思亂想的搞怪趣問 正經認真的科學妙答 商業冒險：華爾街的12個經典故事 債的歷史：從文明的初始到全球負債時代 我的思考，我的光：諾貝爾獎得主中村修二創新突破的7個思考原點 如果中途有看到喜歡的書在新增上來 END 想起前陣子跟朋友討論一本俄羅斯的小說裡面有段話挺有趣的真正的窮人,是那種群聚在一起的人,而孑然一身的窮人,不過是沒賺到錢的有錢人罷了 任何值得去的地方 都沒有捷徑努力配得上你的夢想那麼你的夢想也不會辜負你的努力送給自己一句話自律能讓你更優秀 加油！！！！2016再見 2017加油!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout]]></title>
      <url>%2F2016%2F12%2F15%2FMy-New-post%2F</url>
      <content type="text"><![CDATA[FragmentPagerAdapter+ViewPager 實現TabLayout 版權聲明：轉載請保留原文連結及作者最近剛好在寫UI順便記錄一下在安卓5.0有新增了TabLauout但他並不能滿足很多時候想顯示的樣子所以使用V4下的FragmentPagerAdapter來實現.請記得都要import v4 否則會報錯呈現的效果如下 效果 程式碼 程式碼分成四類 FragmentPagerAdapter ArrayList&lt;Fragment&gt;() 初始化三個布局 更改點擊的布局屬性 布局XML 從上面的效果可以看的出來 沒選重的狀況下其他兩個字體大小要一置 選重的要變大 下底線要與字體長度一樣 程式碼如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="55dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:orientation="horizontal"&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/id_tab_trend" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_trend" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_trend_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_surrounding" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_sourrounding" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_surrounding_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_appliances" android:layout_width="0dp" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/id_tab_tv_appliances" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#D6EDC6" /&gt; &lt;ImageView android:id="@+id/id_tab_appliances_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/tabline" android:layout_gravity="center" android:layout_marginTop="5dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 在一個LinearLayout裡面 再放三個`LinearLayout`` 按照比例分配`android:layout_weight=”1”`` 點擊後在程式碼將點擊的layout_weight 改成你要的比例在把字體放大 Fragment1234567mFragment = new ArrayList&lt;Fragment&gt;(); Fragment mTab01 = new TrendFragment(); Fragment mTab02 = new SurroundingFragment(); Fragment mTab03 = new AppliancesFragment(); mFragment.add(mTab01); mFragment.add(mTab02); mFragment.add(mTab03); FragmentPagerAdapter1234567891011121314151617181920212223242526272829303132333435mAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragment.get(position); &#125; @Override public int getCount() &#123; return mFragment.size(); &#125; &#125;; mViewPager.setAdapter(mAdapter); // Touch Replace the content area mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; 重置 這邊來判斷字的寬度 來依照讀取的寬度來設定線的長度 這邊只貼其中一組 textview ImageView 請在自行補上其他的1234567891011private void resetColor() &#123; mTvTrend.setTextColor(getResources().getColor(R.color.tab_not_selectedl_Color)); mTvTrend.setTextSize(NOT_SELECTED); mTvTrend.setText(one); mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayoutCompat.LayoutParams.WRAP_CONTENT, 1.0f)); mTabtrendImg.setBackgroundResource(R.drawable.tabline); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); 點擊 在點擊的時候先呼叫一次resetColor(); 在設定布局比例 文字大小 123456public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.id_tab_trend: setSelect(0); break; 12345678910111213141516public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 滑動 別忘了上面寫的ViewPage事件 12345public void onPageSelected(int position) &#123; int currentItem = mViewPager.getCurrentItem(); setTab(currentItem); &#125; 123456789101112131415public void setSelect(int i) &#123; resetColor(); switch (i) &#123; case 0: mTabTrend.setLayoutParams(new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.5f)); mTvTrend.setTextColor(getResources().getColor(R.color.tab_selectedl_Color)); mTvTrend.setTextSize(SELECTED); mTvTrend.setText("O N E"); mTabtrendImg.setBackgroundResource(R.drawable.tablineselect); mTvTrend.measure(0, 0); LinearLayout.LayoutParams trend = new LinearLayout.LayoutParams(mTvTrend.getMeasuredWidth(), LinearLayout.LayoutParams.WRAP_CONTENT); mTabtrendImg.setLayoutParams(trend); break; 結尾 程式碼可以在寫一個class來去放 這樣會比較好維護一點 下底線圖片要改成.9會比較好一點]]></content>
    </entry>

    
  
  
</search>
